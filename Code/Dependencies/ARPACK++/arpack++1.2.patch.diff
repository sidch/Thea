diff -rupN arpack++1.2.orig/examples/areig/complex/acompsol.h arpack++1.2.patched/examples/areig/complex/acompsol.h
--- arpack++1.2.orig/examples/areig/complex/acompsol.h	2000-02-21 19:33:35.000000000 +0100
+++ arpack++1.2.patched/examples/areig/complex/acompsol.h	2006-01-26 15:37:47.000000000 +0100
@@ -18,7 +18,7 @@
 #ifndef ACOMPSOL_H
 #define ACOMPSOL_H
 
-#include <math.h>
+#include <cmath>
 #include "arcomp.h"
 #include "blas1c.h"
 #include "lapackc.h"
@@ -30,7 +30,7 @@ void Solution(ARINT nconv, ARINT n, ARIN
               arcomplex<ARFLOAT>* EigVec = 0)
 /*
   Prints eigenvalues and eigenvectors of nonsymmetric eigen-problems
-  on standard "cout" stream.
+  on standard "std::cout" stream.
 */
 
 {
@@ -40,20 +40,20 @@ void Solution(ARINT nconv, ARINT n, ARIN
   ARFLOAT*                                      ResNorm;
   ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> matrix(n, nnz, A, irow, pcol);
 
-  cout << endl << endl << "Testing ARPACK++ function AREig" << endl;
-  cout << "complex standard eigenvalue problem: A*x - lambda*x \n \n";
+  std::cout<< std::endl << std::endl << "Testing ARPACK++ function AREig" << std::endl;
+  std::cout<< "complex standard eigenvalue problem: A*x - lambda*x \n \n";
 
-  cout << "Dimension of the system            : " << n     << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv << endl << endl;
+  std::cout<< "Dimension of the system            : " << n     << std::endl;
+  std::cout<< "Number of 'converged' eigenvalues  : " << nconv << std::endl << std::endl;
 
   // Printing eigenvalues.
 
-  cout << "Eigenvalues:" << endl;
+  std::cout<< "Eigenvalues:" << std::endl;
 
   for (i=0; i<nconv; i++) {
-    cout << "  lambda[" << (i+1) << "]: " << EigVal[i] << endl;
+    std::cout<< "  lambda[" << (i+1) << "]: " << EigVal[i] << std::endl;
   }
-  cout << endl;
+  std::cout<< std::endl;
 
   // Printing eigenvectors.
 
@@ -72,10 +72,10 @@ void Solution(ARINT nconv, ARINT n, ARIN
     }
 
     for (i=0; i<nconv; i++) {
-      cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
-      cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << endl;
+      std::cout<< "||A*x(" << (i+1) << ") - lambda(" << (i+1);
+      std::cout<< ")*x(" << (i+1) << ")||: " << ResNorm[i] << std::endl;
     }
-    cout << endl;
+    std::cout<< std::endl;
 
     delete[] Ax;
     delete[] ResNorm;
@@ -92,7 +92,7 @@ void Solution(ARINT nconv, ARINT n, ARIN
               arcomplex<ARFLOAT> EigVal[], arcomplex<ARFLOAT>* EigVec = 0)
 /*
   Prints eigenvalues and eigenvectors of nonsymmetric generalized
-  eigen-problem on standard "cout" stream.
+  eigen-problem on standard "std::cout" stream.
 */
 
 {
@@ -104,20 +104,20 @@ void Solution(ARINT nconv, ARINT n, ARIN
   ARluNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT> matrixA(n, nnzA, A, irowA, pcolA);
   ARluNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT> matrixB(n, nnzB, B, irowB, pcolB);
 
-  cout << endl << endl << "Testing ARPACK++ function AREig" << endl;
-  cout << "Complex generalized eigenvalue problem: A*x - lambda*B*x \n \n";
+  std::cout<< std::endl << std::endl << "Testing ARPACK++ function AREig" << std::endl;
+  std::cout<< "Complex generalized eigenvalue problem: A*x - lambda*B*x \n \n";
 
-  cout << "Dimension of the system            : " << n     << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv << endl << endl;
+  std::cout<< "Dimension of the system            : " << n     << std::endl;
+  std::cout<< "Number of 'converged' eigenvalues  : " << nconv << std::endl << std::endl;
 
   // Printing eigenvalues.
 
-  cout << "Eigenvalues:" << endl;
+  std::cout<< "Eigenvalues:" << std::endl;
 
   for (i=0; i<nconv; i++) {
-    cout << "  lambda[" << (i+1) << "]: " << EigVal[i] << endl;
+    std::cout<< "  lambda[" << (i+1) << "]: " << EigVal[i] << std::endl;
   }
-  cout << endl;
+  std::cout<< std::endl;
 
   // Printing eigenvectors.
 
@@ -138,10 +138,10 @@ void Solution(ARINT nconv, ARINT n, ARIN
     }
 
     for (i=0; i<nconv; i++) {
-      cout << "||A*x(" << i << ") - lambda(" << i;
-      cout << ")*B*x(" << i << ")||: " << ResNorm[i] << endl;
+      std::cout<< "||A*x(" << i << ") - lambda(" << i;
+      std::cout<< ")*B*x(" << i << ")||: " << ResNorm[i] << std::endl;
     }
-    cout << endl;
+    std::cout<< std::endl;
 
     delete[] Ax;
     delete[] Bx;
diff -rupN arpack++1.2.orig/examples/areig/complex/Makefile arpack++1.2.patched/examples/areig/complex/Makefile
--- arpack++1.2.orig/examples/areig/complex/Makefile	2000-02-18 21:22:18.000000000 +0100
+++ arpack++1.2.patched/examples/areig/complex/Makefile	2006-01-26 15:37:47.000000000 +0100
@@ -36,7 +36,7 @@ acompgre:        acompgre.o
 
 .PHONY:	clean
 clean:
-	rm -f *~ *.o core
+	rm -f *~ *.o core acompgre acompgsh acompreg acompshf
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/examples/areig/nonsym/ansymsol.h arpack++1.2.patched/examples/areig/nonsym/ansymsol.h
--- arpack++1.2.orig/examples/areig/nonsym/ansymsol.h	2000-02-21 19:45:48.000000000 +0100
+++ arpack++1.2.patched/examples/areig/nonsym/ansymsol.h	2006-01-26 15:37:47.000000000 +0100
@@ -18,7 +18,7 @@
 #ifndef ANSYMSOL_H
 #define ANSYMSOL_H
 
-#include <math.h>
+#include <cmath>
 #include "blas1c.h"
 #include "lapackc.h"
 #include "arlnsmat.h"
@@ -29,7 +29,7 @@ void Solution(ARINT nconv, ARINT n, ARIN
               ARFLOAT* EigVec = 0)
 /*
   Prints eigenvalues and eigenvectors of nonsymmetric eigen-problem
-  on standard "cout" stream.
+  on standard "std::cout" stream.
 */
 
 {
@@ -39,26 +39,26 @@ void Solution(ARINT nconv, ARINT n, ARIN
   ARFLOAT*                           ResNorm;
   ARluNonSymMatrix<ARFLOAT, ARFLOAT> matrix(n, nnz, A, irow, pcol);
 
-  cout << endl << endl << "Testing ARPACK++ function AREig" << endl;
-  cout << "Real nonsymmetric eigenvalue problem: A*x - lambda*x \n \n";
+  std::cout << std::endl << std::endl << "Testing ARPACK++ function AREig" << std::endl;
+  std::cout << "Real nonsymmetric eigenvalue problem: A*x - lambda*x \n \n";
 
-  cout << "Dimension of the system            : " << n     << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv << endl << endl;
+  std::cout << "Dimension of the system            : " << n     << std::endl;
+  std::cout << "Number of 'converged' eigenvalues  : " << nconv << std::endl << std::endl;
 
   // Printing eigenvalues.
 
-  cout << "Eigenvalues:" << endl;
+  std::cout << "Eigenvalues:" << std::endl;
 
   for (i=0; i<nconv; i++) {
-    cout << "  lambda[" << (i+1) << "]: " << EigValR[i];
+    std::cout << "  lambda[" << (i+1) << "]: " << EigValR[i];
     if (EigValI[i]>=0.0) {
-      cout << " + " << EigValI[i] << " I" << endl;
+      std::cout << " + " << EigValI[i] << " I" << std::endl;
     }
     else {
-      cout << " - " << fabs(EigValI[i]) << " I" << endl;
+      std::cout << " - " << fabs(EigValI[i]) << " I" << std::endl;
     }
   }
-  cout << endl;
+  std::cout << std::endl;
 
   // Printing eigenvectors.
 
@@ -97,10 +97,10 @@ void Solution(ARINT nconv, ARINT n, ARIN
     }
 
     for (i=0; i<nconv; i++) {
-      cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
-      cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << endl;
+      std::cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
+      std::cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
 
     delete[] Ax;
     delete[] ResNorm;
@@ -117,7 +117,7 @@ void Solution(ARINT nconv, ARINT n, ARIN
               ARFLOAT* EigVec = 0)
 /*
   Prints eigenvalues and eigenvectors of nonsymmetric generalized
-  eigen-problem on standard "cout" stream.
+  eigen-problem on standard "std::cout" stream.
 */
 
 {
@@ -129,27 +129,27 @@ void Solution(ARINT nconv, ARINT n, ARIN
   ARluNonSymMatrix<ARFLOAT, ARFLOAT> matrixA(n, nnzA, A, irowA, pcolA);
   ARluNonSymMatrix<ARFLOAT, ARFLOAT> matrixB(n, nnzB, B, irowB, pcolB);
 
-  cout << endl << endl << "Testing ARPACK++ function AREig" << endl;
-  cout << "Real nonsymmetric generalized eigenvalue problem: A*x - lambda*B*x";
-  cout << endl << endl;
+  std::cout << std::endl << std::endl << "Testing ARPACK++ function AREig" << std::endl;
+  std::cout << "Real nonsymmetric generalized eigenvalue problem: A*x - lambda*B*x";
+  std::cout << std::endl << std::endl;
 
-  cout << "Dimension of the system            : " << n     << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv << endl << endl;
+  std::cout << "Dimension of the system            : " << n     << std::endl;
+  std::cout << "Number of 'converged' eigenvalues  : " << nconv << std::endl << std::endl;
 
   // Printing eigenvalues.
 
-  cout << "Eigenvalues:" << endl;
+  std::cout << "Eigenvalues:" << std::endl;
 
   for (i=0; i<nconv; i++) {
-    cout << "  lambda[" << (i+1) << "]: " << EigValR[i];
+    std::cout << "  lambda[" << (i+1) << "]: " << EigValR[i];
     if (EigValI[i]>=0.0) {
-      cout << " + " << EigValI[i] << " I" << endl;
+      std::cout << " + " << EigValI[i] << " I" << std::endl;
     }
     else {
-      cout << " - " << fabs(EigValI[i]) << " I" << endl;
+      std::cout << " - " << fabs(EigValI[i]) << " I" << std::endl;
     }
   }
-  cout << endl;
+  std::cout << std::endl;
 
   // Printing eigenvectors.
 
@@ -193,10 +193,10 @@ void Solution(ARINT nconv, ARINT n, ARIN
     }
 
     for (i=0; i<nconv; i++) {
-      cout << "||A*x(" << i << ") - lambda(" << i;
-      cout << ")*B*x(" << i << ")||: " << ResNorm[i] << endl;
+      std::cout << "||A*x(" << i << ") - lambda(" << i;
+      std::cout << ")*B*x(" << i << ")||: " << ResNorm[i] << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
 
     delete[] Ax;
     delete[] Bx;
diff -rupN arpack++1.2.orig/examples/areig/nonsym/Makefile arpack++1.2.patched/examples/areig/nonsym/Makefile
--- arpack++1.2.orig/examples/areig/nonsym/Makefile	2000-02-18 22:19:24.000000000 +0100
+++ arpack++1.2.patched/examples/areig/nonsym/Makefile	2006-01-26 15:37:47.000000000 +0100
@@ -42,7 +42,7 @@ ansymgsc:        ansymgsc.o
 
 .PHONY:	clean
 clean:
-	rm -f *~ *.o core
+	rm -f *~ *.o core ansymgre ansymgsc ansymgsh ansymreg ansymshf simple
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/examples/areig/nonsym/simple.cc arpack++1.2.patched/examples/areig/nonsym/simple.cc
--- arpack++1.2.orig/examples/areig/nonsym/simple.cc	2000-02-18 22:17:43.000000000 +0100
+++ arpack++1.2.patched/examples/areig/nonsym/simple.cc	2006-01-26 15:37:47.000000000 +0100
@@ -18,7 +18,7 @@
 
 #include "lnmatrxc.h"
 #include "areig.h"
-#include <math.h>
+#include <cmath>
 
 int main()
 {
@@ -50,16 +50,16 @@ int main()
 
   // Printing eigenvalues.
 
-  cout << "Eigenvalues:" << endl;
+  std::cout << "Eigenvalues:" << std::endl;
   for (int i=0; i<nconv; i++) {
-    cout << "  lambda[" << (i+1) << "]: " << EigValR[i];
+    std::cout << "  lambda[" << (i+1) << "]: " << EigValR[i];
     if (EigValI[i]>=0.0) {
-      cout << " + " << EigValI[i] << " I" << endl;
+      std::cout << " + " << EigValI[i] << " I" << std::endl;
     }
     else {
-      cout << " - " << fabs(EigValI[i]) << " I" << endl;
+      std::cout << " - " << fabs(EigValI[i]) << " I" << std::endl;
     }
   }
-  cout << endl;
+  std::cout << std::endl;
 
 } // main
diff -rupN arpack++1.2.orig/examples/areig/sym/asymsol.h arpack++1.2.patched/examples/areig/sym/asymsol.h
--- arpack++1.2.orig/examples/areig/sym/asymsol.h	2000-02-21 19:53:20.000000000 +0100
+++ arpack++1.2.patched/examples/areig/sym/asymsol.h	2006-01-26 15:37:47.000000000 +0100
@@ -18,7 +18,7 @@
 #ifndef ASYMSOL_H
 #define ASYMSOL_H
 
-#include <math.h>
+#include <cmath>
 #include "blas1c.h"
 #include "lapackc.h"
 #include "arlsmat.h"
@@ -28,7 +28,7 @@ void Solution(ARINT nconv, ARINT n, ARIN
               ARINT pcol[], char uplo, ARFLOAT EigVal[], ARFLOAT* EigVec = 0)
 /*
   Prints eigenvalues and eigenvectors of symmetric eigen-problems
-  on standard "cout" stream.
+  on standard "std::cout" stream.
 */
 
 {
@@ -38,20 +38,20 @@ void Solution(ARINT nconv, ARINT n, ARIN
   ARFLOAT*               ResNorm;
   ARluSymMatrix<ARFLOAT> matrix(n, nnz, A, irow, pcol, uplo);
 
-  cout << endl << endl << "Testing ARPACK++ function AREig" << endl;
-  cout << "Real symmetric eigenvalue problem: A*x - lambda*x \n \n";
+  std::cout << std::endl << std::endl << "Testing ARPACK++ function AREig" << std::endl;
+  std::cout << "Real symmetric eigenvalue problem: A*x - lambda*x \n \n";
 
-  cout << "Dimension of the system            : " << n     << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv << endl << endl;
+  std::cout << "Dimension of the system            : " << n     << std::endl;
+  std::cout << "Number of 'converged' eigenvalues  : " << nconv << std::endl << std::endl;
 
   // Printing eigenvalues.
 
-  cout << "Eigenvalues:" << endl;
+  std::cout << "Eigenvalues:" << std::endl;
 
   for (i=0; i<nconv; i++) {
-    cout << "  lambda[" << (i+1) << "]: " << EigVal[i] << endl;
+    std::cout << "  lambda[" << (i+1) << "]: " << EigVal[i] << std::endl;
   }
-  cout << endl;
+  std::cout << std::endl;
 
   // Printing eigenvectors.
 
@@ -70,10 +70,10 @@ void Solution(ARINT nconv, ARINT n, ARIN
     }
 
     for (i=0; i<nconv; i++) {
-      cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
-      cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << endl;
+      std::cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
+      std::cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
 
     delete[] Ax;
     delete[] ResNorm;
@@ -89,7 +89,7 @@ void Solution(ARINT nconv, ARINT n, ARIN
               ARINT pcolB[], char uplo, ARFLOAT EigVal[], ARFLOAT* EigVec = 0)
 /*
   Prints eigenvalues and eigenvectors of symmetric generalized
-  eigen-problem on standard "cout" stream.
+  eigen-problem on standard "std::cout" stream.
 */
 
 {
@@ -100,21 +100,21 @@ void Solution(ARINT nconv, ARINT n, ARIN
   ARluSymMatrix<ARFLOAT> matrixA(n, nnzA, A, irowA, pcolA, uplo);
   ARluSymMatrix<ARFLOAT> matrixB(n, nnzB, B, irowB, pcolB, uplo);
 
-  cout << endl << endl << "Testing ARPACK++ function AREig" << endl;
-  cout << "Real symmetric generalized eigenvalue problem: A*x - lambda*B*x";
-  cout << endl << endl;
+  std::cout << std::endl <<std::endl << "Testing ARPACK++ function AREig" <<std::endl;
+  std::cout << "Real symmetric generalized eigenvalue problem: A*x - lambda*B*x";
+  std::cout << std::endl <<std::endl;
 
-  cout << "Dimension of the system            : " << n     << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv << endl << endl;
+  std::cout << "Dimension of the system            : " << n     << std::endl;
+  std::cout << "Number of 'converged' eigenvalues  : " << nconv << std::endl <<std::endl;
 
   // Printing eigenvalues.
 
-  cout << "Eigenvalues:" << endl;
+  std::cout << "Eigenvalues:" << std::endl;
 
   for (i=0; i<nconv; i++) {
-    cout << "  lambda[" << (i+1) << "]: " << EigVal[i] << endl;
+    std::cout << "  lambda[" << (i+1) << "]: " << EigVal[i] << std::endl;
   }
-  cout << endl;
+  std::cout << std::endl;
 
   // Printing eigenvectors.
 
@@ -135,10 +135,10 @@ void Solution(ARINT nconv, ARINT n, ARIN
     }
 
     for (i=0; i<nconv; i++) {
-      cout << "||A*x(" << i << ") - lambda(" << i;
-      cout << ")*B*x(" << i << ")||: " << ResNorm[i] << endl;
+      std::cout << "||A*x(" << i << ") - lambda(" << i;
+      std::cout << ")*B*x(" << i << ")||: " << ResNorm[i] << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
 
     delete[] Ax;
     delete[] Bx;
diff -rupN arpack++1.2.orig/examples/areig/sym/Makefile arpack++1.2.patched/examples/areig/sym/Makefile
--- arpack++1.2.orig/examples/areig/sym/Makefile	2000-02-18 22:11:18.000000000 +0100
+++ arpack++1.2.patched/examples/areig/sym/Makefile	2006-01-26 15:37:46.000000000 +0100
@@ -42,7 +42,7 @@ asymgcay:	asymgcay.o
 
 .PHONY:	clean
 clean:
-	rm -f *~ *.o core
+	rm -f *~ *.o core asymgbkl asymgcay asymgreg asymgshf asymreg asymshf
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/examples/band/complex/Makefile arpack++1.2.patched/examples/band/complex/Makefile
--- arpack++1.2.orig/examples/band/complex/Makefile	2000-02-18 19:40:44.000000000 +0100
+++ arpack++1.2.patched/examples/band/complex/Makefile	2006-01-26 15:37:47.000000000 +0100
@@ -32,7 +32,7 @@ bcompgsh:	bcompgsh.o
 
 .PHONY:	clean
 clean:
-	rm -f *~ *.o core
+	rm -f *~ *.o core bcompreg bcompshf bcompgre bcompgsh
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/examples/band/nonsym/bsvd.cc arpack++1.2.patched/examples/band/nonsym/bsvd.cc
--- arpack++1.2.orig/examples/band/nonsym/bsvd.cc	2000-02-18 19:35:55.000000000 +0100
+++ arpack++1.2.patched/examples/band/nonsym/bsvd.cc	2006-01-26 15:37:47.000000000 +0100
@@ -45,8 +45,8 @@
 #include "arssym.h"
 #include "bnmatrxw.h"
 #include "arbnsmat.h"
-#include "iostream.h"
-#include <math.h>
+#include <iostream>
+#include <cmath>
 
 
 int main()
@@ -90,11 +90,11 @@ int main()
 
   // Printing some information about the problem.
 
-  cout << endl << "Testing ARPACK++ class ARSymStdEig" << endl;
-  cout << "Obtaining singular values by solving (A'*A)*v = sigma*v" << endl;
-  cout << endl << "greatest singular values: " << endl; 
+  std::cout << std::endl << "Testing ARPACK++ class ARSymStdEig" << std::endl;
+  std::cout << "Obtaining singular values by solving (A'*A)*v = sigma*v" << std::endl;
+  std::cout << std::endl << "greatest singular values: " << std::endl; 
   for (i=0; i<4; i++) {
-    cout << "  sigma [" << i+1 << "]: " << svalue[i] << endl;
+    std::cout << "  sigma [" << i+1 << "]: " << svalue[i] << std::endl;
   }
 
 } // main.
diff -rupN arpack++1.2.orig/examples/band/nonsym/Makefile arpack++1.2.patched/examples/band/nonsym/Makefile
--- arpack++1.2.orig/examples/band/nonsym/Makefile	2000-02-18 19:30:35.000000000 +0100
+++ arpack++1.2.patched/examples/band/nonsym/Makefile	2006-01-26 15:37:47.000000000 +0100
@@ -38,7 +38,7 @@ bsvd:	bsvd.o
 
 .PHONY:	clean
 clean:
-	rm -f *~ *.o core
+	rm -f *~ *.o core bnsymreg bnsymshf bnsymgre bnsymgsh bnsymgsc bsvd
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/examples/band/sym/Makefile arpack++1.2.patched/examples/band/sym/Makefile
--- arpack++1.2.orig/examples/band/sym/Makefile	2000-02-18 19:27:56.000000000 +0100
+++ arpack++1.2.patched/examples/band/sym/Makefile	2006-01-26 15:37:47.000000000 +0100
@@ -38,7 +38,7 @@ bsymgcay:	bsymgcay.o
 
 .PHONY:	clean
 clean:
-	rm -f *~ *.o core
+	rm -f *~ *.o core bsymreg bsymshf bsymgreg bsymgshf bsymgbkl bsymgcay
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/examples/dense/complex/Makefile arpack++1.2.patched/examples/dense/complex/Makefile
--- arpack++1.2.orig/examples/dense/complex/Makefile	2000-02-18 21:18:23.000000000 +0100
+++ arpack++1.2.patched/examples/dense/complex/Makefile	2006-01-26 15:37:49.000000000 +0100
@@ -32,7 +32,7 @@ dcompgsh:	dcompgsh.o
 
 .PHONY:	clean
 clean:
-	rm -f *~ *.o core
+	rm -f *~ *.o core dcompreg dcompshf dcompgre dcompgsh
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/examples/dense/nonsym/dsvd2.cc arpack++1.2.patched/examples/dense/nonsym/dsvd2.cc
--- arpack++1.2.orig/examples/dense/nonsym/dsvd2.cc	2000-02-18 21:12:32.000000000 +0100
+++ arpack++1.2.patched/examples/dense/nonsym/dsvd2.cc	2006-01-26 15:37:49.000000000 +0100
@@ -47,7 +47,7 @@
 #include "arssym.h"
 #include "ardnsmat.h"
 #include "iostream.h"
-#include <math.h>
+#include <cmath>
 
 
 int main()
@@ -80,11 +80,11 @@ int main()
 
   // Printing some information about the problem.
 
-  cout << endl << "Testing ARPACK++ class ARSymStdEig" << endl;
-  cout << "Obtaining singular values by solving (A'*A)*v = sigma*v" << endl;
-  cout << endl << "greatest singular values: " << endl; 
+  std::cout << std::endl << "Testing ARPACK++ class ARSymStdEig" << std::endl;
+  std::cout << "Obtaining singular values by solving (A'*A)*v = sigma*v" << std::endl;
+  std::cout << std::endl << "greatest singular values: " << std::endl; 
   for (i=0; i<4; i++) {
-    cout << "  sigma [" << i+1 << "]: " << svalue[i] << endl;
+    std::cout << "  sigma [" << i+1 << "]: " << svalue[i] << std::endl;
   }
 
 } // main.
diff -rupN arpack++1.2.orig/examples/dense/nonsym/dsvd.cc arpack++1.2.patched/examples/dense/nonsym/dsvd.cc
--- arpack++1.2.orig/examples/dense/nonsym/dsvd.cc	2000-02-18 21:11:17.000000000 +0100
+++ arpack++1.2.patched/examples/dense/nonsym/dsvd.cc	2006-01-26 15:37:49.000000000 +0100
@@ -42,8 +42,8 @@
 #include "arssym.h"
 #include "dnmatrxw.h"
 #include "ardnsmat.h"
-#include "iostream.h"
-#include <math.h>
+#include <iostream>
+#include <cmath>
 
 
 int main()
@@ -85,11 +85,11 @@ int main()
 
   // Printing some information about the problem.
 
-  cout << endl << "Testing ARPACK++ class ARSymStdEig" << endl;
-  cout << "Obtaining singular values by solving (A'*A)*v = sigma*v" << endl;
-  cout << endl << "greatest singular values: " << endl; 
+  std::cout << std::endl << "Testing ARPACK++ class ARSymStdEig" << std::endl;
+  std::cout << "Obtaining singular values by solving (A'*A)*v = sigma*v" << std::endl;
+  std::cout << std::endl << "greatest singular values: " << std::endl; 
   for (i=0; i<4; i++) {
-    cout << "  sigma [" << i+1 << "]: " << svalue[i] << endl;
+    std::cout << "  sigma [" << i+1 << "]: " << svalue[i] << std::endl;
   }
 
 } // main.
diff -rupN arpack++1.2.orig/examples/dense/nonsym/Makefile arpack++1.2.patched/examples/dense/nonsym/Makefile
--- arpack++1.2.orig/examples/dense/nonsym/Makefile	2000-02-18 21:11:42.000000000 +0100
+++ arpack++1.2.patched/examples/dense/nonsym/Makefile	2006-01-26 15:37:49.000000000 +0100
@@ -41,7 +41,7 @@ dsvd2:	dsvd2.o
 
 .PHONY:	clean
 clean:
-	rm -f *~ *.o core
+	rm -f *~ *.o core dnsymreg dnsymshf dnsymgre dnsymgsh dnsymgsc dsvd
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/examples/dense/sym/Makefile arpack++1.2.patched/examples/dense/sym/Makefile
--- arpack++1.2.orig/examples/dense/sym/Makefile	2000-02-18 20:33:51.000000000 +0100
+++ arpack++1.2.patched/examples/dense/sym/Makefile	2006-01-26 15:37:49.000000000 +0100
@@ -38,7 +38,7 @@ dsymgcay:	dsymgcay.o
 
 .PHONY:	clean
 clean:
-	rm -f *~ *.o core
+	rm -f *~ *.o core dsymreg dsymshf dsymgreg dsymgshf dsymgbkl dsymgcay
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/examples/harwell/complex/hcompgen.cc arpack++1.2.patched/examples/harwell/complex/hcompgen.cc
--- arpack++1.2.orig/examples/harwell/complex/hcompgen.cc	2000-02-22 17:28:48.000000000 +0100
+++ arpack++1.2.patched/examples/harwell/complex/hcompgen.cc	2006-01-26 15:37:48.000000000 +0100
@@ -32,7 +32,7 @@
       Houston, Texas
 */
 
-#include <iostream.h>
+#include <iostream>
 #include "arerror.h"
 #include "arlnsmat.h"
 #include "arlgcomp.h"
@@ -45,21 +45,21 @@ void PrintHelp()
 */
 {
 
-  cout << "ARPACK++ version 1.2 feb 2000" << endl;
-  cout << "hcompgen: a generalized complex eigenvalue problems solver" << endl;
-  cout << "usage:    hcompgen [parameters] file1 file2" << endl;
-  cout << "parameters:" << endl;
-  cout << "      -n <number of desired eigenvalues>" << endl;
-  cout << "      -c <number of Arnoldi vectors per iteration>" << endl;
-  cout << "      -l <maximum number of iterations>" << endl;
-  cout << "      -s <real part of the shift>" << endl;
-  cout << "      -i <imaginary part of the shift>" << endl;
-  cout << "      -t <stopping criterion>" << endl;
-  cout << "      -u <LU pivot threshold>" << endl;
-  cout << "      -o <column ordering for factorization>" << endl;
-  cout << "      -w <desired portion of the spectrum. " << endl;
-  cout << "          acceptable values: LM, SM, LR, SR, LI, SI>" << endl;
-  cout << endl;
+  std::cout << "ARPACK++ version 1.2 feb 2000" << std::endl;
+  std::cout << "hcompgen: a generalized complex eigenvalue problems solver" << std::endl;
+  std::cout << "usage:    hcompgen [parameters] file1 file2" << std::endl;
+  std::cout << "parameters:" << std::endl;
+  std::cout << "      -n <number of desired eigenvalues>" << std::endl;
+  std::cout << "      -c <number of Arnoldi vectors per iteration>" << std::endl;
+  std::cout << "      -l <maximum number of iterations>" << std::endl;
+  std::cout << "      -s <real part of the shift>" << std::endl;
+  std::cout << "      -i <imaginary part of the shift>" << std::endl;
+  std::cout << "      -t <stopping criterion>" << std::endl;
+  std::cout << "      -u <LU pivot threshold>" << std::endl;
+  std::cout << "      -o <column ordering for factorization>" << std::endl;
+  std::cout << "      -w <desired portion of the spectrum. " << std::endl;
+  std::cout << "          acceptable values: LM, SM, LR, SR, LI, SI>" << std::endl;
+  std::cout << std::endl;
 
 } // PrintHelp.
 
@@ -140,7 +140,7 @@ bool ReadParameters(int n, char* v[], in
           thresh = atof(v[i++]);
           break;
         default :
-          cout << "unrecognized parameter: -" << v[i-1][1] << endl;
+          std::cout << "unrecognized parameter: -" << v[i-1][1] << std::endl;
           ok = false; 
         }
       }
diff -rupN arpack++1.2.orig/examples/harwell/complex/hcompstd.cc arpack++1.2.patched/examples/harwell/complex/hcompstd.cc
--- arpack++1.2.orig/examples/harwell/complex/hcompstd.cc	2000-02-22 17:28:18.000000000 +0100
+++ arpack++1.2.patched/examples/harwell/complex/hcompstd.cc	2006-01-26 15:37:48.000000000 +0100
@@ -32,7 +32,7 @@
       Houston, Texas
 */
 
-#include <iostream.h>
+#include <iostream>
 #include "arerror.h"
 #include "arlnsmat.h"
 #include "arlscomp.h"
@@ -45,21 +45,21 @@ void PrintHelp()
 */
 {
 
-  cout << "ARPACK++ version 1.2 feb 2000" << endl;
-  cout << "hcompstd: a standard complex eigenvalue problems solver" << endl;
-  cout << "usage:    hcompstd [parameters] file" << endl;
-  cout << "parameters:" << endl;
-  cout << "      -n (number of desired eigenvalues)" << endl;
-  cout << "      -c (number of Arnoldi vectors per iteration)" << endl;
-  cout << "      -l (maximum number of iterations)" << endl;
-  cout << "      -s (real part of the shift)" << endl;
-  cout << "      -i (imaginary part of the shift)" << endl;
-  cout << "      -t (stopping criterion)" << endl;
-  cout << "      -u (LU pivot threshold)" << endl;
-  cout << "      -o (column ordering for factorization)" << endl;
-  cout << "      -w (desired portion of the spectrum. " << endl;
-  cout << "          acceptable values: LM, SM, LR, SR, LI, SI)" << endl;
-  cout << endl;
+  std::cout << "ARPACK++ version 1.2 feb 2000" << std::endl;
+  std::cout << "hcompstd: a standard complex eigenvalue problems solver" << std::endl;
+  std::cout << "usage:    hcompstd [parameters] file" << std::endl;
+  std::cout << "parameters:" << std::endl;
+  std::cout << "      -n (number of desired eigenvalues)" << std::endl;
+  std::cout << "      -c (number of Arnoldi vectors per iteration)" << std::endl;
+  std::cout << "      -l (maximum number of iterations)" << std::endl;
+  std::cout << "      -s (real part of the shift)" << std::endl;
+  std::cout << "      -i (imaginary part of the shift)" << std::endl;
+  std::cout << "      -t (stopping criterion)" << std::endl;
+  std::cout << "      -u (LU pivot threshold)" << std::endl;
+  std::cout << "      -o (column ordering for factorization)" << std::endl;
+  std::cout << "      -w (desired portion of the spectrum. " << std::endl;
+  std::cout << "          acceptable values: LM, SM, LR, SR, LI, SI)" << std::endl;
+  std::cout << std::endl;
 
 } // PrintHelp.
 
@@ -139,7 +139,7 @@ bool ReadParameters(int n, char* v[], in
           thresh = atof(v[i++]);
           break;
         default :
-          cout << "unrecognized parameter: -" << v[i-1][1] << endl;
+          std::cout << "unrecognized parameter: -" << v[i-1][1] << std::endl;
           ok = false; 
         }
       }
diff -rupN arpack++1.2.orig/examples/harwell/complex/Makefile arpack++1.2.patched/examples/harwell/complex/Makefile
--- arpack++1.2.orig/examples/harwell/complex/Makefile	2000-02-22 17:36:39.000000000 +0100
+++ arpack++1.2.patched/examples/harwell/complex/Makefile	2006-01-26 15:37:48.000000000 +0100
@@ -26,7 +26,7 @@ hcompgen:	hcompgen.o
 
 .PHONY:	clean
 clean:
-	rm -f *~ *.o core
+	rm -f *~ *.o core hcompstd hcompgen
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/examples/harwell/nonsym/hnsymgen.cc arpack++1.2.patched/examples/harwell/nonsym/hnsymgen.cc
--- arpack++1.2.orig/examples/harwell/nonsym/hnsymgen.cc	2000-02-22 17:46:51.000000000 +0100
+++ arpack++1.2.patched/examples/harwell/nonsym/hnsymgen.cc	2006-01-26 15:37:49.000000000 +0100
@@ -33,7 +33,7 @@
       Houston, Texas
 */
 
-#include <iostream.h>
+#include <iostream>
 #include "arerror.h"
 #include "arlnsmat.h"
 #include "arlgnsym.h"
@@ -46,22 +46,22 @@ void PrintHelp()
 */
 {
 
-  cout << "ARPACK++ version 1.2 fev 2000" << endl;
-  cout << "hnsymgen: a generalized nonsymmetric eigenproblems solver" << endl;
-  cout << "usage:    hnsymgen [parameters] file1 file2" << endl;
-  cout << "parameters:" << endl;
-  cout << "      -n <number of desired eigenvalues>" << endl;
-  cout << "      -c <number of Arnoldi vectors per iteration>" << endl;
-  cout << "      -l <maximum number of iterations>" << endl;
-  cout << "      -s <real part of the shift>" << endl;
-  cout << "      -i <imaginary part of the shift>" << endl;
-  cout << "      -p <part of inv(A-sB)*v considered (R or I))>" << endl;
-  cout << "      -t <stopping criterion>" << endl;
-  cout << "      -u <LU pivot threshold>" << endl;
-  cout << "      -o <column ordering for factorization>" << endl;
-  cout << "      -w <desired portion of the spectrum. " << endl;
-  cout << "          acceptable values: LM, SM, LR, SR, LI, SI>" << endl;
-  cout << endl;
+  std::cout << "ARPACK++ version 1.2 fev 2000" << std::endl;
+  std::cout << "hnsymgen: a generalized nonsymmetric eigenproblems solver" << std::endl;
+  std::cout << "usage:    hnsymgen [parameters] file1 file2" << std::endl;
+  std::cout << "parameters:" << std::endl;
+  std::cout << "      -n <number of desired eigenvalues>" << std::endl;
+  std::cout << "      -c <number of Arnoldi vectors per iteration>" << std::endl;
+  std::cout << "      -l <maximum number of iterations>" << std::endl;
+  std::cout << "      -s <real part of the shift>" << std::endl;
+  std::cout << "      -i <imaginary part of the shift>" << std::endl;
+  std::cout << "      -p <part of inv(A-sB)*v considered (R or I))>" << std::endl;
+  std::cout << "      -t <stopping criterion>" << std::endl;
+  std::cout << "      -u <LU pivot threshold>" << std::endl;
+  std::cout << "      -o <column ordering for factorization>" << std::endl;
+  std::cout << "      -w <desired portion of the spectrum. " << std::endl;
+  std::cout << "          acceptable values: LM, SM, LR, SR, LI, SI>" << std::endl;
+  std::cout << std::endl;
 
 } // PrintHelp.
 
@@ -146,7 +146,7 @@ bool ReadParameters(int n, char* v[], in
           thresh = atof(v[i++]);
           break;
         default :
-          cout << "unrecognized parameter: -" << v[i-1][1] << endl;
+          std::cout << "unrecognized parameter: -" << v[i-1][1] << std::endl;
           ok = false; 
         }
       }
diff -rupN arpack++1.2.orig/examples/harwell/nonsym/hnsymstd.cc arpack++1.2.patched/examples/harwell/nonsym/hnsymstd.cc
--- arpack++1.2.orig/examples/harwell/nonsym/hnsymstd.cc	2000-02-22 17:47:02.000000000 +0100
+++ arpack++1.2.patched/examples/harwell/nonsym/hnsymstd.cc	2006-01-26 15:37:49.000000000 +0100
@@ -33,7 +33,7 @@
       Houston, Texas
 */
 
-#include <iostream.h>
+#include <iostream>
 #include "arerror.h"
 #include "arlnsmat.h"
 #include "arlsnsym.h"
@@ -46,20 +46,20 @@ void PrintHelp()
 */
 {
 
-  cout << "ARPACK++ version 1.2 feb 2000" << endl;
-  cout << "hnsymstd: a standard nonsymmetric eigenproblems solver" << endl;
-  cout << "usage:    hnsymstd [parameters] file" << endl;
-  cout << "parameters:" << endl;
-  cout << "      -n (number of desired eigenvalues)" << endl;
-  cout << "      -c (number of Arnoldi vectors per iteration)" << endl;
-  cout << "      -l (maximum number of iterations)" << endl;
-  cout << "      -s (shift)" << endl;
-  cout << "      -t (stopping criterion)" << endl;
-  cout << "      -u (LU pivot threshold)" << endl;
-  cout << "      -o (column ordering for factorization)" << endl;
-  cout << "      -w (desired portion of the spectrum. " << endl;
-  cout << "          acceptable values: LM, SM, LR, SR, LI, SI)" << endl;
-  cout << endl;
+  std::cout << "ARPACK++ version 1.2 feb 2000" << std::endl;
+  std::cout << "hnsymstd: a standard nonsymmetric eigenproblems solver" << std::endl;
+  std::cout << "usage:    hnsymstd [parameters] file" << std::endl;
+  std::cout << "parameters:" << std::endl;
+  std::cout << "      -n (number of desired eigenvalues)" << std::endl;
+  std::cout << "      -c (number of Arnoldi vectors per iteration)" << std::endl;
+  std::cout << "      -l (maximum number of iterations)" << std::endl;
+  std::cout << "      -s (shift)" << std::endl;
+  std::cout << "      -t (stopping criterion)" << std::endl;
+  std::cout << "      -u (LU pivot threshold)" << std::endl;
+  std::cout << "      -o (column ordering for factorization)" << std::endl;
+  std::cout << "      -w (desired portion of the spectrum. " << std::endl;
+  std::cout << "          acceptable values: LM, SM, LR, SR, LI, SI)" << std::endl;
+  std::cout << std::endl;
 
 } // PrintHelp.
 
@@ -133,7 +133,7 @@ bool ReadParameters(int n, char* v[], in
           thresh = atof(v[i++]);
           break;
         default :
-          cout << "unrecognized parameter: -" << v[i-1][1] << endl;
+          std::cout << "unrecognized parameter: -" << v[i-1][1] << std::endl;
           ok = false; 
         }
       }
diff -rupN arpack++1.2.orig/examples/harwell/nonsym/Makefile arpack++1.2.patched/examples/harwell/nonsym/Makefile
--- arpack++1.2.orig/examples/harwell/nonsym/Makefile	2000-02-22 17:36:26.000000000 +0100
+++ arpack++1.2.patched/examples/harwell/nonsym/Makefile	2006-01-26 15:37:49.000000000 +0100
@@ -26,7 +26,7 @@ hnsymgen:	hnsymgen.o
 
 .PHONY:	clean
 clean:
-	rm -f *~ *.o core
+	rm -f *~ *.o core hnsymstd hnsymgen
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/examples/harwell/sym/hsymgen.cc arpack++1.2.patched/examples/harwell/sym/hsymgen.cc
--- arpack++1.2.orig/examples/harwell/sym/hsymgen.cc	2000-02-22 17:50:18.000000000 +0100
+++ arpack++1.2.patched/examples/harwell/sym/hsymgen.cc	2006-01-26 15:37:48.000000000 +0100
@@ -33,7 +33,7 @@
       Houston, Texas
 */
 
-#include <iostream.h>
+#include <iostream>
 #include "arerror.h"
 #include "arlsmat.h"
 #include "arlgsym.h"
@@ -46,22 +46,22 @@ void PrintHelp()
 */
 {
 
-  cout << "ARPACK++ version 1.2 feb 2000" << endl;
-  cout << "hsymgen: a generalized symmetric eigenproblems solver" << endl;
-  cout << "usage:   hsymgen [parameters] file1 file2" << endl;
-  cout << "parameters:" << endl;
-  cout << "      -n <number of desired eigenvalues>" << endl;
-  cout << "      -c <number of Arnoldi vectors per iteration>" << endl;
-  cout << "      -l <maximum number of iterations>" << endl;
-  cout << "      -s <shift>" << endl;
-  cout << "      -i <invert mode: 'S'hift-invert, 'B'uckling or 'C'ayley)>";
-  cout << endl;
-  cout << "      -t <stopping criterion>" << endl;
-  cout << "      -u <LU pivot threshold>" << endl;
-  cout << "      -o <column ordering for factorization>" << endl;
-  cout << "      -w <desired portion of the spectrum. " << endl;
-  cout << "          acceptable values: LM, SM, LA, SA, BE>" << endl;
-  cout << endl;
+  std::cout << "ARPACK++ version 1.2 feb 2000" << std::endl;
+  std::cout << "hsymgen: a generalized symmetric eigenproblems solver" << std::endl;
+  std::cout << "usage:   hsymgen [parameters] file1 file2" << std::endl;
+  std::cout << "parameters:" << std::endl;
+  std::cout << "      -n <number of desired eigenvalues>" << std::endl;
+  std::cout << "      -c <number of Arnoldi vectors per iteration>" << std::endl;
+  std::cout << "      -l <maximum number of iterations>" << std::endl;
+  std::cout << "      -s <shift>" << std::endl;
+  std::cout << "      -i <invert mode: 'S'hift-invert, 'B'uckling or 'C'ayley)>";
+  std::cout << std::endl;
+  std::cout << "      -t <stopping criterion>" << std::endl;
+  std::cout << "      -u <LU pivot threshold>" << std::endl;
+  std::cout << "      -o <column ordering for factorization>" << std::endl;
+  std::cout << "      -w <desired portion of the spectrum. " << std::endl;
+  std::cout << "          acceptable values: LM, SM, LA, SA, BE>" << std::endl;
+  std::cout << std::endl;
 
 } // PrintHelp.
 
@@ -122,7 +122,7 @@ bool ReadParameters(int n, char* v[], in
         case 'i':
           mode = v[i++][0];
           if ((mode!='S')&&(mode!='B')&&(mode!='C')) {
-            cout << "invalid invert mode: " << mode << endl;
+            std::cout << "invalid invert mode: " << mode << std::endl;
             ok = false;
           }
           break;
@@ -145,7 +145,7 @@ bool ReadParameters(int n, char* v[], in
           thresh = atof(v[i++]);
           break;
         default :
-          cout << "unrecognized parameter: -" << v[i-1][1] << endl;
+          std::cout << "unrecognized parameter: -" << v[i-1][1] << std::endl;
           ok = false;
         }
       }
diff -rupN arpack++1.2.orig/examples/harwell/sym/hsymstd.cc arpack++1.2.patched/examples/harwell/sym/hsymstd.cc
--- arpack++1.2.orig/examples/harwell/sym/hsymstd.cc	2000-02-22 17:43:30.000000000 +0100
+++ arpack++1.2.patched/examples/harwell/sym/hsymstd.cc	2006-01-26 15:37:48.000000000 +0100
@@ -33,7 +33,7 @@
       Houston, Texas
 */
 
-#include <iostream.h>
+#include <iostream>
 #include "arerror.h"
 #include "arlsmat.h"
 #include "arlssym.h"
@@ -46,20 +46,20 @@ void PrintHelp()
 */
 {
 
-  cout << "ARPACK++ version 1.2 feb 2000" << endl;
-  cout << "hsymstd: a standard symmetric eigenvalue problems solver" << endl;
-  cout << "usage:   hsymstd [parameters] file" << endl;
-  cout << "parameters:" << endl;
-  cout << "      -n (number of desired eigenvalues)" << endl;
-  cout << "      -c (number of Arnoldi vectors per iteration)" << endl;
-  cout << "      -l (maximum number of iterations)" << endl;
-  cout << "      -s (shift)" << endl;
-  cout << "      -t (stopping criterion)" << endl;
-  cout << "      -u (LU pivot threshold)" << endl;
-  cout << "      -o (column ordering for factorization)" << endl;
-  cout << "      -w (desired portion of the spectrum. " << endl;
-  cout << "          acceptable values: LM, SM, LA, SA, BE)" << endl;
-  cout << endl;
+  std::cout << "ARPACK++ version 1.2 feb 2000" << std::endl;
+  std::cout << "hsymstd: a standard symmetric eigenvalue problems solver" << std::endl;
+  std::cout << "usage:   hsymstd [parameters] file" << std::endl;
+  std::cout << "parameters:" << std::endl;
+  std::cout << "      -n (number of desired eigenvalues)" << std::endl;
+  std::cout << "      -c (number of Arnoldi vectors per iteration)" << std::endl;
+  std::cout << "      -l (maximum number of iterations)" << std::endl;
+  std::cout << "      -s (shift)" << std::endl;
+  std::cout << "      -t (stopping criterion)" << std::endl;
+  std::cout << "      -u (LU pivot threshold)" << std::endl;
+  std::cout << "      -o (column ordering for factorization)" << std::endl;
+  std::cout << "      -w (desired portion of the spectrum. " << std::endl;
+  std::cout << "          acceptable values: LM, SM, LA, SA, BE)" << std::endl;
+  std::cout << std::endl;
 
 } // PrintHelp.
 
@@ -133,7 +133,7 @@ bool ReadParameters(int n, char* v[], in
           thresh = atof(v[i++]);
           break;
         default :
-          cout << "unrecognized parameter: -" << v[i-1][1] << endl;
+          std::cout << "unrecognized parameter: -" << v[i-1][1] << std::endl;
           ok = false; 
         }
       }
diff -rupN arpack++1.2.orig/examples/harwell/sym/Makefile arpack++1.2.patched/examples/harwell/sym/Makefile
--- arpack++1.2.orig/examples/harwell/sym/Makefile	2000-02-22 17:51:04.000000000 +0100
+++ arpack++1.2.patched/examples/harwell/sym/Makefile	2006-01-26 15:37:48.000000000 +0100
@@ -26,7 +26,7 @@ hsymgen:	hsymgen.o
 
 .PHONY:	clean
 clean:
-	rm -f *~ *.o core
+	rm -f *~ *.o core hsymstd hsymgen
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/examples/matprod/complex/cmatrixb.h arpack++1.2.patched/examples/matprod/complex/cmatrixb.h
--- arpack++1.2.orig/examples/matprod/complex/cmatrixb.h	1997-08-01 17:07:42.000000000 +0200
+++ arpack++1.2.patched/examples/matprod/complex/cmatrixb.h	2006-01-26 15:37:48.000000000 +0100
@@ -86,31 +86,31 @@ void CompMatrixB<T>::FactorOP()
   const arcomplex<T> one(1.0, 0.0);
   const arcomplex<T> two(2.0, 0.0);
 
-  if (decsize != ncols()) {
-    decsize = ncols();
+  if (decsize != this->ncols()) {
+    decsize = this->ncols();
     FactorDataDeallocate();
-    Ad   = new arcomplex<T>[ncols()];
-    Adl  = new arcomplex<T>[ncols()];
-    Adu  = new arcomplex<T>[ncols()];
-    Adu2 = new arcomplex<T>[ncols()];
-    ipiv = new int[ncols()];
+    Ad   = new arcomplex<T>[this->ncols()];
+    Adl  = new arcomplex<T>[this->ncols()];
+    Adu  = new arcomplex<T>[this->ncols()];
+    Adu2 = new arcomplex<T>[this->ncols()];
+    ipiv = new int[this->ncols()];
   }
 
-  h  = one/arcomplex<T>((ncols()+1),0.0);
+  h  = one/arcomplex<T>((this->ncols()+1),0.0);
   h2 = h*h;
   s  = rho/two;
   s1 = -one/h2 - s/h;
   s2 = two/h2 - shift;
   s3 = -one/h2 + s/h;
 
-  for (j=0; j<ncols()-1; j++) {
+  for (j=0; j<this->ncols()-1; j++) {
     Adl[j] = s1;
     Ad[j]  = s2;
     Adu[j] = s3;
   }
-  Ad[ncols()-1]  = s2;
+  Ad[this->ncols()-1]  = s2;
 
-  gttrf(ncols(), Adl, Ad, Adu, Adu2, ipiv, ierr);
+  gttrf(this->ncols(), Adl, Ad, Adu, Adu2, ipiv, ierr);
 
 } // FactorOP.
 
@@ -129,7 +129,7 @@ void CompMatrixB<T>::MultMv(arcomplex<T>
   const arcomplex<T> one( 1.0, 0.0);
   const arcomplex<T> two( 2.0, 0.0);
 
-  h  = one/arcomplex<T>((ncols()+1),0.0);
+  h  = one/arcomplex<T>((this->ncols()+1),0.0);
   h2 = h*h;
   s  = rho/two;
   dd = two/h2;
@@ -137,10 +137,10 @@ void CompMatrixB<T>::MultMv(arcomplex<T>
   du = -one/h2 + s/h;
 
   w[0] = dd*v[0] + du*v[1];
-  for (j=1; j<ncols()-1; j++) {
+  for (j=1; j<this->ncols()-1; j++) {
     w[j] = dl*v[j-1] + dd*v[j] + du*v[j+1];
   }
-  w[ncols()-1] = dl*v[ncols()-2] + dd*v[ncols()-1];
+  w[this->ncols()-1] = dl*v[this->ncols()-2] + dd*v[this->ncols()-1];
 
 } //  MultMv.
 
@@ -156,8 +156,8 @@ void CompMatrixB<T>::MultOPv(arcomplex<T
   int  ierr;
   char *type = "N";
 
-  copy(ncols(), v, 1, w, 1);
-  gttrs(type, ncols(), 1, Adl, Ad, Adu, Adu2, ipiv, w, ncols(), ierr);
+  copy(this->ncols(), v, 1, w, 1);
+  gttrs(type, this->ncols(), 1, Adl, Ad, Adu, Adu2, ipiv, w, this->ncols(), ierr);
 
 } // MultOPv.
 
@@ -220,4 +220,3 @@ inline CompMatrixB<T>::~CompMatrixB()
 
 
 #endif // CMATRIXB_H
-
diff -rupN arpack++1.2.orig/examples/matprod/complex/cmatrixc.h arpack++1.2.patched/examples/matprod/complex/cmatrixc.h
--- arpack++1.2.orig/examples/matprod/complex/cmatrixc.h	1997-08-01 17:06:49.000000000 +0200
+++ arpack++1.2.patched/examples/matprod/complex/cmatrixc.h	2006-01-26 15:37:48.000000000 +0100
@@ -46,23 +46,19 @@ void ComplexMatrixC<T>::MultMv(arcomplex
   const arcomplex<T> two( 2.0, 0.0);
   const arcomplex<T> rho(10.0, 0.0);
 
-  h  = one/arcomplex<T>((ncols()+1),0.0);
+  h  = one/arcomplex<T>((this->ncols()+1),0.0);
   s  = rho/two;
   dd = two/h;
   dl = -one/h - s;
   du = -one/h + s;
 
   w[0] = dd*v[0] + du*v[1];
-  for (j=1; j<ncols()-1; j++) {
+  for (j=1; j<this->ncols()-1; j++) {
     w[j] = dl*v[j-1] + dd*v[j] + du*v[j+1];
   }
-  w[ncols()-1] = dl*v[ncols()-2] + dd*v[ncols()-1];
+  w[this->ncols()-1] = dl*v[this->ncols()-2] + dd*v[this->ncols()-1];
 
 } //  MultMv.
 
 
 #endif // CMATRIXC_H
-
-
-
-
diff -rupN arpack++1.2.orig/examples/matprod/complex/cmatrixd.h arpack++1.2.patched/examples/matprod/complex/cmatrixd.h
--- arpack++1.2.orig/examples/matprod/complex/cmatrixd.h	1997-08-01 17:06:07.000000000 +0200
+++ arpack++1.2.patched/examples/matprod/complex/cmatrixd.h	2006-01-26 15:37:48.000000000 +0100
@@ -81,8 +81,8 @@ void ComplexMatrixD<T>::FactorM()
   const arcomplex<T> one(1.0, 0.0);
   const arcomplex<T> four(4.0, 0.0);
 
-  if (decsize != ncols()) {
-    decsize = ncols();
+  if (decsize != this->ncols()) {
+    decsize = this->ncols();
     FactorDataDeallocate();
     Ad   = new arcomplex<T>[decsize];
     Adl  = new arcomplex<T>[decsize];
@@ -91,16 +91,16 @@ void ComplexMatrixD<T>::FactorM()
     ipiv = new int[decsize];
   }
 
-  h  = one/arcomplex<T>((ncols()+1),0.0);
+  h  = one/arcomplex<T>((this->ncols()+1),0.0);
 
-  for (j=0; j<ncols()-1; j++) {
+  for (j=0; j<this->ncols()-1; j++) {
     Adl[j] = one*h;
     Ad[j]  = four*h;
     Adu[j] = one*h;
   }
-  Ad[ncols()-1]  = four*h;
+  Ad[this->ncols()-1]  = four*h;
 
-  gttrf(ncols(), Adl, Ad, Adu, Adu2, ipiv, ierr);
+  gttrf(this->ncols(), Adl, Ad, Adu, Adu2, ipiv, ierr);
 
 } // FactorM.
 
@@ -116,13 +116,13 @@ void ComplexMatrixD<T>::MultMv(arcomplex
   const arcomplex<T> four(4.0, 0.0);
 
   w[0] = four*v[0] + one*v[1];
-  for (j=1; j<ncols()-1; j++) {
+  for (j=1; j<this->ncols()-1; j++) {
     w[j] = one*v[j-1] + four*v[j] + one*v[j+1];
   }
-  w[ncols()-1] = one*v[ncols()-2] + four*v[ncols()-1];
+  w[this->ncols()-1] = one*v[this->ncols()-2] + four*v[this->ncols()-1];
 
-  h = one/arcomplex<T>((ncols()+1),0.0);
-  scal(ncols(), h, w, 1);
+  h = one/arcomplex<T>((this->ncols()+1),0.0);
+  scal(this->ncols(), h, w, 1);
 
 } // MultMv.
 
@@ -134,7 +134,7 @@ inline void ComplexMatrixD<T>::SolveM(ar
   int  ierr;
   char *type = "N";
 
-  gttrs(type, ncols(), 1, Adl, Ad, Adu, Adu2, ipiv, v, ncols(), ierr);
+  gttrs(type, this->ncols(), 1, Adl, Ad, Adu, Adu2, ipiv, v, this->ncols(), ierr);
 
 } // SolveM.
 
@@ -164,4 +164,3 @@ inline ComplexMatrixD<T>::~ComplexMatrix
 
 
 #endif // CMATRIXD_H
-
diff -rupN arpack++1.2.orig/examples/matprod/complex/cmatrixe.h arpack++1.2.patched/examples/matprod/complex/cmatrixe.h
--- arpack++1.2.orig/examples/matprod/complex/cmatrixe.h	1997-08-01 17:05:21.000000000 +0200
+++ arpack++1.2.patched/examples/matprod/complex/cmatrixe.h	2006-01-26 15:37:48.000000000 +0100
@@ -49,17 +49,17 @@ void ComplexMatrixE<T>::MultMv(arcomplex
   const arcomplex<T> one( 1.0, 0.0);
   const arcomplex<T> two( 2.0, 0.0);
 
-  h  = one/arcomplex<T>((ncols()+1),0.0);
+  h  = one/arcomplex<T>((this->ncols()+1),0.0);
   s  = rho/two;
   dd = two/h;
   dl = -one/h - s;
   du = -one/h + s;
 
   w[0] = dd*v[0] + du*v[1];
-  for (j=1; j<ncols()-1; j++) {
+  for (j=1; j<this->ncols()-1; j++) {
     w[j] = dl*v[j-1] + dd*v[j] + du*v[j+1];
   }
-  w[ncols()-1] = dl*v[ncols()-2] + dd*v[ncols()-1];
+  w[this->ncols()-1] = dl*v[this->ncols()-2] + dd*v[this->ncols()-1];
 
 } //  MultMv.
 
@@ -74,5 +74,3 @@ ComplexMatrixE(int nx, arcomplex<T> rhop
 } // Constructor
 
 #endif // CMATRIXE_H
-
-
diff -rupN arpack++1.2.orig/examples/matprod/complex/cmatrixf.h arpack++1.2.patched/examples/matprod/complex/cmatrixf.h
--- arpack++1.2.orig/examples/matprod/complex/cmatrixf.h	1997-08-01 17:04:52.000000000 +0200
+++ arpack++1.2.patched/examples/matprod/complex/cmatrixf.h	2006-01-26 15:37:48.000000000 +0100
@@ -48,16 +48,15 @@ void ComplexMatrixF<T>::MultMv(arcomplex
   const arcomplex<T> four(4.0, 0.0);
 
   w[0] = four*v[0] + one*v[1];
-  for (j=1; j<ncols()-1; j++) {
+  for (j=1; j<this->ncols()-1; j++) {
     w[j] = one*v[j-1] + four*v[j] + one*v[j+1];
   }
-  w[ncols()-1] = one*v[ncols()-2] + four*v[ncols()-1];
+  w[this->ncols()-1] = one*v[this->ncols()-2] + four*v[this->ncols()-1];
 
-  h = one/arcomplex<T>((ncols()+1),0.0);
-  scal(ncols(), h, w, 1);
+  h = one/arcomplex<T>((this->ncols()+1),0.0);
+  scal(this->ncols(), h, w, 1);
 
 } // MultMv.
 
 
 #endif // CMATRIXF_H
-
diff -rupN arpack++1.2.orig/examples/matprod/nonsym/nmatrixb.h arpack++1.2.patched/examples/matprod/nonsym/nmatrixb.h
--- arpack++1.2.orig/examples/matprod/nonsym/nmatrixb.h	1997-08-01 17:00:19.000000000 +0200
+++ arpack++1.2.patched/examples/matprod/nonsym/nmatrixb.h	2006-01-26 15:37:47.000000000 +0100
@@ -83,30 +83,30 @@ void NonSymMatrixB<T>::FactorOP()
   const T one = 1.0;
   const T two = 2.0;
 
-  if (decsize != ncols()) {
-    decsize = ncols();
+  if (decsize != this->ncols()) {
+    decsize = this->ncols();
     FactorDataDeallocate();
-    Ad   = new T[ncols()];
-    Adl  = new T[ncols()];
-    Adu  = new T[ncols()];
-    Adu2 = new T[ncols()];
-    ipiv = new int[ncols()];
+    Ad   = new T[this->ncols()];
+    Adl  = new T[this->ncols()];
+    Adu  = new T[this->ncols()];
+    Adu2 = new T[this->ncols()];
+    ipiv = new int[this->ncols()];
   }
 
-  h  = one/T(ncols()+1);
+  h  = one/T(this->ncols()+1);
   s  = rho*h/two;
   s1 = -one - s;
   s2 = two - shift;
   s3 = -one + s;
 
-  for (j=0; j<ncols()-1; j++) {
+  for (j=0; j<this->ncols()-1; j++) {
     Adl[j] = s1;
     Ad[j]  = s2;
     Adu[j] = s3;
   }
-  Ad[ncols()-1]  = s2;
+  Ad[this->ncols()-1]  = s2;
 
-  gttrf(ncols(), Adl, Ad, Adu, Adu2, ipiv, ierr);
+  gttrf(this->ncols(), Adl, Ad, Adu, Adu2, ipiv, ierr);
 
 } // FactorOP.
 
@@ -125,17 +125,17 @@ void NonSymMatrixB<T>::MultMv(T* v, T* w
   const T one = 1.0;
   const T two = 2.0;
 
-  h  = one/T(ncols()+1);
+  h  = one/T(this->ncols()+1);
   s  = rho*h/two;
   dd = two;
   dl = -one - s;
   du = -one + s;
 
   w[0] = dd*v[0] + du*v[1];
-  for (j=1; j<ncols()-1; j++) {
+  for (j=1; j<this->ncols()-1; j++) {
     w[j] = dl*v[j-1] + dd*v[j] + du*v[j+1];
   }
-  w[ncols()-1] = dl*v[ncols()-2] + dd*v[ncols()-1];
+  w[this->ncols()-1] = dl*v[this->ncols()-2] + dd*v[this->ncols()-1];
 
   return;
 
@@ -153,8 +153,8 @@ void NonSymMatrixB<T>::MultOPv(T* v, T* 
   int  ierr;
   char *type = "N";
 
-  copy(ncols(), v, 1, w, 1);
-  gttrs(type, ncols(), 1, Adl, Ad, Adu, Adu2, ipiv, w, ncols(), ierr);
+  copy(this->ncols(), v, 1, w, 1);
+  gttrs(type, this->ncols(), 1, Adl, Ad, Adu, Adu2, ipiv, w, this->ncols(), ierr);
 
 } // MultOPv
 
@@ -215,4 +215,3 @@ inline NonSymMatrixB<T>::~NonSymMatrixB(
 
 
 #endif // NMATRIXB_H
-
diff -rupN arpack++1.2.orig/examples/matprod/nonsym/nmatrixc.h arpack++1.2.patched/examples/matprod/nonsym/nmatrixc.h
--- arpack++1.2.orig/examples/matprod/nonsym/nmatrixc.h	1997-08-01 16:59:34.000000000 +0200
+++ arpack++1.2.patched/examples/matprod/nonsym/nmatrixc.h	2006-01-26 15:37:48.000000000 +0100
@@ -49,21 +49,19 @@ void NonSymMatrixC<T>::MultMv(T* v, T* w
   const T two = 2.0;
   const T rho = 10.0;
 
-  h  = one/T(ncols()+1);
+  h  = one/T(this->ncols()+1);
   s  = rho/two;
   dd = two/h;
   dl = -one/h - s;
   du = -one/h + s;
 
   w[0] = dd*v[0] + du*v[1];
-  for (j=1; j<ncols()-1; j++) {
+  for (j=1; j<this->ncols()-1; j++) {
     w[j] = dl*v[j-1] + dd*v[j] + du*v[j+1];
   }
-  w[ncols()-1] = dl*v[ncols()-2] + dd*v[ncols()-1];
+  w[this->ncols()-1] = dl*v[this->ncols()-2] + dd*v[this->ncols()-1];
 
 } //  MultMv.
 
 
 #endif // NMATRIXC_H
-
-
diff -rupN arpack++1.2.orig/examples/matprod/nonsym/nmatrixd.h arpack++1.2.patched/examples/matprod/nonsym/nmatrixd.h
--- arpack++1.2.orig/examples/matprod/nonsym/nmatrixd.h	1997-08-01 16:58:54.000000000 +0200
+++ arpack++1.2.patched/examples/matprod/nonsym/nmatrixd.h	2006-01-26 15:37:48.000000000 +0100
@@ -77,22 +77,22 @@ void NonSymMatrixD<T>::FactorM()
   const T one  = 1.0;
   const T four = 4.0;
 
-  if (decsize != ncols()) {
-    decsize = ncols();
+  if (decsize != this->ncols()) {
+    decsize = this->ncols();
     FactorDataDeallocate();
-    Md   = new T[ncols()];
-    Me   = new T[ncols()];
+    Md   = new T[this->ncols()];
+    Me   = new T[this->ncols()];
   }
 
-  h  = one/T(ncols()+1);
+  h  = one/T(this->ncols()+1);
 
-  for (i=0; i<ncols()-1; i++) {
+  for (i=0; i<this->ncols()-1; i++) {
     Md[i] = four*h;
     Me[i] = h;
   }
-  Md[ncols()-1] = four*h;
+  Md[this->ncols()-1] = four*h;
 
-  pttrf(ncols(), Md, Me, ierr);
+  pttrf(this->ncols(), Md, Me, ierr);
 
 } // FactorM.
 
@@ -108,13 +108,13 @@ void NonSymMatrixD<T>::MultMv(T* v, T* w
   const T four = 4.0;
 
   w[0] = four*v[0] + one*v[1];
-  for (j=1; j<ncols()-1; j++) {
+  for (j=1; j<this->ncols()-1; j++) {
     w[j] = one*v[j-1] + four*v[j] + one*v[j+1];
   }
-  w[ncols()-1] = one*v[ncols()-2] + four*v[ncols()-1];
+  w[this->ncols()-1] = one*v[this->ncols()-2] + four*v[this->ncols()-1];
 
-  h = one/T(ncols()+1);
-  scal(ncols(), h, w, 1);
+  h = one/T(this->ncols()+1);
+  scal(this->ncols(), h, w, 1);
 
 } // MultMv.
 
@@ -125,7 +125,7 @@ inline void NonSymMatrixD<T>::SolveM(T* 
 
   int  ierr;
 
-  pttrs(ncols(), 1, Md, Me, v, ncols(), ierr);
+  pttrs(this->ncols(), 1, Md, Me, v, this->ncols(), ierr);
 
 } // SolveM.
 
@@ -151,4 +151,3 @@ inline NonSymMatrixD<T>::~NonSymMatrixD(
 
 
 #endif // NMATRIXD_H
-
diff -rupN arpack++1.2.orig/examples/matprod/nonsym/nmatrixe.h arpack++1.2.patched/examples/matprod/nonsym/nmatrixe.h
--- arpack++1.2.orig/examples/matprod/nonsym/nmatrixe.h	1997-08-01 16:58:15.000000000 +0200
+++ arpack++1.2.patched/examples/matprod/nonsym/nmatrixe.h	2006-01-26 15:37:48.000000000 +0100
@@ -43,15 +43,12 @@ void NonSymMatrixE<T>::MultMv(T* v, T* w
   const T two   = 2.0;
 
   w[0] = two*v[0] + three*v[1];
-  for (j=1; j<ncols()-1; j++) {
+  for (j=1; j<this->ncols()-1; j++) {
     w[j] = -two*v[j-1] + two*v[j] + three*v[j+1];
   }
-  w[ncols()-1] = -two*v[ncols()-2] + two*v[ncols()-1];
+  w[this->ncols()-1] = -two*v[this->ncols()-2] + two*v[this->ncols()-1];
 
 } //  MultMv.
 
 
 #endif // NMATRIXE_H
-
-
-
diff -rupN arpack++1.2.orig/examples/matprod/nonsym/nmatrixf.h arpack++1.2.patched/examples/matprod/nonsym/nmatrixf.h
--- arpack++1.2.orig/examples/matprod/nonsym/nmatrixf.h	1997-08-01 16:57:51.000000000 +0200
+++ arpack++1.2.patched/examples/matprod/nonsym/nmatrixf.h	2006-01-26 15:37:48.000000000 +0100
@@ -46,13 +46,12 @@ void NonSymMatrixF<T>::MultMv(T* v, T* w
   const T four = 4.0;
 
   w[0] = four*v[0] + one*v[1];
-  for (j=1; j<ncols()-1; j++) {
+  for (j=1; j<this->ncols()-1; j++) {
     w[j] = one*v[j-1] + four*v[j] + one*v[j+1];
   }
-  w[ncols()-1] = one*v[ncols()-2] + four*v[ncols()-1];
+  w[this->ncols()-1] = one*v[this->ncols()-2] + four*v[this->ncols()-1];
 
 } // MultMv.
 
 
 #endif // NMATRIXF_H
-
diff -rupN arpack++1.2.orig/examples/matprod/nonsym/nmatrixv.h arpack++1.2.patched/examples/matprod/nonsym/nmatrixv.h
--- arpack++1.2.orig/examples/matprod/nonsym/nmatrixv.h	1997-08-01 16:57:28.000000000 +0200
+++ arpack++1.2.patched/examples/matprod/nonsym/nmatrixv.h	2006-01-26 15:37:48.000000000 +0100
@@ -66,13 +66,13 @@ void NonSymMatrixV<T>::MultMv(T* v, T* w
   int  i,j;
   T    h,k,s,t,z;
 
-  h  = 1.0/T(nrows()+1);
-  k  = 1.0/T(ncols()+1);
+  h  = 1.0/T(this->nrows()+1);
+  k  = 1.0/T(this->ncols()+1);
 
-  for (i=0; i!=nrows(); i++) w[i] = 0.0;
+  for (i=0; i!=this->nrows(); i++) w[i] = 0.0;
 
   t = 0.0;
-  for (j=0; j!=ncols(); j++) {
+  for (j=0; j!=this->ncols(); j++) {
     t += k;
     s  = 0.0;
     z  = v[j];
@@ -80,7 +80,7 @@ void NonSymMatrixV<T>::MultMv(T* v, T* w
       s    += h;
       w[i] += k*s*(t-1.0)*z;
     }
-    for (i=j+1; i!=nrows(); i++) {
+    for (i=j+1; i!=this->nrows(); i++) {
       s    += h;
       w[i] += k*t*(s-1.0)*z;
     }
@@ -102,11 +102,11 @@ void NonSymMatrixV<T>::MultMtv(T* v, T* 
   int  i,j;
   T    h,k,s,t,z;
 
-  h  = 1.0/T(nrows()+1);
-  k  = 1.0/T(ncols()+1);
+  h  = 1.0/T(this->nrows()+1);
+  k  = 1.0/T(this->ncols()+1);
 
   t = 0.0;
-  for (j=0; j!=ncols(); j++) {
+  for (j=0; j!=this->ncols(); j++) {
     t += k;
     z  = 0.0;
     s  = 0.0;
@@ -114,7 +114,7 @@ void NonSymMatrixV<T>::MultMtv(T* v, T* 
       s += h;
       z += k*s*(t-1.0)*v[i];
     }
-    for (i=j+1; i!=nrows(); i++) {
+    for (i=j+1; i!=this->nrows(); i++) {
       s += h;
       z += k*t*(s-1.0)*v[i];
     }
@@ -134,7 +134,7 @@ void NonSymMatrixV<T>::MultOPv(T* v, T* 
 
 {
 
-  T* t = new T[nrows()];
+  T* t = new T[this->nrows()];
 
   MultMv(v,t);
   MultMtv(t,w);
diff -rupN arpack++1.2.orig/examples/matprod/sym/smatrixb.h arpack++1.2.patched/examples/matprod/sym/smatrixb.h
--- arpack++1.2.orig/examples/matprod/sym/smatrixb.h	2000-02-21 21:34:54.000000000 +0100
+++ arpack++1.2.patched/examples/matprod/sym/smatrixb.h	2006-01-26 15:37:47.000000000 +0100
@@ -80,25 +80,25 @@ void SymMatrixB<ART>::FactorOP()
   const ART one = 1.0;
   const ART two = 2.0;
 
-  if (decsize != ncols()) {
-    decsize = ncols();
+  if (decsize != this->ncols()) {
+    decsize = this->ncols();
     FactorDataDeallocate();
-    Ad   = new ART[ncols()];
-    Adl  = new ART[ncols()];
-    Adu  = new ART[ncols()];
-    Adu2 = new ART[ncols()];
-    ipiv = new int[ncols()];
+    Ad   = new ART[this->ncols()];
+    Adl  = new ART[this->ncols()];
+    Adu  = new ART[this->ncols()];
+    Adu2 = new ART[this->ncols()];
+    ipiv = new int[this->ncols()];
   }
 
-  h2 = ART((ncols()+1)*(ncols()+1));
+  h2 = ART((this->ncols()+1)*(this->ncols()+1));
 
-  for (i=0; i<ncols(); i++) {
+  for (i=0; i<this->ncols(); i++) {
     Ad[i]  = two*h2 - shift;
     Adl[i] = -one*h2;
   }
 
-  copy(ncols(), Adl, 1, Adu, 1);
-  gttrf(ncols(), Adl, Ad, Adu, Adu2, ipiv, ierr);
+  copy(this->ncols(), Adl, 1, Adu, 1);
+  gttrf(this->ncols(), Adl, Ad, Adu, Adu2, ipiv, ierr);
 
 } // FactorOP.
 
@@ -117,15 +117,15 @@ void SymMatrixB<ART>::MultMv(ART* v, ART
   const ART two = 2.0;
 
   w[0] =  two*v[0] - v[1];
-  for (j=1; j<ncols()-1; j++) {
+  for (j=1; j<this->ncols()-1; j++) {
     w[j] = - v[j-1] + two*v[j] - v[j+1];
   }
-  w[ncols()-1] = - v[ncols()-2] + two*v[ncols()-1];
+  w[this->ncols()-1] = - v[this->ncols()-2] + two*v[this->ncols()-1];
 
   // Scaling the vector w by (1 / h^2).
 
-  h2 = ART((ncols()+1)*(ncols()+1));
-  scal(ncols(), h2, w, 1L);
+  h2 = ART((this->ncols()+1)*(this->ncols()+1));
+  scal(this->ncols(), h2, w, 1L);
 
   return;
 
@@ -143,8 +143,8 @@ void SymMatrixB<ART>::MultOPv(ART* v, AR
   int  ierr;
   char *type = "N";
 
-  copy(ncols(), v, 1, w, 1);
-  gttrs(type, ncols(), 1, Adl, Ad, Adu, Adu2, ipiv, w, ncols(), ierr);
+  copy(this->ncols(), v, 1, w, 1);
+  gttrs(type, this->ncols(), 1, Adl, Ad, Adu, Adu2, ipiv, w, this->ncols(), ierr);
 
 } // MultOPv
 
@@ -197,4 +197,3 @@ inline SymMatrixB<ART>::~SymMatrixB()
 
 
 #endif // SMATRIXB_H
-
diff -rupN arpack++1.2.orig/examples/matprod/sym/smatrixc.h arpack++1.2.patched/examples/matprod/sym/smatrixc.h
--- arpack++1.2.orig/examples/matprod/sym/smatrixc.h	2000-02-21 21:42:08.000000000 +0100
+++ arpack++1.2.patched/examples/matprod/sym/smatrixc.h	2006-01-26 15:37:47.000000000 +0100
@@ -50,15 +50,15 @@ void SymMatrixC<ART>::MultMv(ART* v, ART
   const ART two = 2.0;
 
   w[0] =  two*v[0] - v[1];
-  for (j=1; j<ncols()-1; j++) {
+  for (j=1; j<this->ncols()-1; j++) {
     w[j] = - v[j-1] + two*v[j] - v[j+1];
   }
-  w[ncols()-1] = - v[ncols()-2] + two*v[ncols()-1];
+  w[this->ncols()-1] = - v[this->ncols()-2] + two*v[this->ncols()-1];
 
   // Scaling the vector w by (1 / h).
 
-  h2 = ART(ncols()+1);
-  scal(ncols(), h2, w, 1L);
+  h2 = ART(this->ncols()+1);
+  scal(this->ncols(), h2, w, 1L);
 
   return;
 
@@ -66,4 +66,3 @@ void SymMatrixC<ART>::MultMv(ART* v, ART
 
 
 #endif // SMATRIXC_H
-
diff -rupN arpack++1.2.orig/examples/matprod/sym/smatrixd.h arpack++1.2.patched/examples/matprod/sym/smatrixd.h
--- arpack++1.2.orig/examples/matprod/sym/smatrixd.h	2000-02-21 21:31:52.000000000 +0100
+++ arpack++1.2.patched/examples/matprod/sym/smatrixd.h	2006-01-26 15:37:47.000000000 +0100
@@ -76,27 +76,27 @@ void SymMatrixD<ART>::FactorM()
   const ART four = 4.0;
   const ART six  = 6.0;
 
-  if (decsize != ncols()) {
-    decsize = ncols();
+  if (decsize != this->ncols()) {
+    decsize = this->ncols();
     FactorDataDeallocate();
-    Ad   = new ART[ncols()];
-    Adl  = new ART[ncols()];
-    Adu  = new ART[ncols()];
-    Adu2 = new ART[ncols()];
-    ipiv = new int[ncols()];
+    Ad   = new ART[this->ncols()];
+    Adl  = new ART[this->ncols()];
+    Adu  = new ART[this->ncols()];
+    Adu2 = new ART[this->ncols()];
+    ipiv = new int[this->ncols()];
   }
 
-  h  = one/ART(ncols()+1);
+  h  = one/ART(this->ncols()+1);
   r2 = h/six;
   r1 = r2*four;
 
-  for (i=0; i<ncols(); i++) {
+  for (i=0; i<this->ncols(); i++) {
     Ad[i]  = r1;
     Adl[i] = r2;
   }
 
-  copy(ncols(), Adl, 1, Adu, 1);
-  gttrf(ncols(), Adl, Ad, Adu, Adu2, ipiv, ierr);
+  copy(this->ncols(), Adl, 1, Adu, 1);
+  gttrf(this->ncols(), Adl, Ad, Adu, Adu2, ipiv, ierr);
 
 } // FactorM.
 
@@ -110,7 +110,7 @@ inline void SymMatrixD<ART>::SolveM(ART*
   int  ierr;
   char *type = "N";
 
-  gttrs(type, ncols(), 1, Adl, Ad, Adu, Adu2, ipiv, v, ncols(), ierr);
+  gttrs(type, this->ncols(), 1, Adl, Ad, Adu, Adu2, ipiv, v, this->ncols(), ierr);
 
 } // SolveM.
 
@@ -128,15 +128,15 @@ void SymMatrixD<ART>::MultMv(ART* v, ART
   const ART six  = 6.0;
 
   w[0] = four*v[0] + v[1];
-  for (j=1; j<ncols()-1; j++) {
+  for (j=1; j<this->ncols()-1; j++) {
     w[j] = v[j-1] + four*v[j] + v[j+1];
   }
-  w[ncols()-1] = v[ncols()-2] + four*v[ncols()-1];
+  w[this->ncols()-1] = v[this->ncols()-2] + four*v[this->ncols()-1];
 
   // Scaling the vector w by h.
 
-  h = one / (ART(ncols()+1)*six);
-  scal(ncols(), h, w, 1L);
+  h = one / (ART(this->ncols()+1)*six);
+  scal(this->ncols(), h, w, 1L);
 
   return;
 
@@ -171,4 +171,3 @@ inline SymMatrixD<ART>::~SymMatrixD()
 
 
 #endif // SMATRIXD_H
-
diff -rupN arpack++1.2.orig/examples/matrices/complex/lcompsol.h arpack++1.2.patched/examples/matrices/complex/lcompsol.h
--- arpack++1.2.orig/examples/matrices/complex/lcompsol.h	2000-02-22 12:49:50.000000000 +0100
+++ arpack++1.2.patched/examples/matrices/complex/lcompsol.h	2006-01-26 15:37:48.000000000 +0100
@@ -18,7 +18,7 @@
 #ifndef LCOMPSOL_H
 #define LCOMPSOL_H
 
-#include <math.h>
+#include <cmath>
 #include "arcomp.h"
 #include "blas1c.h"
 #include "lapackc.h"
@@ -40,7 +40,7 @@ template<class ARMATRIX, class ARFLOAT>
 void Solution(ARMATRIX &A, ARluCompStdEig<ARFLOAT> &Prob)
 /*
   Prints eigenvalues and eigenvectors of complex eigen-problems
-  on standard "cout" stream.
+  on standard "std::cout" stream.
 */
 
 {
@@ -53,32 +53,32 @@ void Solution(ARMATRIX &A, ARluCompStdEi
   nconv = Prob.ConvergedEigenvalues();
   mode  = Prob.GetMode();
 
-  cout << endl << endl << "Testing ARPACK++ class ARluCompStdEig \n";
-  cout << "Complex eigenvalue problem: A*x - lambda*x" << endl;
+  std::cout << std::endl << std::endl << "Testing ARPACK++ class ARluCompStdEig \n";
+  std::cout << "Complex eigenvalue problem: A*x - lambda*x" << std::endl;
   switch (mode) {
   case 1:
-    cout << "Regular mode" << endl << endl;
+    std::cout << "Regular mode" << std::endl << std::endl;
     break;
   case 3:
-    cout << "Shift and invert mode" << endl << endl;
+    std::cout << "Shift and invert mode" << std::endl << std::endl;
   }
 
-  cout << "Dimension of the system            : " << n              << endl;
-  cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
-  cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
-  cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
-  cout << endl;
+  std::cout << "Dimension of the system            : " << n              << std::endl;
+  std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
+  std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
+  std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
+  std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
+  std::cout << std::endl;
 
   if (Prob.EigenvaluesFound()) {
 
     // Printing eigenvalues.
 
-    cout << "Eigenvalues:" << endl;
+    std::cout << "Eigenvalues:" << std::endl;
     for (i=0; i<nconv; i++) {
-      cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
+      std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
   }
 
   if (Prob.EigenvectorsFound()) {
@@ -97,10 +97,10 @@ void Solution(ARMATRIX &A, ARluCompStdEi
     }
 
     for (i=0; i<nconv; i++) {
-      cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
-      cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << endl;
+      std::cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
+      std::cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << std::endl;
     }
-    cout << "\n";
+    std::cout << "\n";
 
     delete[] Ax;
     delete[] ResNorm;
@@ -114,7 +114,7 @@ template<class MATRA, class MATRB, class
 void Solution(MATRA &A, MATRB &B, ARluCompGenEig<ARFLOAT> &Prob)
 /*
   Prints eigenvalues and eigenvectors of complex generalized
-  eigen-problems on standard "cout" stream.
+  eigen-problems on standard "std::cout" stream.
 */
 
 {
@@ -128,33 +128,33 @@ void Solution(MATRA &A, MATRB &B, ARluCo
   nconv = Prob.ConvergedEigenvalues();
   mode  = Prob.GetMode();
 
-  cout << endl << endl; 
-  cout << "Testing ARPACK++ class ARluCompGenEig \n" << endl;
-  cout << "Complex generalized eigenvalue problem: A*x - lambda*B*x" << endl;
+  std::cout << std::endl << std::endl; 
+  std::cout << "Testing ARPACK++ class ARluCompGenEig \n" << std::endl;
+  std::cout << "Complex generalized eigenvalue problem: A*x - lambda*B*x" << std::endl;
   switch (mode) {
   case 2:
-    cout << "Regular mode" << endl << endl;
+    std::cout << "Regular mode" << std::endl << std::endl;
     break;
   case 3:
-    cout << "Shift and invert mode" << endl << endl;
+    std::cout << "Shift and invert mode" << std::endl << std::endl;
   }
 
-  cout << "Dimension of the system            : " << n              << endl;
-  cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
-  cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
-  cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
-  cout << endl;
+  std::cout << "Dimension of the system            : " << n              << std::endl;
+  std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
+  std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
+  std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
+  std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
+  std::cout << std::endl;
 
   if (Prob.EigenvaluesFound()) {
 
     // Printing eigenvalues.
 
-    cout << "Eigenvalues:" << endl;
+    std::cout << "Eigenvalues:" << std::endl;
     for (i=0; i<nconv; i++) {
-      cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
+      std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
   }
 
   if (Prob.EigenvectorsFound()) {
@@ -175,10 +175,10 @@ void Solution(MATRA &A, MATRB &B, ARluCo
     }
 
     for (i=0; i<nconv; i++) {
-      cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
-      cout << ")*B*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
+      std::cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
+      std::cout << ")*B*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
     }
-    cout << endl;
+    std::cout << std::endl;
 
     delete[] Ax;
     delete[] Bx;
diff -rupN arpack++1.2.orig/examples/matrices/nonsym/bnmatrxa.h arpack++1.2.patched/examples/matrices/nonsym/bnmatrxa.h
--- arpack++1.2.orig/examples/matrices/nonsym/bnmatrxa.h	2000-02-22 13:19:18.000000000 +0100
+++ arpack++1.2.patched/examples/matrices/nonsym/bnmatrxa.h	2006-01-26 15:37:48.000000000 +0100
@@ -29,7 +29,7 @@
 #ifndef BNMATRXA_H
 #define BNMATRXA_H
 
-#include <math.h>
+#include <cmath>
 
 template<class ARFLOAT, class ARINT>
 void BandMatrixA(ARINT nx, ARFLOAT rho, ARINT& n, ARINT& nL, ARINT& nU, 
diff -rupN arpack++1.2.orig/examples/matrices/nonsym/dnmatrxa.h arpack++1.2.patched/examples/matrices/nonsym/dnmatrxa.h
--- arpack++1.2.orig/examples/matrices/nonsym/dnmatrxa.h	2000-02-22 13:15:31.000000000 +0100
+++ arpack++1.2.patched/examples/matrices/nonsym/dnmatrxa.h	2006-01-26 15:37:48.000000000 +0100
@@ -29,7 +29,7 @@
 #ifndef DNMATRXA_H
 #define DNMATRXA_H
 
-#include <math.h>
+#include <cmath>
 
 template<class ARFLOAT, class ARINT>
 void DenseMatrixA(ARINT nx, ARFLOAT rho, ARINT& n, ARFLOAT* &A)
diff -rupN arpack++1.2.orig/examples/matrices/nonsym/lnmatrxa.h arpack++1.2.patched/examples/matrices/nonsym/lnmatrxa.h
--- arpack++1.2.orig/examples/matrices/nonsym/lnmatrxa.h	2000-02-22 13:11:45.000000000 +0100
+++ arpack++1.2.patched/examples/matrices/nonsym/lnmatrxa.h	2006-01-26 15:37:48.000000000 +0100
@@ -9,7 +9,7 @@
 #ifndef LNMATRXA_H
 #define LNMATRXA_H
 
-#include <math.h>
+#include <cmath>
 
 template<class ARFLOAT, class ARINT>
 
diff -rupN arpack++1.2.orig/examples/matrices/nonsym/lnmatrxb.h arpack++1.2.patched/examples/matrices/nonsym/lnmatrxb.h
--- arpack++1.2.orig/examples/matrices/nonsym/lnmatrxb.h	2000-02-22 13:11:03.000000000 +0100
+++ arpack++1.2.patched/examples/matrices/nonsym/lnmatrxb.h	2006-01-26 15:37:48.000000000 +0100
@@ -29,7 +29,7 @@
 #ifndef LNMATRXB_H
 #define LNMATRXB_H
 
-#include <math.h>
+#include <cmath>
 
 template<class ARFLOAT, class ARINT>
 void BlockTridMatrix(ARINT nx, ARINT& n, ARINT& nnz,
diff -rupN arpack++1.2.orig/examples/matrices/nonsym/lnsymsol.h arpack++1.2.patched/examples/matrices/nonsym/lnsymsol.h
--- arpack++1.2.orig/examples/matrices/nonsym/lnsymsol.h	2000-02-22 13:05:25.000000000 +0100
+++ arpack++1.2.patched/examples/matrices/nonsym/lnsymsol.h	2006-01-26 15:37:48.000000000 +0100
@@ -18,7 +18,7 @@
 #ifndef LNSYMSOL_H
 #define LNSYMSOL_H
 
-#include <math.h>
+#include <cmath>
 #include "blas1c.h"
 #include "lapackc.h"
 #ifdef ARLNSMAT_H
@@ -40,7 +40,7 @@ template<class ARMATRIX, class ARFLOAT>
 void Solution(ARMATRIX &A, ARluNonSymStdEig<ARFLOAT> &Prob)
 /*
   Prints eigenvalues and eigenvectors of nonsymmetric eigen-problems
-  on standard "cout" stream.
+  on standard "std::cout" stream.
 */
 
 {
@@ -53,38 +53,38 @@ void Solution(ARMATRIX &A, ARluNonSymStd
   nconv = Prob.ConvergedEigenvalues();
   mode  = Prob.GetMode();
 
-  cout << endl << endl << "Testing ARPACK++ class ARluNonSymStdEig \n";
-  cout << "Real nonsymmetric eigenvalue problem: A*x - lambda*x" << endl;
+  std::cout << std::endl << std::endl << "Testing ARPACK++ class ARluNonSymStdEig \n";
+  std::cout << "Real nonsymmetric eigenvalue problem: A*x - lambda*x" << std::endl;
   switch (mode) {
   case 1:
-    cout << "Regular mode" << endl << endl;
+    std::cout << "Regular mode" << std::endl << std::endl;
     break;
   case 3:
-    cout << "Shift and invert mode" << endl << endl;
+    std::cout << "Shift and invert mode" << std::endl << std::endl;
   }
 
-  cout << "Dimension of the system            : " << n              << endl;
-  cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
-  cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
-  cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
-  cout << endl;
+  std::cout << "Dimension of the system            : " << n              << std::endl;
+  std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
+  std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
+  std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
+  std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
+  std::cout << std::endl;
 
   if (Prob.EigenvaluesFound()) {
 
     // Printing eigenvalues.
 
-    cout << "Eigenvalues:" << endl;
+    std::cout << "Eigenvalues:" << std::endl;
     for (i=0; i<nconv; i++) {
-      cout << "  lambda[" << (i+1) << "]: " << Prob.EigenvalueReal(i);
+      std::cout << "  lambda[" << (i+1) << "]: " << Prob.EigenvalueReal(i);
       if (Prob.EigenvalueImag(i)>=0.0) {
-        cout << " + " << Prob.EigenvalueImag(i) << " I" << endl;
+        std::cout << " + " << Prob.EigenvalueImag(i) << " I" << std::endl;
       }
       else {
-        cout << " - " << fabs(Prob.EigenvalueImag(i)) << " I" << endl;
+        std::cout << " - " << fabs(Prob.EigenvalueImag(i)) << " I" << std::endl;
       }
     }
-    cout << endl;
+    std::cout << std::endl;
   }
   
   if (Prob.EigenvectorsFound()) {
@@ -122,10 +122,10 @@ void Solution(ARMATRIX &A, ARluNonSymStd
     }
 
     for (i=0; i<nconv; i++) {
-      cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
-      cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
+      std::cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
+      std::cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
     }
-    cout << "\n";
+    std::cout << "\n";
 
     delete[] Ax;
     delete[] ResNorm;
@@ -139,7 +139,7 @@ template<class MATRA, class MATRB, class
 void Solution(MATRA &A, MATRB &B, ARluNonSymGenEig<ARFLOAT> &Prob)
 /*
   Prints eigenvalues and eigenvectors of nonsymmetric generalized
-  eigen-problems on standard "cout" stream.
+  eigen-problems on standard "std::cout" stream.
 */
 
 {
@@ -153,43 +153,43 @@ void Solution(MATRA &A, MATRB &B, ARluNo
   nconv = Prob.ConvergedEigenvalues();
   mode  = Prob.GetMode();
 
-  cout << endl << endl << "Testing ARPACK++ class ARluNonSymGenEig \n";
-  cout << "Real nonsymmetric generalized eigenvalue problem: A*x - lambda*B*x";
-  cout << endl;
+  std::cout << std::endl << std::endl << "Testing ARPACK++ class ARluNonSymGenEig \n";
+  std::cout << "Real nonsymmetric generalized eigenvalue problem: A*x - lambda*B*x";
+  std::cout << std::endl;
   switch (mode) {
   case 2:
-    cout << "Regular mode" << endl;
+    std::cout << "Regular mode" << std::endl;
     break;
   case 3:
-    cout << "Shift and invert mode (using the real part of OP)" << endl;
+    std::cout << "Shift and invert mode (using the real part of OP)" << std::endl;
     break;
   case 4:
-    cout << "Shift and invert mode (using the imaginary part of OP)" << endl;
+    std::cout << "Shift and invert mode (using the imaginary part of OP)" << std::endl;
   }
-  cout << endl;
+  std::cout << std::endl;
 
-  cout << "Dimension of the system            : " << n              << endl;
-  cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
-  cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
-  cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
-  cout << endl;
+  std::cout << "Dimension of the system            : " << n              << std::endl;
+  std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
+  std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
+  std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
+  std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
+  std::cout << std::endl;
 
   if (Prob.EigenvaluesFound()) {
 
     // Printing eigenvalues.
 
-    cout << "Eigenvalues:" << endl;
+    std::cout << "Eigenvalues:" << std::endl;
     for (i=0; i<nconv; i++) {
-      cout << "  lambda[" << (i+1) << "]: " << Prob.EigenvalueReal(i);
+      std::cout << "  lambda[" << (i+1) << "]: " << Prob.EigenvalueReal(i);
       if (Prob.EigenvalueImag(i)>=0.0) {
-        cout << " + " << Prob.EigenvalueImag(i) << " I" << endl;
+        std::cout << " + " << Prob.EigenvalueImag(i) << " I" << std::endl;
       }
       else {
-        cout << " - " << fabs(Prob.EigenvalueImag(i)) << " I" << endl;
+        std::cout << " - " << fabs(Prob.EigenvalueImag(i)) << " I" << std::endl;
       }
     }
-    cout << endl;
+    std::cout << std::endl;
   }
 
   if (Prob.EigenvectorsFound()) {
@@ -232,10 +232,10 @@ void Solution(MATRA &A, MATRB &B, ARluNo
     }
 
     for (i=0; i<nconv; i++) {
-      cout << "||A*x(" << i << ") - lambda(" << i;
-      cout << ")*B*x(" << i << ")||: " << ResNorm[i] << "\n";
+      std::cout << "||A*x(" << i << ") - lambda(" << i;
+      std::cout << ")*B*x(" << i << ")||: " << ResNorm[i] << "\n";
     }
-    cout << "\n";
+    std::cout << "\n";
 
     delete[] Ax;
     delete[] Bx;
diff -rupN arpack++1.2.orig/examples/matrices/nonsym/lsvdsol.h arpack++1.2.patched/examples/matrices/nonsym/lsvdsol.h
--- arpack++1.2.orig/examples/matrices/nonsym/lsvdsol.h	2000-02-22 13:06:13.000000000 +0100
+++ arpack++1.2.patched/examples/matrices/nonsym/lsvdsol.h	2006-01-26 15:37:48.000000000 +0100
@@ -19,7 +19,7 @@
 #ifndef LSVDSOL_H
 #define LSVDSOL_H
 
-#include <math.h>
+#include <cmath>
 #include "blas1c.h"
 #include "lapackc.h"
 #include "arssym.h"
@@ -28,7 +28,7 @@
 template<class ARMATRIX, class ARFLOAT, class ARFOP>
 void Solution(ARMATRIX &A, ARSymStdEig<ARFLOAT, ARFOP> &Prob)
 /*
-  Prints singular values and vectors on standard "cout" stream.
+  Prints singular values and vectors on standard "std::cout" stream.
 */
 
 {
@@ -42,24 +42,24 @@ void Solution(ARMATRIX &A, ARSymStdEig<A
   nAx   = (n>m)?n:m;
   nconv = Prob.ConvergedEigenvalues();
 
-  cout << endl << endl << "Testing ARPACK++ class ARSymStdEig \n";
-  cout << "SVD problems: A = U*S*V'" << endl;
+  std::cout << std::endl << std::endl << "Testing ARPACK++ class ARSymStdEig \n";
+  std::cout << "SVD problems: A = U*S*V'" << std::endl;
 
-  cout << "Dimension of the system            : " << Prob.GetN()   << endl;
-  cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev() << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv         << endl;
-  cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv() << endl;
-  cout << endl;
+  std::cout << "Dimension of the system            : " << Prob.GetN()   << std::endl;
+  std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev() << std::endl;
+  std::cout << "Number of 'converged' eigenvalues  : " << nconv         << std::endl;
+  std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv() << std::endl;
+  std::cout << std::endl;
 
   if (Prob.EigenvaluesFound()) {
 
     // Printing singular values.
 
-    cout << "Singular values:" << endl;
+    std::cout << "Singular values:" << std::endl;
     for (i=0; i<nconv; i++) {
-      cout << "  sigma[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
+      std::cout << "  sigma[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
   }
 
   if (Prob.EigenvectorsFound()) {
@@ -82,10 +82,10 @@ void Solution(ARMATRIX &A, ARSymStdEig<A
     }
 
     for (i=0; i<nconv; i++) {
-      cout << "||A*v(" << (i+1) << ") - sigma(" << (i+1);
-      cout << ")*u(" << (i+1) << ")||: " << ResNorm[i] << endl;
+      std::cout << "||A*v(" << (i+1) << ") - sigma(" << (i+1);
+      std::cout << ")*u(" << (i+1) << ")||: " << ResNorm[i] << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
 
     // Printing the residual norm || A'*u - sigma*v ||
     // for the nconv accurately computed vectors u and v.
@@ -99,10 +99,10 @@ void Solution(ARMATRIX &A, ARSymStdEig<A
     }
 
     for (i=0; i<nconv; i++) {
-      cout << "||A'*u(" << (i+1) << ") - sigma(" << (i+1);
-      cout << ")*v(" << (i+1) << ")||: " << ResNorm[i] << endl;
+      std::cout << "||A'*u(" << (i+1) << ") - sigma(" << (i+1);
+      std::cout << ")*v(" << (i+1) << ")||: " << ResNorm[i] << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
 
     delete[] Ax;
     delete[] ResNorm;
diff -rupN arpack++1.2.orig/examples/matrices/sym/bsmatrxa.h arpack++1.2.patched/examples/matrices/sym/bsmatrxa.h
--- arpack++1.2.orig/examples/matrices/sym/bsmatrxa.h	2000-02-22 13:27:38.000000000 +0100
+++ arpack++1.2.patched/examples/matrices/sym/bsmatrxa.h	2006-01-26 15:37:48.000000000 +0100
@@ -31,7 +31,7 @@
 #ifndef BSMATRXA_H
 #define BSMATRXA_H
 
-#include <math.h>
+#include <cmath>
 
 template<class ARFLOAT, class ARINT>
 void BandMatrixA(ARINT nx, ARINT& n, ARINT& nD, ARFLOAT* &A, char uplo='L')
diff -rupN arpack++1.2.orig/examples/matrices/sym/bsmatrxb.h arpack++1.2.patched/examples/matrices/sym/bsmatrxb.h
--- arpack++1.2.orig/examples/matrices/sym/bsmatrxb.h	2000-02-22 13:27:05.000000000 +0100
+++ arpack++1.2.patched/examples/matrices/sym/bsmatrxb.h	2006-01-26 15:37:48.000000000 +0100
@@ -22,7 +22,7 @@
 #ifndef BSMATRXB_H
 #define BSMATRXB_H
 
-#include <math.h>
+#include <cmath>
 
 template<class ARFLOAT, class ARINT>
 void BandMatrixB(ARINT n, ARINT& nD, ARFLOAT* &A, char uplo='L')
diff -rupN arpack++1.2.orig/examples/matrices/sym/bsmatrxc.h arpack++1.2.patched/examples/matrices/sym/bsmatrxc.h
--- arpack++1.2.orig/examples/matrices/sym/bsmatrxc.h	2000-02-22 13:26:36.000000000 +0100
+++ arpack++1.2.patched/examples/matrices/sym/bsmatrxc.h	2006-01-26 15:37:48.000000000 +0100
@@ -22,7 +22,7 @@
 #ifndef BSMATRXC_H
 #define BSMATRXC_H
 
-#include <math.h>
+#include <cmath>
 
 template<class ARFLOAT, class ARINT>
 void BandMatrixC(ARINT n, ARINT& nD, ARFLOAT* &A, char uplo='L')
diff -rupN arpack++1.2.orig/examples/matrices/sym/dsmatrxa.h arpack++1.2.patched/examples/matrices/sym/dsmatrxa.h
--- arpack++1.2.orig/examples/matrices/sym/dsmatrxa.h	2000-02-22 13:25:58.000000000 +0100
+++ arpack++1.2.patched/examples/matrices/sym/dsmatrxa.h	2006-01-26 15:37:48.000000000 +0100
@@ -27,7 +27,7 @@
 #ifndef DSMATRXA_H
 #define DSMATRXA_H
 
-#include <math.h>
+#include <cmath>
 
 template<class ARFLOAT, class ARINT>
 void DenseMatrixA(ARINT nx, ARINT& n, ARFLOAT* &A, char uplo = 'L')
diff -rupN arpack++1.2.orig/examples/matrices/sym/dsmatrxb.h arpack++1.2.patched/examples/matrices/sym/dsmatrxb.h
--- arpack++1.2.orig/examples/matrices/sym/dsmatrxb.h	2000-02-22 13:25:27.000000000 +0100
+++ arpack++1.2.patched/examples/matrices/sym/dsmatrxb.h	2006-01-26 15:37:48.000000000 +0100
@@ -18,7 +18,7 @@
 #ifndef DSMATRXB_H
 #define DSMATRXB_H
 
-#include <math.h>
+#include <cmath>
 
 template<class ARFLOAT, class ARINT>
 void DenseMatrixB(ARINT n, ARFLOAT* &A, char uplo = 'L')
diff -rupN arpack++1.2.orig/examples/matrices/sym/dsmatrxc.h arpack++1.2.patched/examples/matrices/sym/dsmatrxc.h
--- arpack++1.2.orig/examples/matrices/sym/dsmatrxc.h	2000-02-22 13:24:55.000000000 +0100
+++ arpack++1.2.patched/examples/matrices/sym/dsmatrxc.h	2006-01-26 15:37:48.000000000 +0100
@@ -18,7 +18,7 @@
 #ifndef DSMATRXC_H
 #define DSMATRXC_H
 
-#include <math.h>
+#include <cmath>
 
 template<class ARFLOAT, class ARINT>
 void DenseMatrixC(ARINT n, ARFLOAT* &A, char uplo='L')
diff -rupN arpack++1.2.orig/examples/matrices/sym/lsmatrxa.h arpack++1.2.patched/examples/matrices/sym/lsmatrxa.h
--- arpack++1.2.orig/examples/matrices/sym/lsmatrxa.h	2000-02-22 13:24:25.000000000 +0100
+++ arpack++1.2.patched/examples/matrices/sym/lsmatrxa.h	2006-01-26 15:37:48.000000000 +0100
@@ -27,7 +27,7 @@
 #ifndef LSMATRXA_H
 #define LSMATRXA_H
 
-#include <math.h>
+#include <cmath>
 
 template<class ARFLOAT, class ARINT>
 void SymmetricMatrixA(ARINT nx, ARINT& n, ARINT& nnz, ARFLOAT* &A, 
diff -rupN arpack++1.2.orig/examples/matrices/sym/lsmatrxb.h arpack++1.2.patched/examples/matrices/sym/lsmatrxb.h
--- arpack++1.2.orig/examples/matrices/sym/lsmatrxb.h	2000-02-22 13:23:35.000000000 +0100
+++ arpack++1.2.patched/examples/matrices/sym/lsmatrxb.h	2006-01-26 15:37:48.000000000 +0100
@@ -18,7 +18,7 @@
 #ifndef LSMATRXB_H
 #define LSMATRXB_H
 
-#include <math.h>
+#include <cmath>
 
 template<class ARFLOAT, class ARINT>
 void SymmetricMatrixB(ARINT n, ARINT& nnz, ARFLOAT* &A, 
diff -rupN arpack++1.2.orig/examples/matrices/sym/lsmatrxc.h arpack++1.2.patched/examples/matrices/sym/lsmatrxc.h
--- arpack++1.2.orig/examples/matrices/sym/lsmatrxc.h	2000-02-22 13:23:01.000000000 +0100
+++ arpack++1.2.patched/examples/matrices/sym/lsmatrxc.h	2006-01-26 15:37:48.000000000 +0100
@@ -20,7 +20,7 @@
 #ifndef LSMATRXC_H
 #define LSMATRXC_H
 
-#include <math.h>
+#include <cmath>
 
 template<class ARFLOAT, class ARINT>
 void SymmetricMatrixC(ARINT n, ARINT& nnz, ARFLOAT* &A, 
diff -rupN arpack++1.2.orig/examples/matrices/sym/lsmatrxd.h arpack++1.2.patched/examples/matrices/sym/lsmatrxd.h
--- arpack++1.2.orig/examples/matrices/sym/lsmatrxd.h	2000-02-22 13:21:37.000000000 +0100
+++ arpack++1.2.patched/examples/matrices/sym/lsmatrxd.h	2006-01-26 15:37:48.000000000 +0100
@@ -18,7 +18,7 @@
 #ifndef LSMATRXD_H
 #define LSMATRXD_H
 
-#include <math.h>
+#include <cmath>
 
 template<class ARFLOAT, class ARINT>
 void SymmetricMatrixD(ARINT n, ARINT& nnz, ARFLOAT* &A, 
diff -rupN arpack++1.2.orig/examples/matrices/sym/lsymsol.h arpack++1.2.patched/examples/matrices/sym/lsymsol.h
--- arpack++1.2.orig/examples/matrices/sym/lsymsol.h	2000-02-22 13:22:25.000000000 +0100
+++ arpack++1.2.patched/examples/matrices/sym/lsymsol.h	2006-01-26 15:37:48.000000000 +0100
@@ -18,7 +18,7 @@
 #ifndef LSYMSOL_H
 #define LSYMSOL_H
 
-#include <math.h>
+#include <cmath>
 #include "blas1c.h"
 #include "lapackc.h"
 #ifdef ARLSMAT_H
@@ -53,33 +53,33 @@ void Solution(ARMATRIX &A, ARluSymStdEig
   nconv = Prob.ConvergedEigenvalues();
   mode  = Prob.GetMode();
 
-  cout << endl << endl << "Testing ARPACK++ class ARluSymStdEig \n";
-  cout << "Real symmetric eigenvalue problem: A*x - lambda*x" << endl;
+  std::cout << std::endl << std::endl << "Testing ARPACK++ class ARluSymStdEig \n";
+  std::cout << "Real symmetric eigenvalue problem: A*x - lambda*x" << std::endl;
   switch (mode) {
   case 1:
-    cout << "Regular mode" << endl;
+    std::cout << "Regular mode" << std::endl;
     break;
   case 3:
-    cout << "Shift and invert mode" << endl;
+    std::cout << "Shift and invert mode" << std::endl;
   }
-  cout << endl;
+  std::cout << std::endl;
 
-  cout << "Dimension of the system            : " << n              << endl;
-  cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
-  cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
-  cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
-  cout << endl;
+  std::cout << "Dimension of the system            : " << n              << std::endl;
+  std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
+  std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
+  std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
+  std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
+  std::cout << std::endl;
 
   if (Prob.EigenvaluesFound()) {
 
     // Printing eigenvalues.
 
-    cout << "Eigenvalues:" << endl;
+    std::cout << "Eigenvalues:" << std::endl;
     for (i=0; i<nconv; i++) {
-      cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
+      std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
   }
 
   if (Prob.EigenvectorsFound()) {
@@ -97,10 +97,10 @@ void Solution(ARMATRIX &A, ARluSymStdEig
     }
 
     for (i=0; i<nconv; i++) {
-      cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
-      cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
+      std::cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
+      std::cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
     }
-    cout << "\n";
+    std::cout << "\n";
 
     delete[] Ax;
     delete[] ResNorm;
@@ -126,40 +126,40 @@ void Solution(MATRA &A, MATRB &B, ARluSy
   nconv = Prob.ConvergedEigenvalues();
   mode  = Prob.GetMode();
 
-  cout << endl << endl << "Testing ARPACK++ class ARluSymGenEig \n";
-  cout << "Real symmetric generalized eigenvalue problem: A*x - lambda*B*x";
-  cout << endl;
+  std::cout << std::endl << std::endl << "Testing ARPACK++ class ARluSymGenEig \n";
+  std::cout << "Real symmetric generalized eigenvalue problem: A*x - lambda*B*x";
+  std::cout << std::endl;
   switch (mode) {
   case 2:
-    cout << "Regular mode" << endl;
+    std::cout << "Regular mode" << std::endl;
     break;
   case 3:
-    cout << "Shift and invert mode" << endl;
+    std::cout << "Shift and invert mode" << std::endl;
     break;
   case 4:
-    cout << "Buckling mode" << endl;
+    std::cout << "Buckling mode" << std::endl;
     break;
   case 5:
-    cout << "Cayley mode" << endl;
+    std::cout << "Cayley mode" << std::endl;
   }
-  cout << endl;
+  std::cout << std::endl;
 
-  cout << "Dimension of the system            : " << n              << endl;
-  cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
-  cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
-  cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
-  cout << endl;
+  std::cout << "Dimension of the system            : " << n              << std::endl;
+  std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
+  std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
+  std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
+  std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
+  std::cout << std::endl;
 
   if (Prob.EigenvaluesFound()) {
 
     // Printing eigenvalues.
 
-    cout << "Eigenvalues:" << endl;
+    std::cout << "Eigenvalues:" << std::endl;
     for (i=0; i<nconv; i++) {
-      cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
+      std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
   }
 
   if (Prob.EigenvectorsFound()) {
@@ -179,10 +179,10 @@ void Solution(MATRA &A, MATRB &B, ARluSy
     }
 
     for (i=0; i<nconv; i++) {
-      cout << "||A*x(" << i << ") - lambda(" << i;
-      cout << ")*B*x(" << i << ")||: " << ResNorm[i] << "\n";
+      std::cout << "||A*x(" << i << ") - lambda(" << i;
+      std::cout << ")*B*x(" << i << ")||: " << ResNorm[i] << "\n";
     }
-    cout << "\n";
+    std::cout << "\n";
 
     delete[] Ax;
     delete[] Bx;
diff -rupN arpack++1.2.orig/examples/product/complex/compgsol.h arpack++1.2.patched/examples/product/complex/compgsol.h
--- arpack++1.2.orig/examples/product/complex/compgsol.h	2000-02-21 20:52:13.000000000 +0100
+++ arpack++1.2.patched/examples/product/complex/compgsol.h	2006-01-26 15:37:47.000000000 +0100
@@ -19,7 +19,7 @@
 #define COMPGSOL_H
 
 #include "arcomp.h"
-#include <math.h>
+#include <cmath>
 #include "blas1c.h"
 #include "lapackc.h"
 #include "matprod.h"
@@ -29,7 +29,7 @@ template<class MATRA, class MATRB, class
 void Solution(MATRA &A, MATRB &B, ARCompGenEig<ARFLOAT, ARFOP, ARFB> &Prob)
 /*
   Prints eigenvalues and eigenvectors of complex generalized
-  eigen-problems on standard "cout" stream.
+  eigen-problems on standard "std::cout" stream.
 */
 
 {
@@ -43,32 +43,32 @@ void Solution(MATRA &A, MATRB &B, ARComp
   nconv = Prob.ConvergedEigenvalues();
   mode  = Prob.GetMode();
 
-  cout << endl << endl << "Testing ARPACK++ class ARCompGenEig" << endl;
-  cout << "Complex generalized eigenvalue problem: A*x - lambda*B*x" << endl;
+  std::cout << std::endl << std::endl << "Testing ARPACK++ class ARCompGenEig" << std::endl;
+  std::cout << "Complex generalized eigenvalue problem: A*x - lambda*B*x" << std::endl;
   switch (mode) {
   case 2:
-    cout << "Regular mode" << endl << endl;
+    std::cout << "Regular mode" << std::endl << std::endl;
     break;
   case 3:
-    cout << "Shift and invert mode" << endl << endl;
+    std::cout << "Shift and invert mode" << std::endl << std::endl;
   }
 
-  cout << "Dimension of the system            : " << n              << endl;
-  cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
-  cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
-  cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
-  cout << endl;
+  std::cout << "Dimension of the system            : " << n              << std::endl;
+  std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
+  std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
+  std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
+  std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
+  std::cout << std::endl;
 
   if (Prob.EigenvaluesFound()) {
 
     // Printing eigenvalues.
 
-    cout << "Eigenvalues:" << endl;
+    std::cout << "Eigenvalues:" << std::endl;
     for (i=0; i<nconv; i++) {
-      cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
+      std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
   }
 
   if (Prob.EigenvectorsFound()) {
@@ -89,10 +89,10 @@ void Solution(MATRA &A, MATRB &B, ARComp
     }
 
     for (i=0; i<nconv; i++) {
-      cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
-      cout << ")*B*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
+      std::cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
+      std::cout << ")*B*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
     }
-    cout << endl;
+    std::cout << std::endl;
 
     delete[] Ax;
     delete[] Bx;
diff -rupN arpack++1.2.orig/examples/product/complex/compsol.h arpack++1.2.patched/examples/product/complex/compsol.h
--- arpack++1.2.orig/examples/product/complex/compsol.h	2000-02-21 20:51:37.000000000 +0100
+++ arpack++1.2.patched/examples/product/complex/compsol.h	2006-01-26 15:37:47.000000000 +0100
@@ -19,7 +19,7 @@
 #define COMPSOL_H
 
 #include "arcomp.h"
-#include <math.h>
+#include <cmath>
 #include "blas1c.h"
 #include "lapackc.h"
 #include "matprod.h"
@@ -29,7 +29,7 @@ template<class ARMATRIX, class ARFLOAT>
 void Solution(ARMATRIX &A, ARCompStdEig<ARFLOAT, ARMATRIX> &Prob)
 /*
   Prints eigenvalues and eigenvectors of complex eigen-problems
-  on standard "cout" stream.
+  on standard "std::cout" stream.
 */
 
 {
@@ -42,32 +42,32 @@ void Solution(ARMATRIX &A, ARCompStdEig<
   nconv = Prob.ConvergedEigenvalues();
   mode  = Prob.GetMode();
 
-  cout << endl << endl << "Testing ARPACK++ class ARCompStdEig \n";
-  cout << "Complex eigenvalue problem: A*x - lambda*x" << endl;
+  std::cout << std::endl << std::endl << "Testing ARPACK++ class ARCompStdEig \n";
+  std::cout << "Complex eigenvalue problem: A*x - lambda*x" << std::endl;
   switch (mode) {
   case 1:
-    cout << "Regular mode" << endl << endl;
+    std::cout << "Regular mode" << std::endl << std::endl;
     break;
   case 3:
-    cout << "Shift and invert mode" << endl << endl;
+    std::cout << "Shift and invert mode" << std::endl << std::endl;
   }
 
-  cout << "Dimension of the system            : " << n              << endl;
-  cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
-  cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
-  cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
-  cout << endl;
+  std::cout << "Dimension of the system            : " << n              << std::endl;
+  std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
+  std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
+  std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
+  std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
+  std::cout << std::endl;
 
   if (Prob.EigenvaluesFound()) {
 
     // Printing eigenvalues.
 
-    cout << "Eigenvalues:" << endl;
+    std::cout << "Eigenvalues:" << std::endl;
     for (i=0; i<nconv; i++) {
-      cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
+      std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
   }
 
   if (Prob.EigenvectorsFound()) {
@@ -86,10 +86,10 @@ void Solution(ARMATRIX &A, ARCompStdEig<
     }
 
     for (i=0; i<nconv; i++) {
-      cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
-      cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << endl;
+      std::cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
+      std::cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << std::endl;
     }
-    cout << "\n";
+    std::cout << "\n";
 
     delete[] Ax;
     delete[] ResNorm;
diff -rupN arpack++1.2.orig/examples/product/complex/Makefile arpack++1.2.patched/examples/product/complex/Makefile
--- arpack++1.2.orig/examples/product/complex/Makefile	2000-02-18 20:11:19.000000000 +0100
+++ arpack++1.2.patched/examples/product/complex/Makefile	2006-01-26 15:37:47.000000000 +0100
@@ -33,7 +33,7 @@ compgshf:       compgshf.o
 
 .PHONY:	clean
 clean:
-	rm -f *~ *.o core
+	rm -f *~ *.o core compgreg compgshf compreg compshf
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/examples/product/nonsym/Makefile arpack++1.2.patched/examples/product/nonsym/Makefile
--- arpack++1.2.orig/examples/product/nonsym/Makefile	2000-02-18 20:02:44.000000000 +0100
+++ arpack++1.2.patched/examples/product/nonsym/Makefile	2006-01-26 15:37:47.000000000 +0100
@@ -44,7 +44,7 @@ svd:	svd.o
 
 .PHONY:	clean
 clean:
-	rm -f *~ *.o core
+	rm -f *~ *.o core nsymgreg nsymgsci nsymgscr nsymgshf nsymreg nsymshf svd
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/examples/product/nonsym/nsymgsol.h arpack++1.2.patched/examples/product/nonsym/nsymgsol.h
--- arpack++1.2.orig/examples/product/nonsym/nsymgsol.h	2000-02-21 20:46:05.000000000 +0100
+++ arpack++1.2.patched/examples/product/nonsym/nsymgsol.h	2006-01-26 15:37:47.000000000 +0100
@@ -18,7 +18,7 @@
 #ifndef NSYMGSOL_H
 #define NSYMGSOL_H
 
-#include <math.h>
+#include <cmath>
 #include "blas1c.h"
 #include "lapackc.h"
 #include "matprod.h"
@@ -28,7 +28,7 @@ template<class MATRA, class MATRB, class
 void Solution(MATRA &A, MATRB &B, ARNonSymGenEig<ARFLOAT, ARFOP, ARFB> &Prob)
 /*
   Prints eigenvalues and eigenvectors of nonsymmetric generalized
-  eigen-problems on standard "cout" stream.
+  eigen-problems on standard "std::cout" stream.
 */
 
 {
@@ -42,43 +42,43 @@ void Solution(MATRA &A, MATRB &B, ARNonS
   nconv = Prob.ConvergedEigenvalues();
   mode  = Prob.GetMode();
 
-  cout << endl << endl << "Testing ARPACK++ class ARNonSymGenEig" << endl;
-  cout << "Real nonsymmetric generalized eigenvalue problem: A*x - lambda*B*x";
-  cout << endl;
+  std::cout << std::endl << std::endl << "Testing ARPACK++ class ARNonSymGenEig" << std::endl;
+  std::cout << "Real nonsymmetric generalized eigenvalue problem: A*x - lambda*B*x";
+  std::cout << std::endl;
   switch (mode) {
   case 2:
-    cout << "Regular mode" << endl;
+    std::cout << "Regular mode" << std::endl;
     break;
   case 3:
-    cout << "Shift and invert mode (using real part of OP)" << endl;
+    std::cout << "Shift and invert mode (using real part of OP)" << std::endl;
     break;
   case 4:
-    cout << "Shift and invert mode (using imaginary part of OP)" << endl;
+    std::cout << "Shift and invert mode (using imaginary part of OP)" << std::endl;
   }
-  cout << endl;
+  std::cout << std::endl;
 
-  cout << "Dimension of the system            : " << n              << endl;
-  cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
-  cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
-  cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
-  cout << endl;
+  std::cout << "Dimension of the system            : " << n              << std::endl;
+  std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
+  std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
+  std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
+  std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
+  std::cout << std::endl;
 
   if (Prob.EigenvaluesFound()) {
 
     // Eigenvalues.
 
-    cout << "Eigenvalues:" << endl;
+    std::cout << "Eigenvalues:" << std::endl;
     for (i=0; i<nconv; i++) {
-      cout << "  lambda[" << (i+1) << "]: " << Prob.EigenvalueReal(i);
+      std::cout << "  lambda[" << (i+1) << "]: " << Prob.EigenvalueReal(i);
       if (Prob.EigenvalueImag(i)>=0.0) {
-        cout << " + " << Prob.EigenvalueImag(i) << " I" << endl;
+        std::cout << " + " << Prob.EigenvalueImag(i) << " I" << std::endl;
       }
       else {
-        cout << " - " << fabs(Prob.EigenvalueImag(i)) << " I" << endl;
+        std::cout << " - " << fabs(Prob.EigenvalueImag(i)) << " I" << std::endl;
       }
     }
-    cout << endl;
+    std::cout << std::endl;
   }
 
   if (Prob.EigenvectorsFound()) {
@@ -121,10 +121,10 @@ void Solution(MATRA &A, MATRB &B, ARNonS
     }
 
     for (i=0; i<nconv; i++) {
-      cout << "||A*x(" << i << ") - lambda(" << i;
-      cout << ")*B*x(" << i << ")||: " << ResNorm[i] << "\n";
+      std::cout << "||A*x(" << i << ") - lambda(" << i;
+      std::cout << ")*B*x(" << i << ")||: " << ResNorm[i] << "\n";
     }
-    cout << "\n";
+    std::cout << "\n";
 
     delete[] Ax;
     delete[] Bx;
diff -rupN arpack++1.2.orig/examples/product/nonsym/nsymsol.h arpack++1.2.patched/examples/product/nonsym/nsymsol.h
--- arpack++1.2.orig/examples/product/nonsym/nsymsol.h	2000-02-21 20:46:37.000000000 +0100
+++ arpack++1.2.patched/examples/product/nonsym/nsymsol.h	2006-01-26 15:37:47.000000000 +0100
@@ -18,7 +18,7 @@
 #ifndef NSYMSOL_H
 #define NSYMSOL_H
 
-#include <math.h>
+#include <cmath>
 #include "blas1c.h"
 #include "lapackc.h"
 #include "matprod.h"
@@ -28,7 +28,7 @@ template<class ARMATRIX, class ARFLOAT>
 void Solution(ARMATRIX &A, ARNonSymStdEig<ARFLOAT, ARMATRIX> &Prob)
 /*
   Prints eigenvalues and eigenvectors of nonsymmetric eigen-problems
-  on standard "cout" stream.
+  on standard "std::cout" stream.
 */
 
 {
@@ -41,38 +41,38 @@ void Solution(ARMATRIX &A, ARNonSymStdEi
   nconv = Prob.ConvergedEigenvalues();
   mode  = Prob.GetMode();
 
-  cout << endl << endl << "Testing ARPACK++ class ARNonSymStdEig \n";
-  cout << "Real nonsymmetric eigenvalue problem: A*x - lambda*x" << endl;
+  std::cout << std::endl << std::endl << "Testing ARPACK++ class ARNonSymStdEig \n";
+  std::cout << "Real nonsymmetric eigenvalue problem: A*x - lambda*x" << std::endl;
   switch (mode) {
   case 1:
-    cout << "Regular mode" << endl << endl;
+    std::cout << "Regular mode" << std::endl << std::endl;
     break;
   case 3:
-    cout << "Shift and invert mode" << endl << endl;
+    std::cout << "Shift and invert mode" << std::endl << std::endl;
   }
 
-  cout << "Dimension of the system            : " << n             << endl;
-  cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev() << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv         << endl;
-  cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv() << endl;
-  cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
-  cout << endl;
+  std::cout << "Dimension of the system            : " << n             << std::endl;
+  std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev() << std::endl;
+  std::cout << "Number of 'converged' eigenvalues  : " << nconv         << std::endl;
+  std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv() << std::endl;
+  std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
+  std::cout << std::endl;
 
   if (Prob.EigenvaluesFound()) {
 
     // Printing eigenvalues.
 
-    cout << "Eigenvalues:" << endl;
+    std::cout << "Eigenvalues:" << std::endl;
     for (i=0; i<nconv; i++) {
-      cout << "  lambda[" << (i+1) << "]: " << Prob.EigenvalueReal(i);
+      std::cout << "  lambda[" << (i+1) << "]: " << Prob.EigenvalueReal(i);
       if (Prob.EigenvalueImag(i)>=0.0) {
-        cout << " + " << Prob.EigenvalueImag(i) << " I" << endl;
+        std::cout << " + " << Prob.EigenvalueImag(i) << " I" << std::endl;
       }
       else {
-        cout << " - " << fabs(Prob.EigenvalueImag(i)) << " I" << endl;
+        std::cout << " - " << fabs(Prob.EigenvalueImag(i)) << " I" << std::endl;
       }
     }
-    cout << endl;
+    std::cout << std::endl;
   }
 
   if (Prob.EigenvectorsFound()) {
@@ -110,10 +110,10 @@ void Solution(ARMATRIX &A, ARNonSymStdEi
     }
 
     for (i=0; i<nconv; i++) {
-      cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
-      cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
+      std::cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
+      std::cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
     }
-    cout << "\n";
+    std::cout << "\n";
 
     delete[] Ax;
     delete[] ResNorm;
diff -rupN arpack++1.2.orig/examples/product/nonsym/nsymvsol.h arpack++1.2.patched/examples/product/nonsym/nsymvsol.h
--- arpack++1.2.orig/examples/product/nonsym/nsymvsol.h	2000-02-21 20:45:21.000000000 +0100
+++ arpack++1.2.patched/examples/product/nonsym/nsymvsol.h	2006-01-26 15:37:47.000000000 +0100
@@ -19,7 +19,7 @@
 #ifndef NSYMVSOL_H
 #define NSYMVSOL_H
 
-#include <math.h>
+#include <cmath>
 #include "blas1c.h"
 #include "lapackc.h"
 #include "matprod.h"
@@ -29,7 +29,7 @@ template<class ARMATRIX, class ARFLOAT>
 void Solution(ARMATRIX &A, ARNonSymStdEig<ARFLOAT, ARMATRIX> &Prob)
 /*
   Prints singular values and singular vectors of nonsymmetric 
-  real matrices on standard "cout" stream.
+  real matrices on standard "std::cout" stream.
 */
 
 {
@@ -44,15 +44,15 @@ void Solution(ARMATRIX &A, ARNonSymStdEi
   m     = A.nrows();
   nconv = Prob.ConvergedEigenvalues();
 
-  cout << endl << endl << "Testing ARPACK++ class ARNonSymStdEig \n";
-  cout << "Singular value decomposition problem: (A'*A)*x - lambda*x" << endl;
+  std::cout << std::endl << std::endl << "Testing ARPACK++ class ARNonSymStdEig \n";
+  std::cout << "Singular value decomposition problem: (A'*A)*x - lambda*x" << std::endl;
 
-  cout << "Dimension of the system              : " << n             << endl;
-  cout << "Number of 'requested' singular values: " << Prob.GetNev() << endl;
-  cout << "Number of 'converged' singular values: " << nconv         << endl;
-  cout << "Number of Arnoldi vectors generated  : " << Prob.GetNcv() << endl;
-  cout << "Number of iterations taken           : " << Prob.GetIter() << endl;
-  cout << endl;
+  std::cout << "Dimension of the system              : " << n             << std::endl;
+  std::cout << "Number of 'requested' singular values: " << Prob.GetNev() << std::endl;
+  std::cout << "Number of 'converged' singular values: " << nconv         << std::endl;
+  std::cout << "Number of Arnoldi vectors generated  : " << Prob.GetNcv() << std::endl;
+  std::cout << "Number of iterations taken           : " << Prob.GetIter() << std::endl;
+  std::cout << std::endl;
 
   value = new ARFLOAT[nconv];
   Ax    = new ARFLOAT[m];
@@ -62,12 +62,12 @@ void Solution(ARMATRIX &A, ARNonSymStdEi
 
     // Printing singular values.
 
-    cout << "Singular values:" << endl;
+    std::cout << "Singular values:" << std::endl;
     for (i=0; i<nconv; i++) {
       value[i] = sqrt(Prob.EigenvalueReal(i));
-      cout << "  sigma[" << (i+1) << "]: " << value[i] << endl;
+      std::cout << "  sigma[" << (i+1) << "]: " << value[i] << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
   }
 
   if (Prob.EigenvectorsFound()) {
@@ -91,8 +91,8 @@ void Solution(ARMATRIX &A, ARNonSymStdEi
 
       // Printing the norm.
 
-      cout << "||A*v(" << (i+1) << ") - sigma(" << (i+1);
-      cout << ")*u(" << (i+1) << ")||: " << ResNorm << endl;
+      std::cout << "||A*v(" << (i+1) << ") - sigma(" << (i+1);
+      std::cout << ")*u(" << (i+1) << ")||: " << ResNorm << std::endl;
     }
 
   }
diff -rupN arpack++1.2.orig/examples/product/simple/Makefile arpack++1.2.patched/examples/product/simple/Makefile
--- arpack++1.2.orig/examples/product/simple/Makefile	2000-02-18 19:43:27.000000000 +0100
+++ arpack++1.2.patched/examples/product/simple/Makefile	2006-01-26 15:37:47.000000000 +0100
@@ -19,7 +19,7 @@ symsimp: 	symsimp.o
 
 .PHONY:	clean
 clean:
-	rm -f *~ *.o core
+	rm -f *~ *.o core symsimp
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/examples/product/simple/symsimp.cc arpack++1.2.patched/examples/product/simple/symsimp.cc
--- arpack++1.2.orig/examples/product/simple/symsimp.cc	2000-02-18 19:43:13.000000000 +0100
+++ arpack++1.2.patched/examples/product/simple/symsimp.cc	2006-01-26 15:37:47.000000000 +0100
@@ -96,7 +96,7 @@ class SymMatrix {
 template<class FLOAT, class EIGPROB>
 void Solution(SymMatrix<FLOAT> &A, EIGPROB &Prob)
 /*
-  This function prints eigenvalues and eigenvetors on standard "cout" 
+  This function prints eigenvalues and eigenvetors on standard "std::cout" 
   stream and exemplifies how to retrieve information from ARPACK++ classes.
 */
 
@@ -119,21 +119,21 @@ void Solution(SymMatrix<FLOAT> &A, EIGPR
   nconv = Prob.ConvergedEigenvalues();
   mode  = Prob.GetMode();
 
-  cout << endl << endl << "Testing ARPACK++ class ARSymEig \n";
-  cout << "Real symmetric eigenvalue problem: A*x - lambda*x" << endl;
+  std::cout << std::endl << std::endl << "Testing ARPACK++ class ARSymEig \n";
+  std::cout << "Real symmetric eigenvalue problem: A*x - lambda*x" << std::endl;
   switch (mode) {
   case 1:
-    cout << "Regular mode" << endl << endl;
+    std::cout << "Regular mode" << std::endl << std::endl;
     break;
   case 3: 
-    cout << "Shift and invert mode" << endl << endl;
+    std::cout << "Shift and invert mode" << std::endl << std::endl;
   }
 
-  cout << "Dimension of the system            : " << n             << endl;
-  cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev() << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv         << endl;
-  cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv() << endl;
-  cout << endl;
+  std::cout << "Dimension of the system            : " << n             << std::endl;
+  std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev() << std::endl;
+  std::cout << "Number of 'converged' eigenvalues  : " << nconv         << std::endl;
+  std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv() << std::endl;
+  std::cout << std::endl;
 
   /*
     EigenvaluesFound is a boolean function that indicates
@@ -144,11 +144,11 @@ void Solution(SymMatrix<FLOAT> &A, EIGPR
   */
 
   if (Prob.EigenvaluesFound()) {
-    cout << "Eigenvalues:" << endl;
+    std::cout << "Eigenvalues:" << std::endl;
     for (i=0; i<nconv; i++) {
-      cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
+      std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
   }
 
   /*
@@ -174,10 +174,10 @@ void Solution(SymMatrix<FLOAT> &A, EIGPR
     }
 
     for (i=0; i<nconv; i++) {
-      cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
-      cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
+      std::cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
+      std::cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
     }
-    cout << "\n";
+    std::cout << "\n";
 
     delete[] Ax;
     delete[] ResNorm;
diff -rupN arpack++1.2.orig/examples/product/sym/Makefile arpack++1.2.patched/examples/product/sym/Makefile
--- arpack++1.2.orig/examples/product/sym/Makefile	2000-02-18 19:55:22.000000000 +0100
+++ arpack++1.2.patched/examples/product/sym/Makefile	2006-01-26 15:37:47.000000000 +0100
@@ -39,7 +39,7 @@ symgcayl:	symgcayl.o
 
 .PHONY:	clean
 clean:
-	rm -f *~ *.o core
+	rm -f *~ *.o core symgbklg symgcayl symgreg symgshft symreg symshft
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/examples/product/sym/symgsol.h arpack++1.2.patched/examples/product/sym/symgsol.h
--- arpack++1.2.orig/examples/product/sym/symgsol.h	2000-02-21 20:40:51.000000000 +0100
+++ arpack++1.2.patched/examples/product/sym/symgsol.h	2006-01-26 15:37:47.000000000 +0100
@@ -18,7 +18,7 @@
 #ifndef SYMGSOL_H
 #define SYMGSOL_H
 
-#include <math.h>
+#include <cmath>
 #include "blas1c.h"
 #include "argsym.h"
 
@@ -26,7 +26,7 @@ template<class MATRA, class MATRB, class
 void Solution(MATRA &A, MATRB &B, ARSymGenEig<ARFLOAT, ARFOP, ARFB> &Prob)
 /*
   Prints eigenvalues and eigenvectors of symmetric generalized
-  eigen-problems on standard "cout" stream.
+  eigen-problems on standard "std::cout" stream.
 */
 
 {
@@ -39,39 +39,39 @@ void Solution(MATRA &A, MATRB &B, ARSymG
   nconv = Prob.ConvergedEigenvalues();
   mode  = Prob.GetMode();
 
-  cout << endl << endl << "Testing ARPACK++ class ARSymGenEig \n";
-  cout << "Real symmetric generalized eigenvalue problem: A*x - lambda*B*x";
-  cout << endl;
+  std::cout << std::endl << std::endl << "Testing ARPACK++ class ARSymGenEig \n";
+  std::cout << "Real symmetric generalized eigenvalue problem: A*x - lambda*B*x";
+  std::cout << std::endl;
   switch (mode) {
   case 2:
-    cout << "Regular mode" << endl << endl;
+    std::cout << "Regular mode" << std::endl << std::endl;
     break;
   case 3:
-    cout << "Shift and invert mode" << endl << endl;
+    std::cout << "Shift and invert mode" << std::endl << std::endl;
     break;
   case 4:
-    cout << "Buckling mode" << endl << endl;
+    std::cout << "Buckling mode" << std::endl << std::endl;
     break;
   case 5:
-    cout << "Cayley mode" << endl << endl;
+    std::cout << "Cayley mode" << std::endl << std::endl;
   }
 
-  cout << "Dimension of the system            : " << n              << endl;
-  cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
-  cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
-  cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
-  cout << endl;
+  std::cout << "Dimension of the system            : " << n              << std::endl;
+  std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
+  std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
+  std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
+  std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
+  std::cout << std::endl;
 
   if (Prob.EigenvaluesFound()) {
 
     // Printing eigenvalues.
 
-    cout << "Eigenvalues:" << endl;
+    std::cout << "Eigenvalues:" << std::endl;
     for (i=0; i<nconv; i++) {
-      cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
+      std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
   }
 
   if (Prob.EigenvectorsFound()) {
@@ -91,10 +91,10 @@ void Solution(MATRA &A, MATRB &B, ARSymG
     }
 
     for (i=0; i<nconv; i++) {
-      cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
-      cout << ")*B*x(" << (i+1) << ")||: " << ResNorm[i] << endl;
+      std::cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
+      std::cout << ")*B*x(" << (i+1) << ")||: " << ResNorm[i] << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
 
     delete[] Ax;
     delete[] Bx;
diff -rupN arpack++1.2.orig/examples/product/sym/symsol.h arpack++1.2.patched/examples/product/sym/symsol.h
--- arpack++1.2.orig/examples/product/sym/symsol.h	2000-02-21 20:41:31.000000000 +0100
+++ arpack++1.2.patched/examples/product/sym/symsol.h	2006-01-26 15:37:47.000000000 +0100
@@ -18,7 +18,7 @@
 #ifndef SYMSOL_H
 #define SYMSOL_H
 
-#include <math.h>
+#include <cmath>
 #include "blas1c.h"
 #include "matprod.h"
 #include "arssym.h"
@@ -27,7 +27,7 @@ template<class ARMATRIX, class ARFLOAT>
 void Solution(ARMATRIX &A, ARSymStdEig<ARFLOAT, ARMATRIX> &Prob)
 /*
   Prints eigenvalues and eigenvectors of symmetric eigen-problems
-  on standard "cout" stream.
+  on standard "std::cout" stream.
 */
 
 {
@@ -40,32 +40,32 @@ void Solution(ARMATRIX &A, ARSymStdEig<A
   nconv = Prob.ConvergedEigenvalues();
   mode  = Prob.GetMode();
 
-  cout << endl << endl << "Testing ARPACK++ class ARSymStdEig \n";
-  cout << "Real symmetric eigenvalue problem: A*x - lambda*x" << endl;
+  std::cout << std::endl << std::endl << "Testing ARPACK++ class ARSymStdEig \n";
+  std::cout << "Real symmetric eigenvalue problem: A*x - lambda*x" << std::endl;
   switch (mode) {
   case 1:
-    cout << "Regular mode" << endl << endl;
+    std::cout << "Regular mode" << std::endl << std::endl;
     break;
   case 3: 
-    cout << "Shift and invert mode" << endl << endl;
+    std::cout << "Shift and invert mode" << std::endl << std::endl;
   }
 
-  cout << "Dimension of the system            : " << n              << endl;
-  cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
-  cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
-  cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
-  cout << endl;
+  std::cout << "Dimension of the system            : " << n              << std::endl;
+  std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
+  std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
+  std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
+  std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
+  std::cout << std::endl;
 
   if (Prob.EigenvaluesFound()) {
 
     // Printing eigenvalues.
 
-    cout << "Eigenvalues:" << endl;
+    std::cout << "Eigenvalues:" << std::endl;
     for (i=0; i<nconv; i++) {
-      cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
+      std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
   }
 
   if (Prob.EigenvectorsFound()) {
@@ -83,10 +83,10 @@ void Solution(ARMATRIX &A, ARSymStdEig<A
     }
 
     for (i=0; i<nconv; i++) {
-      cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
-      cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
+      std::cout << "||A*x(" << (i+1) << ") - lambda(" << (i+1);
+      std::cout << ")*x(" << (i+1) << ")||: " << ResNorm[i] << "\n";
     }
-    cout << "\n";
+    std::cout << "\n";
 
     delete[] Ax;
     delete[] ResNorm;
diff -rupN arpack++1.2.orig/examples/reverse/complex/Makefile arpack++1.2.patched/examples/reverse/complex/Makefile
--- arpack++1.2.orig/examples/reverse/complex/Makefile	2000-02-18 20:16:37.000000000 +0100
+++ arpack++1.2.patched/examples/reverse/complex/Makefile	2006-01-26 15:37:46.000000000 +0100
@@ -37,7 +37,7 @@ rcompgsh:       rcompgsh.o
 
 .PHONY:	clean
 clean:
-	rm -f *.o *~ core
+	rm -f *.o *~ core rcompreg rcompshf rcompgre rcompgsh
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/examples/reverse/complex/rcompgsl.h arpack++1.2.patched/examples/reverse/complex/rcompgsl.h
--- arpack++1.2.orig/examples/reverse/complex/rcompgsl.h	2000-02-22 14:34:53.000000000 +0100
+++ arpack++1.2.patched/examples/reverse/complex/rcompgsl.h	2006-01-26 15:37:46.000000000 +0100
@@ -23,7 +23,7 @@
 template<class ARFLOAT>
 void Solution(ARrcCompGenEig<ARFLOAT> &Prob)
 /*
-  Prints eigenvalues on standard "cout" stream.
+  Prints eigenvalues on standard "std::cout" stream.
 */
 
 {
@@ -34,30 +34,30 @@ void Solution(ARrcCompGenEig<ARFLOAT> &P
   nconv = Prob.ConvergedEigenvalues();
   mode  = Prob.GetMode();
 
-  cout << endl << endl << "Testing ARPACK++ class ARrcCompGenEig" << endl;
-  cout << "Complex eigenvalue problem: A*x - B*x*lambda" << endl;
+  std::cout << std::endl << std::endl << "Testing ARPACK++ class ARrcCompGenEig" << std::endl;
+  std::cout << "Complex eigenvalue problem: A*x - B*x*lambda" << std::endl;
   switch (mode) {
   case 2:
-    cout << "Regular mode";
+    std::cout << "Regular mode";
     break;
   case 3:
-    cout << "Shift and invert mode";
+    std::cout << "Shift and invert mode";
   }
-  cout << endl << endl;
+  std::cout << std::endl << std::endl;
 
-  cout << "Dimension of the system            : " << n              << endl;
-  cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
-  cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
-  cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
-  cout << endl;
+  std::cout << "Dimension of the system            : " << n              << std::endl;
+  std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
+  std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
+  std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
+  std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
+  std::cout << std::endl;
 
   if (Prob.EigenvaluesFound()) {
-    cout << "Eigenvalues:" << endl;
+    std::cout << "Eigenvalues:" << std::endl;
     for (i=0; i<nconv; i++) {
-      cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
+      std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
   }
 
 } // Solution
diff -rupN arpack++1.2.orig/examples/reverse/complex/rcompsol.h arpack++1.2.patched/examples/reverse/complex/rcompsol.h
--- arpack++1.2.orig/examples/reverse/complex/rcompsol.h	2000-02-22 14:34:31.000000000 +0100
+++ arpack++1.2.patched/examples/reverse/complex/rcompsol.h	2006-01-26 15:37:46.000000000 +0100
@@ -23,7 +23,7 @@
 template<class ARFLOAT>
 void Solution(ARrcCompStdEig<ARFLOAT> &Prob)
 /*
-  Prints eigenvalues on standard "cout" stream.
+  Prints eigenvalues on standard "std::cout" stream.
 */
 
 {
@@ -34,29 +34,29 @@ void Solution(ARrcCompStdEig<ARFLOAT> &P
   nconv = Prob.ConvergedEigenvalues();
   mode  = Prob.GetMode();
 
-  cout << endl << endl << "Testing ARPACK++ class ARrcCompStdEig " << endl;
-  cout << "Complex eigenvalue problem: A*x - lambda*x" << endl;
+  std::cout << std::endl << std::endl << "Testing ARPACK++ class ARrcCompStdEig " << std::endl;
+  std::cout << "Complex eigenvalue problem: A*x - lambda*x" << std::endl;
   switch (mode) {
   case 1:
-    cout << "Regular mode" << endl << endl;
+    std::cout << "Regular mode" << std::endl << std::endl;
     break;
   case 3:
-    cout << "Shift and invert mode" << endl << endl;
+    std::cout << "Shift and invert mode" << std::endl << std::endl;
   }
 
-  cout << "Dimension of the system            : " << n              << endl;
-  cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
-  cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
-  cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
-  cout << endl;
+  std::cout << "Dimension of the system            : " << n              << std::endl;
+  std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
+  std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
+  std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
+  std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
+  std::cout << std::endl;
 
   if (Prob.EigenvaluesFound()) {
-    cout << "Eigenvalues:" << endl;
+    std::cout << "Eigenvalues:" << std::endl;
     for (i=0; i<nconv; i++) {
-      cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
+      std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
   }
 
 } // Solution
diff -rupN arpack++1.2.orig/examples/reverse/nonsym/Makefile arpack++1.2.patched/examples/reverse/nonsym/Makefile
--- arpack++1.2.orig/examples/reverse/nonsym/Makefile	2000-02-18 20:30:14.000000000 +0100
+++ arpack++1.2.patched/examples/reverse/nonsym/Makefile	2006-01-26 15:37:46.000000000 +0100
@@ -46,7 +46,7 @@ rsvd:	rsvd.o
 
 .PHONY:	clean
 clean:
-	rm -f *.o *~ core
+	rm -f *.o *~ core rnsymreg rnsymshf rnsymgre rnsymgsh rnsymgsc rsvd
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/examples/reverse/nonsym/rnsymgsl.h arpack++1.2.patched/examples/reverse/nonsym/rnsymgsl.h
--- arpack++1.2.orig/examples/reverse/nonsym/rnsymgsl.h	2000-02-22 14:42:34.000000000 +0100
+++ arpack++1.2.patched/examples/reverse/nonsym/rnsymgsl.h	2006-01-26 15:37:46.000000000 +0100
@@ -23,7 +23,7 @@
 template<class ARFLOAT>
 void Solution(ARrcNonSymGenEig<ARFLOAT> &Prob)
 /*
-  Prints eigenvalues on standard "cout" stream.
+  Prints eigenvalues on standard "std::cout" stream.
 */
 
 {
@@ -34,33 +34,33 @@ void Solution(ARrcNonSymGenEig<ARFLOAT> 
   nconv = Prob.ConvergedEigenvalues();
   mode  = Prob.GetMode();
 
-  cout << endl << endl << "Testing ARPACK++ class ARrcNonSymGenEig" << endl;
-  cout << "Real nonsymmetric generalized eigenvalue problem: A*x - B*x*lambda" << endl;
+  std::cout << std::endl << std::endl << "Testing ARPACK++ class ARrcNonSymGenEig" << std::endl;
+  std::cout << "Real nonsymmetric generalized eigenvalue problem: A*x - B*x*lambda" << std::endl;
   switch (mode) {
   case 2:
-    cout << "Regular mode";
+    std::cout << "Regular mode";
     break;
   case 3:
-    cout << "Shift and invert mode (using real part of OP)";
+    std::cout << "Shift and invert mode (using real part of OP)";
     break;
   case 4:
-    cout << "Shift and invert mode (using imaginary part of OP)";
+    std::cout << "Shift and invert mode (using imaginary part of OP)";
   }
-  cout << endl << endl;
+  std::cout << std::endl << std::endl;
 
-  cout << "Dimension of the system            : " << n              << endl;
-  cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
-  cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
-  cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
-  cout << endl;
+  std::cout << "Dimension of the system            : " << n              << std::endl;
+  std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
+  std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
+  std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
+  std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
+  std::cout << std::endl;
 
   if (Prob.EigenvaluesFound()) {
-    cout << "Eigenvalues:" << endl;
+    std::cout << "Eigenvalues:" << std::endl;
     for (i=0; i<nconv; i++) {
-      cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
+      std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
   }
 
 } // Solution
diff -rupN arpack++1.2.orig/examples/reverse/nonsym/rnsymsol.h arpack++1.2.patched/examples/reverse/nonsym/rnsymsol.h
--- arpack++1.2.orig/examples/reverse/nonsym/rnsymsol.h	2000-02-22 14:42:06.000000000 +0100
+++ arpack++1.2.patched/examples/reverse/nonsym/rnsymsol.h	2006-01-26 15:37:46.000000000 +0100
@@ -23,7 +23,7 @@
 template<class ARFLOAT>
 void Solution(ARrcNonSymStdEig<ARFLOAT> &Prob)
 /*
-  Prints eigenvalues on standard "cout" stream.
+  Prints eigenvalues on standard "std::cout" stream.
 */
 
 {
@@ -34,29 +34,29 @@ void Solution(ARrcNonSymStdEig<ARFLOAT> 
   nconv = Prob.ConvergedEigenvalues();
   mode  = Prob.GetMode();
 
-  cout << endl << endl << "Testing ARPACK++ class ARrcNonSymStdEig " << endl;
-  cout << "Real nonsymmetric eigenvalue problem: A*x - lambda*x" << endl;
+  std::cout << std::endl << std::endl << "Testing ARPACK++ class ARrcNonSymStdEig " << std::endl;
+  std::cout << "Real nonsymmetric eigenvalue problem: A*x - lambda*x" << std::endl;
   switch (mode) {
   case 1:
-    cout << "Regular mode" << endl << endl;
+    std::cout << "Regular mode" << std::endl << std::endl;
     break;
   case 3:
-    cout << "Shift and invert mode" << endl << endl;
+    std::cout << "Shift and invert mode" << std::endl << std::endl;
   }
 
-  cout << "Dimension of the system            : " << n              << endl;
-  cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
-  cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
-  cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
-  cout << endl;
+  std::cout << "Dimension of the system            : " << n              << std::endl;
+  std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
+  std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
+  std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
+  std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
+  std::cout << std::endl;
 
   if (Prob.EigenvaluesFound()) {
-    cout << "Eigenvalues:" << endl;
+    std::cout << "Eigenvalues:" << std::endl;
     for (i=0; i<nconv; i++) {
-      cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
+      std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
   }
 
 } // Solution
diff -rupN arpack++1.2.orig/examples/reverse/nonsym/rnsymvsl.h arpack++1.2.patched/examples/reverse/nonsym/rnsymvsl.h
--- arpack++1.2.orig/examples/reverse/nonsym/rnsymvsl.h	2000-02-22 14:41:49.000000000 +0100
+++ arpack++1.2.patched/examples/reverse/nonsym/rnsymvsl.h	2006-01-26 15:37:46.000000000 +0100
@@ -19,7 +19,7 @@
 #ifndef RNSYMVSL_H
 #define RNSYMVSL_H
 
-#include <math.h>
+#include <cmath>
 #include "blas1c.h"
 #include "lapackc.h"
 #include "matprod.h"
@@ -29,7 +29,7 @@ template<class ARFLOAT>
 void Solution(ARrcNonSymStdEig<ARFLOAT> &Prob)
 /*
   Prints singular values and singular vectors of nonsymmetric 
-  real matrices on standard "cout" stream.
+  real matrices on standard "std::cout" stream.
 */
 
 {
@@ -38,25 +38,25 @@ void Solution(ARrcNonSymStdEig<ARFLOAT> 
 
   nconv = Prob.ConvergedEigenvalues();
 
-  cout << endl << endl << "Testing ARPACK++ class ARrcNonSymStdEig \n";
-  cout << "Singular value decomposition problem: (A'*A)*x - lambda*x" << endl;
+  std::cout << std::endl << std::endl << "Testing ARPACK++ class ARrcNonSymStdEig \n";
+  std::cout << "Singular value decomposition problem: (A'*A)*x - lambda*x" << std::endl;
 
-  cout << "Dimension of the system              : " << Prob.GetN()   << endl;
-  cout << "Number of 'requested' singular values: " << Prob.GetNev() << endl;
-  cout << "Number of 'converged' singular values: " << nconv         << endl;
-  cout << "Number of Arnoldi vectors generated  : " << Prob.GetNcv() << endl;
-  cout << endl;
+  std::cout << "Dimension of the system              : " << Prob.GetN()   << std::endl;
+  std::cout << "Number of 'requested' singular values: " << Prob.GetNev() << std::endl;
+  std::cout << "Number of 'converged' singular values: " << nconv         << std::endl;
+  std::cout << "Number of Arnoldi vectors generated  : " << Prob.GetNcv() << std::endl;
+  std::cout << std::endl;
 
   if (Prob.EigenvaluesFound()) {
 
     // Printing singular values.
 
-    cout << "Singular values:" << endl;
+    std::cout << "Singular values:" << std::endl;
     for (i=0; i<nconv; i++) {
-      cout << "  sigma[" << (i+1) << "]: ";
-      cout << sqrt(Prob.EigenvalueReal(i)) << endl;
+      std::cout << "  sigma[" << (i+1) << "]: ";
+      std::cout << sqrt(Prob.EigenvalueReal(i)) << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
   }
 
 } // Solution
diff -rupN arpack++1.2.orig/examples/reverse/sym/Makefile arpack++1.2.patched/examples/reverse/sym/Makefile
--- arpack++1.2.orig/examples/reverse/sym/Makefile	2000-02-18 20:24:58.000000000 +0100
+++ arpack++1.2.patched/examples/reverse/sym/Makefile	2006-01-26 15:37:46.000000000 +0100
@@ -45,7 +45,7 @@ rsymgcay:       rsymgcay.o
 
 .PHONY:	clean
 clean:
-	rm -f *.o *~ core
+	rm -f *.o *~ core rsymgbkl rsymgcay rsymgreg rsymgshf rsymreg rsymshf
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/examples/reverse/sym/rsymgsol.h arpack++1.2.patched/examples/reverse/sym/rsymgsol.h
--- arpack++1.2.orig/examples/reverse/sym/rsymgsol.h	2000-02-22 14:53:25.000000000 +0100
+++ arpack++1.2.patched/examples/reverse/sym/rsymgsol.h	2006-01-26 15:37:46.000000000 +0100
@@ -23,7 +23,7 @@
 template<class ARFLOAT>
 void Solution(ARrcSymGenEig<ARFLOAT> &Prob)
 /*
-  Prints eigenvalues on standard "cout" stream.
+  Prints eigenvalues on standard "std::cout" stream.
 */
 
 {
@@ -34,35 +34,35 @@ void Solution(ARrcSymGenEig<ARFLOAT> &Pr
   nconv = Prob.ConvergedEigenvalues();
   mode  = Prob.GetMode();
 
-  cout << endl << endl << "Testing ARPACK++ class ARrcSymGenEig" << endl;
-  cout << "Real symmetric eigenvalue problem: A*x - B*x*lambda" << endl;
+  std::cout << std::endl << std::endl << "Testing ARPACK++ class ARrcSymGenEig" << std::endl;
+  std::cout << "Real symmetric eigenvalue problem: A*x - B*x*lambda" << std::endl;
   switch (mode) {
   case 2:
-    cout << "Regular mode" << endl << endl;
+    std::cout << "Regular mode" << std::endl << std::endl;
     break;
   case 3:
-    cout << "Shift and invert mode" << endl << endl;
+    std::cout << "Shift and invert mode" << std::endl << std::endl;
     break;
   case 4:
-    cout << "Buckling mode" << endl << endl;
+    std::cout << "Buckling mode" << std::endl << std::endl;
     break;
   case 5:
-    cout << "Cayley mode" << endl << endl;
+    std::cout << "Cayley mode" << std::endl << std::endl;
   }
 
-  cout << "Dimension of the system            : " << n              << endl;
-  cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
-  cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
-  cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
-  cout << endl;
+  std::cout << "Dimension of the system            : " << n              << std::endl;
+  std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
+  std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
+  std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
+  std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
+  std::cout << std::endl;
 
   if (Prob.EigenvaluesFound()) {
-    cout << "Eigenvalues:" << endl;
+    std::cout << "Eigenvalues:" << std::endl;
     for (i=0; i<nconv; i++) {
-      cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
+      std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
   }
 
 } // Solution
diff -rupN arpack++1.2.orig/examples/reverse/sym/rsymsol.h arpack++1.2.patched/examples/reverse/sym/rsymsol.h
--- arpack++1.2.orig/examples/reverse/sym/rsymsol.h	2000-02-22 14:54:13.000000000 +0100
+++ arpack++1.2.patched/examples/reverse/sym/rsymsol.h	2006-01-26 15:37:46.000000000 +0100
@@ -23,7 +23,7 @@
 template<class ARFLOAT>
 void Solution(ARrcSymStdEig<ARFLOAT> &Prob)
 /*
-  Prints eigenvalues on standard "cout" stream.
+  Prints eigenvalues on standard "std::cout" stream.
 */
 
 {
@@ -34,29 +34,29 @@ void Solution(ARrcSymStdEig<ARFLOAT> &Pr
   nconv = Prob.ConvergedEigenvalues();
   mode  = Prob.GetMode();
 
-  cout << endl << endl << "Testing ARPACK++ class ARrcSymStdEig" << endl;
-  cout << "Real symmetric eigenvalue problem: A*x - lambda*x" << endl;
+  std::cout << std::endl << std::endl << "Testing ARPACK++ class ARrcSymStdEig" << std::endl;
+  std::cout << "Real symmetric eigenvalue problem: A*x - lambda*x" << std::endl;
   switch (mode) {
   case 1:
-    cout << "Regular mode" << endl << endl;
+    std::cout << "Regular mode" << std::endl << std::endl;
     break;
   case 3: 
-    cout << "Shift and invert mode" << endl << endl;
+    std::cout << "Shift and invert mode" << std::endl << std::endl;
   }
 
-  cout << "Dimension of the system            : " << n              << endl;
-  cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << endl;
-  cout << "Number of 'converged' eigenvalues  : " << nconv          << endl;
-  cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << endl;
-  cout << "Number of iterations taken         : " << Prob.GetIter() << endl;
-  cout << endl;
+  std::cout << "Dimension of the system            : " << n              << std::endl;
+  std::cout << "Number of 'requested' eigenvalues  : " << Prob.GetNev()  << std::endl;
+  std::cout << "Number of 'converged' eigenvalues  : " << nconv          << std::endl;
+  std::cout << "Number of Arnoldi vectors generated: " << Prob.GetNcv()  << std::endl;
+  std::cout << "Number of iterations taken         : " << Prob.GetIter() << std::endl;
+  std::cout << std::endl;
 
   if (Prob.EigenvaluesFound()) {
-    cout << "Eigenvalues:" << endl;
+    std::cout << "Eigenvalues:" << std::endl;
     for (i=0; i<nconv; i++) {
-      cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << endl;
+      std::cout << "  lambda[" << (i+1) << "]: " << Prob.Eigenvalue(i) << std::endl;
     }
-    cout << endl;
+    std::cout << std::endl;
   }
 
 } // Solution
diff -rupN arpack++1.2.orig/examples/superlu/complex/Makefile arpack++1.2.patched/examples/superlu/complex/Makefile
--- arpack++1.2.orig/examples/superlu/complex/Makefile	2000-02-22 15:21:50.000000000 +0100
+++ arpack++1.2.patched/examples/superlu/complex/Makefile	2006-01-26 15:37:47.000000000 +0100
@@ -32,7 +32,7 @@ lcompgsh:	lcompgsh.o
 
 .PHONY:	clean
 clean:
-	rm -f *~ *.o core
+	rm -f *~ *.o core lcompreg lcompshf lcompgre lcompgsh
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/examples/superlu/nonsym/lsvd.cc arpack++1.2.patched/examples/superlu/nonsym/lsvd.cc
--- arpack++1.2.orig/examples/superlu/nonsym/lsvd.cc	2000-03-02 18:51:33.000000000 +0100
+++ arpack++1.2.patched/examples/superlu/nonsym/lsvd.cc	2006-01-26 15:37:47.000000000 +0100
@@ -44,7 +44,7 @@
 #include "arssym.h"
 #include "lnmatrxv.h"
 #include "arlnsmat.h"
-#include <math.h>
+#include <cmath>
 
 
 int main()
@@ -94,15 +94,15 @@ int main()
 
   // Printing some information about the problem.
 
-  cout << endl << "Testing ARPACK++ class ARSymStdEig" << endl;
-  cout << "Obtaining singular values by solving (A'*A)*v = sigma*v" << endl;
-  cout << "  greatest singular value: " << svalue[5] << endl;
-  cout << "  smallest singular value: " << svalue[0] << endl;
-  cout << "  condition number of A  : " << cond << endl;
-  cout << "MATLAB solution:" << endl;
-  cout << "  greatest singular value:  9.89757224207690 \n";
-  cout << "  smallest singular value:  1.41683937261247 \n";
-  cout << "  condition number of A  :  6.98566995906319 \n";
+  std::cout << std::endl << "Testing ARPACK++ class ARSymStdEig" << std::endl;
+  std::cout << "Obtaining singular values by solving (A'*A)*v = sigma*v" << std::endl;
+  std::cout << "  greatest singular value: " << svalue[5] << std::endl;
+  std::cout << "  smallest singular value: " << svalue[0] << std::endl;
+  std::cout << "  condition number of A  : " << cond << std::endl;
+  std::cout << "MATLAB solution:" << std::endl;
+  std::cout << "  greatest singular value:  9.89757224207690 \n";
+  std::cout << "  smallest singular value:  1.41683937261247 \n";
+  std::cout << "  condition number of A  :  6.98566995906319 \n";
 
 } // main.
 
diff -rupN arpack++1.2.orig/examples/superlu/nonsym/Makefile arpack++1.2.patched/examples/superlu/nonsym/Makefile
--- arpack++1.2.orig/examples/superlu/nonsym/Makefile	2000-02-22 15:39:02.000000000 +0100
+++ arpack++1.2.patched/examples/superlu/nonsym/Makefile	2006-01-26 15:37:47.000000000 +0100
@@ -43,7 +43,7 @@ lsvd2:	lsvd2.o
 
 .PHONY:	clean
 clean:
-	rm -f *~ *.o core
+	rm -f *~ *.o core lnsymreg lnsymshf lnsymgre lnsymgsh lnsymgsc lsvd lsvd2
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/examples/superlu/sym/Makefile arpack++1.2.patched/examples/superlu/sym/Makefile
--- arpack++1.2.orig/examples/superlu/sym/Makefile	2000-02-22 15:45:12.000000000 +0100
+++ arpack++1.2.patched/examples/superlu/sym/Makefile	2006-01-26 15:37:47.000000000 +0100
@@ -38,7 +38,7 @@ lsymgcay:	lsymgcay.o
 
 .PHONY:	clean
 clean:
-	rm -f *~ *.o core
+	rm -f *~ *.o core lsymgbkl lsymgcay lsymgreg lsymgshf lsymreg lsymshf
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/examples/umfpack/complex/Makefile arpack++1.2.patched/examples/umfpack/complex/Makefile
--- arpack++1.2.orig/examples/umfpack/complex/Makefile	2000-02-22 15:51:57.000000000 +0100
+++ arpack++1.2.patched/examples/umfpack/complex/Makefile	2006-01-26 15:37:46.000000000 +0100
@@ -32,7 +32,7 @@ ucompgsh:	ucompgsh.o
 
 .PHONY:	clean
 clean:
-	rm -f *~ *.o core
+	rm -f *~ *.o core ucompreg ucompshf ucompgre ucompgsh
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/examples/umfpack/nonsym/Makefile arpack++1.2.patched/examples/umfpack/nonsym/Makefile
--- arpack++1.2.orig/examples/umfpack/nonsym/Makefile	2000-02-22 16:00:11.000000000 +0100
+++ arpack++1.2.patched/examples/umfpack/nonsym/Makefile	2006-01-26 15:37:46.000000000 +0100
@@ -40,7 +40,7 @@ usvd:	usvd.o
 
 .PHONY:	clean
 clean:
-	rm -f *~ *.o core
+	rm -f *~ *.o core unsymreg unsymshf unsymgre unsymgsh unsymgsc usvd
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/examples/umfpack/nonsym/usvd.cc arpack++1.2.patched/examples/umfpack/nonsym/usvd.cc
--- arpack++1.2.orig/examples/umfpack/nonsym/usvd.cc	2000-02-22 16:03:23.000000000 +0100
+++ arpack++1.2.patched/examples/umfpack/nonsym/usvd.cc	2006-01-26 15:37:46.000000000 +0100
@@ -44,7 +44,7 @@
 #include "arssym.h"
 #include "lnmatrxv.h"
 #include "arunsmat.h"
-#include <math.h>
+#include <cmath>
 
 
 int main()
@@ -94,15 +94,15 @@ int main()
 
   // Printing some information about the problem.
 
-  cout << endl << "Testing ARPACK++ class ARSymStdEig" << endl;
-  cout << "Obtaining singular values by solving (A'*A)*v = sigma*v" << endl;
-  cout << "  greatest singular value: " << svalue[5] << endl;
-  cout << "  smallest singular value: " << svalue[0] << endl;
-  cout << "  condition number of A  : " << cond << endl;
-  cout << "MATLAB solution:" << endl;
-  cout << "  greatest singular value:  9.89757224207690 \n";
-  cout << "  smallest singular value:  1.41683937261247 \n";
-  cout << "  condition number of A  :  6.98566995906319 \n";
+  std::cout << std::endl << "Testing ARPACK++ class ARSymStdEig" << std::endl;
+  std::cout << "Obtaining singular values by solving (A'*A)*v = sigma*v" << std::endl;
+  std::cout << "  greatest singular value: " << svalue[5] << std::endl;
+  std::cout << "  smallest singular value: " << svalue[0] << std::endl;
+  std::cout << "  condition number of A  : " << cond << std::endl;
+  std::cout << "MATLAB solution:" << std::endl;
+  std::cout << "  greatest singular value:  9.89757224207690 \n";
+  std::cout << "  smallest singular value:  1.41683937261247 \n";
+  std::cout << "  condition number of A  :  6.98566995906319 \n";
 
 } // main.
 
diff -rupN arpack++1.2.orig/examples/umfpack/sym/Makefile arpack++1.2.patched/examples/umfpack/sym/Makefile
--- arpack++1.2.orig/examples/umfpack/sym/Makefile	2000-02-22 16:07:07.000000000 +0100
+++ arpack++1.2.patched/examples/umfpack/sym/Makefile	2006-01-26 15:37:46.000000000 +0100
@@ -38,7 +38,7 @@ usymgcay:	usymgcay.o
 
 .PHONY:	clean
 clean:
-	rm -f *~ *.o core
+	rm -f *~ *.o core usymreg usymshf usymgreg usymgshf usymgbkl usymgcay
 
 # defining pattern rules.
 
diff -rupN arpack++1.2.orig/include/arbgcomp.h arpack++1.2.patched/include/arbgcomp.h
--- arpack++1.2.orig/include/arbgcomp.h	2000-02-20 14:34:16.000000000 +0100
+++ arpack++1.2.patched/include/arbgcomp.h	2006-01-26 15:37:50.000000000 +0100
@@ -18,7 +18,7 @@
 #ifndef ARBGCOMP_H
 #define ARBGCOMP_H
 
-#include <stddef.h>
+#include <cstddef>
 #include "arch.h"
 #include "arbnsmat.h"
 #include "arbnspen.h"
@@ -103,8 +103,8 @@ Copy(const ARluCompGenEig<ARFLOAT>& othe
   ARCompGenEig<ARFLOAT, ARbdNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT >,
                ARbdNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT> >:: Copy(other);
   Pencil = other.Pencil;
-  objOP  = &Pencil;
-  objB   = &Pencil;
+  this->objOP  = &Pencil;
+  this->objB   = &Pencil;
 
 } // Copy.
 
@@ -114,7 +114,7 @@ inline void ARluCompGenEig<ARFLOAT>::
 ChangeShift(arcomplex<ARFLOAT> sigmaRp)
 {
 
-  objOP->FactorAsB(sigmaRp);
+  this->objOP->FactorAsB(sigmaRp);
   ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmaRp);
 
 } // ChangeShift.
@@ -155,7 +155,7 @@ ARluCompGenEig(int nevp, ARbdNonSymMatri
 {
 
   Pencil.DefineMatrices(A, B);
-  NoShift();
+  this->NoShift();
   DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARbdNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvBAv,
                    &Pencil, 
@@ -192,7 +192,7 @@ operator=(const ARluCompGenEig<ARFLOAT>&
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arbgnsym.h arpack++1.2.patched/include/arbgnsym.h
--- arpack++1.2.orig/include/arbgnsym.h	2000-02-20 14:18:20.000000000 +0100
+++ arpack++1.2.patched/include/arbgnsym.h	2006-01-26 15:37:50.000000000 +0100
@@ -18,7 +18,7 @@
 #ifndef ARBGNSYM_H
 #define ARBGNSYM_H
 
-#include <stddef.h>
+#include <cstddef>
 #include "arch.h"
 #include "arbnsmat.h"
 #include "arbnspen.h"
@@ -110,9 +110,9 @@ Copy(const ARluNonSymGenEig<ARFLOAT>& ot
   ARNonSymGenEig<ARFLOAT, ARbdNonSymPencil<ARFLOAT, ARFLOAT>,
                  ARbdNonSymPencil<ARFLOAT, ARFLOAT> >:: Copy(other);
   Pencil = other.Pencil;
-  objOP  = &Pencil;
-  objB   = &Pencil;
-  objA   = &Pencil;
+  this->objOP  = &Pencil;
+  this->objB   = &Pencil;
+  this->objA   = &Pencil;
 
 } // Copy.
 
@@ -123,10 +123,10 @@ ChangeShift(ARFLOAT sigmaRp, ARFLOAT sig
 {
 
   if (sigmaIp == 0.0) {
-    objOP->FactorAsB(sigmaRp);
+    this->objOP->FactorAsB(sigmaRp);
   }
   else {
-    objOP->FactorAsB(sigmaRp, sigmaIp, part);
+    this->objOP->FactorAsB(sigmaRp, sigmaIp, this->part);
   }
   ARrcNonSymGenEig<ARFLOAT>::ChangeShift(sigmaRp, sigmaIp);
 
@@ -178,7 +178,7 @@ ARluNonSymGenEig(int nevp, ARbdNonSymMat
 {
 
   Pencil.DefineMatrices(A, B);
-  NoShift();
+  this->NoShift();
   DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARbdNonSymPencil<ARFLOAT, ARFLOAT>::MultInvBAv, &Pencil,
                    &ARbdNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
@@ -231,7 +231,7 @@ operator=(const ARluNonSymGenEig<ARFLOAT
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arbgsym.h arpack++1.2.patched/include/arbgsym.h
--- arpack++1.2.orig/include/arbgsym.h	2000-02-20 14:10:22.000000000 +0100
+++ arpack++1.2.patched/include/arbgsym.h	2006-01-26 15:37:49.000000000 +0100
@@ -18,7 +18,7 @@
 #ifndef ARBGSYM_H
 #define ARBGSYM_H
 
-#include <stddef.h>
+#include <cstddef>
 #include "arch.h"
 #include "arbsmat.h"
 #include "arbspen.h"
@@ -104,9 +104,9 @@ Copy(const ARluSymGenEig<ARFLOAT>& other
   ARSymGenEig<ARFLOAT, ARbdSymPencil<ARFLOAT>,
               ARbdSymPencil<ARFLOAT> >:: Copy(other);
   Pencil = other.Pencil;
-  objOP  = &Pencil;
-  objB   = &Pencil;
-  objA   = &Pencil;
+  this->objOP  = &Pencil;
+  this->objB   = &Pencil;
+  this->objA   = &Pencil;
 
 } // Copy.
 
@@ -115,7 +115,7 @@ template<class ARFLOAT>
 inline void ARluSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)
 {
 
-  objOP->FactorAsB(sigmap);
+  this->objOP->FactorAsB(sigmap);
   ARrcSymGenEig<ARFLOAT>::ChangeShift(sigmap);
 
 } // ChangeShift.
@@ -177,8 +177,8 @@ ARluSymGenEig(int nevp, ARbdSymMatrix<AR
 {
 
   Pencil.DefineMatrices(A, B);
-  InvertMode = 'S';
-  NoShift();
+  this->InvertMode = 'S';
+  this->NoShift();
   DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARbdSymPencil<ARFLOAT>::MultInvBAv, &Pencil,
                    &ARbdSymPencil<ARFLOAT>::MultBv, whichp,
@@ -201,8 +201,8 @@ ARluSymGenEig(char InvertModep, int nevp
                    &ARbdSymPencil<ARFLOAT>::MultInvAsBv, &Pencil,
                    &ARbdSymPencil<ARFLOAT>::MultBv, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
-  InvertMode = CheckInvertMode(InvertModep);
-  switch (InvertMode) {
+  this->InvertMode = this->CheckInvertMode(InvertModep);
+  switch (this->InvertMode) {
   case 'B':
     ChangeMultBx(&Pencil, &ARbdSymPencil<ARFLOAT>::MultAv);
   case 'S':
@@ -221,7 +221,7 @@ operator=(const ARluSymGenEig<ARFLOAT>& 
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arbnsmat.h arpack++1.2.patched/include/arbnsmat.h
--- arpack++1.2.orig/include/arbnsmat.h	2000-02-21 00:00:46.000000000 +0100
+++ arpack++1.2.patched/include/arbnsmat.h	2006-01-26 15:37:49.000000000 +0100
@@ -20,7 +20,7 @@
 #ifndef ARBNSMAT_H
 #define ARBNSMAT_H
 
-#include <stddef.h>
+#include <cstddef>
 #include "arch.h"
 #include "armat.h"
 #include "arerror.h"
@@ -123,9 +123,9 @@ Copy(const ARbdNonSymMatrix<ARTYPE, ARFL
 
   // Copying very fundamental variables and user-defined parameters.
 
-  m         = other.m;
-  n         = other.n;
-  defined   = other.defined;
+  this->m         = other.m;
+   this->n         = other.n;
+   this->defined   = other.defined;
   factored  = other.factored;
   ndiagL    = other.ndiagL;
   ndiagU    = other.ndiagU;
@@ -139,11 +139,11 @@ Copy(const ARbdNonSymMatrix<ARTYPE, ARFL
 
   // Copying vectors.
 
-  Ainv = new ARTYPE[n*lda];
-  ipiv = new int[n];
+  Ainv = new ARTYPE[ this->n*lda];
+  ipiv = new int[ this->n];
 
-  copy(n*lda, other.Ainv, 1, Ainv, 1);
-  for (int i=0; i<n; i++) ipiv[i] = other.ipiv[i];
+  copy( this->n*lda, other.Ainv, 1, Ainv, 1);
+  for (int i=0; i< this->n; i++) ipiv[i] = other.ipiv[i];
 
 } // Copy.
 
@@ -158,7 +158,7 @@ void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::
 
   inca = ndiagL+ndiagU+1;
   for (i = 0; i < inca; i++) {
-    copy(n, &A[i], inca, &Ainv[ndiagL+i], lda);
+    copy( this->n, &A[i], inca, &Ainv[ndiagL+i], lda);
   }
 
 } // ExpandA.
@@ -174,7 +174,7 @@ void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Subtracting sigma from diagonal elements.
 
-  for (int i=(ndiagL+ndiagU); i<(lda*n); i+=lda) Ainv[i] -= sigma; 
+  for (int i=(ndiagL+ndiagU); i<(lda* this->n); i+=lda) Ainv[i] -= sigma; 
 
 } // SubtractAsI.
 
@@ -184,8 +184,8 @@ inline void ARbdNonSymMatrix<ARTYPE, ARF
 {
 
   ClearMem();
-  Ainv = new ARTYPE[lda*n];
-  ipiv = new int[n];
+  Ainv = new ARTYPE[lda* this->n];
+  ipiv = new int[ this->n];
 
 } // CreateStructure.
 
@@ -212,7 +212,7 @@ void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (! this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARbdNonSymMatrix::FactorA");
   }
 
@@ -226,7 +226,7 @@ void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Decomposing A.
 
-  gbtrf(n, n, ndiagL, ndiagU, Ainv, lda, ipiv, info);
+  gbtrf( this->n,  this->n, ndiagL, ndiagU, Ainv, lda, ipiv, info);
 
   // Handling errors.
 
@@ -243,7 +243,7 @@ void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (! this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED,
                       "ARbdNonSymMatrix::FactorAsI");
   }
@@ -258,7 +258,7 @@ void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Decomposing AsI.
 
-  gbtrf(n, n, ndiagL, ndiagU, Ainv, lda, ipiv, info);
+  gbtrf( this->n,  this->n, ndiagL, ndiagU, Ainv, lda, ipiv, info);
 
   // Handling errors.
 
@@ -281,13 +281,13 @@ void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (! this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARbdNonSymMatrix::MultMv");
   }
 
   // Determining w = M.v.
 
-  gbmv("N", m, n, ndiagL, ndiagU, one, A,
+  gbmv("N",  this->m,  this->n, ndiagL, ndiagU, one, A,
        ndiagL+ndiagU+1, v, 1, zero, w, 1);
 
 } // MultMv.
@@ -305,13 +305,13 @@ void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (! this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARbdNonSymMatrix::MultMtv");
   }
 
   // Determining w = M'.v.
 
-  gbmv("T", m, n, ndiagL, ndiagU, one, A,
+  gbmv("T",  this->m,  this->n, ndiagL, ndiagU, one, A,
        ndiagL+ndiagU+1, v, 1, zero, w, 1);   
 
 } // MultMtv.
@@ -321,7 +321,7 @@ template<class ARTYPE, class ARFLOAT>
 void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::MultMtMv(ARTYPE* v, ARTYPE* w)
 {
 
-  ARTYPE* t = new ARTYPE[m];
+  ARTYPE* t = new ARTYPE[ this->m];
 
   MultMv(v,t);
   MultMtv(t,w);
@@ -335,7 +335,7 @@ template<class ARTYPE, class ARFLOAT>
 void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::MultMMtv(ARTYPE* v, ARTYPE* w)
 {
 
-  ARTYPE* t = new ARTYPE[n];
+  ARTYPE* t = new ARTYPE[ this->n];
 
   MultMtv(v,t);
   MultMv(t,w);
@@ -349,8 +349,8 @@ template<class ARTYPE, class ARFLOAT>
 void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::Mult0MMt0v(ARTYPE* v, ARTYPE* w)
 {
 
-  MultMv(&v[m],w);
-  MultMtv(v,&w[m]);
+  MultMv(&v[ this->m],w);
+  MultMtv(v,&w[ this->m]);
 
 } // Mult0MMt0v.
 
@@ -368,11 +368,11 @@ void ARbdNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Overwritting w with v.
 
-  copy(n, v, 1, w, 1);
+  copy( this->n, v, 1, w, 1);
 
   // Solving A.w = v (or AsI.w = v).
 
-  gbtrs("N", n, ndiagL, ndiagU, 1, Ainv, lda, ipiv, w, m, info);
+  gbtrs("N",  this->n, ndiagL, ndiagU, 1, Ainv, lda, ipiv, w,  this->m, info);
 
   // Handling errors.
 
@@ -388,13 +388,13 @@ DefineMatrix(int np, int ndiagLp, int nd
 
   // Defining member variables.
 
-  m         = np;
-  n         = np;
+   this->m         = np;
+   this->n         = np;
   ndiagL    = ndiagLp;
   ndiagU    = ndiagUp;
   lda       = 2*ndiagL+ndiagU+1;
   A         = Ap;
-  defined   = true;
+   this->defined   = true;
   Ainv      = NULL;
   ipiv      = NULL;
   info      = 0; 
@@ -420,7 +420,7 @@ operator=(const ARbdNonSymMatrix<ARTYPE,
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+     this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arbscomp.h arpack++1.2.patched/include/arbscomp.h
--- arpack++1.2.orig/include/arbscomp.h	2000-02-20 14:29:32.000000000 +0100
+++ arpack++1.2.patched/include/arbscomp.h	2006-01-26 15:37:49.000000000 +0100
@@ -18,7 +18,7 @@
 #ifndef ARBSCOMP_H
 #define ARBSCOMP_H
 
-#include <stddef.h>
+#include <cstddef>
 #include "arch.h"
 #include "arscomp.h"
 #include "arbnsmat.h"
@@ -84,7 +84,7 @@ inline void ARluCompStdEig<ARFLOAT>::
 ChangeShift(arcomplex<ARFLOAT> sigmaRp)
 {
 
-  objOP->FactorAsI(sigmaRp);
+  this->objOP->FactorAsI(sigmaRp);
   ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmaRp);
 
 } // ChangeShift.
@@ -96,7 +96,7 @@ inline void ARluCompStdEig<ARFLOAT>::Set
 
   ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
            ARbdNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT> >::
-    SetRegularMode(objOP,&ARbdNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT>::MultMv);
+    SetRegularMode(this->objOP,&ARbdNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT>::MultMv);
 
 } // SetRegularMode.
 
@@ -108,7 +108,7 @@ SetShiftInvertMode(arcomplex<ARFLOAT> si
 
   ARStdEig<ARFLOAT, arcomplex<ARFLOAT>,
            ARbdNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT> >::
-    SetShiftInvertMode(sigmap, objOP,
+    SetShiftInvertMode(sigmap, this->objOP,
                        &ARbdNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT>::MultInvv);
 
 } // SetShiftInvertMode.
@@ -122,7 +122,7 @@ ARluCompStdEig(int nevp, ARbdNonSymMatri
 
 {
 
-  NoShift();
+  this->NoShift();
   DefineParameters(A.ncols(), nevp, &A,
                    &ARbdNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
@@ -153,7 +153,7 @@ operator=(const ARluCompStdEig<ARFLOAT>&
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arbsmat.h arpack++1.2.patched/include/arbsmat.h
--- arpack++1.2.orig/include/arbsmat.h	2000-02-20 13:46:20.000000000 +0100
+++ arpack++1.2.patched/include/arbsmat.h	2006-01-26 15:37:49.000000000 +0100
@@ -20,7 +20,7 @@
 #ifndef ARBSMAT_H
 #define ARBSMAT_H
 
-#include <stddef.h>
+#include <cstddef>
 #include "arch.h"
 #include "armat.h"
 #include "arerror.h"
@@ -114,9 +114,9 @@ Copy(const ARbdSymMatrix<ARTYPE>& other)
 
   // Copying very fundamental variables and user-defined parameters.
 
-  m         = other.m;
-  n         = other.n;
-  defined   = other.defined;
+  this->m         = other.m;
+  this->n         = other.n;
+  this->defined   = other.defined;
   factored  = other.factored;
   uplo      = other.uplo;
   nsdiag    = other.nsdiag;
@@ -130,11 +130,11 @@ Copy(const ARbdSymMatrix<ARTYPE>& other)
 
   // Copying vectors.
 
-  Ainv = new ARTYPE[n*lda];
-  ipiv = new int[n];
+  Ainv = new ARTYPE[this->n*lda];
+  ipiv = new int[this->n];
 
-  copy(n*lda, other.Ainv, 1, Ainv, 1);
-  for (int i=0; i<n; i++) ipiv[i] = other.ipiv[i];
+  copy(this->n*lda, other.Ainv, 1, Ainv, 1);
+  for (int i=0; i<this->n; i++) ipiv[i] = other.ipiv[i];
 
 } // Copy.
 
@@ -149,13 +149,13 @@ void ARbdSymMatrix<ARTYPE>::ExpandA()
 
     // Copying the main diagonal of A to Ainv.
 
-    copy(n, &A[nsdiag], nsdiag+1, &Ainv[2*nsdiag], lda);
+    copy(this->n, &A[nsdiag], nsdiag+1, &Ainv[2*nsdiag], lda);
 
     // Copying the superdiagonals of A to Ainv.
 
     for (i = 0; i < nsdiag; i++) {
-      copy(n, &A[i], nsdiag+1, &Ainv[nsdiag+i], lda);
-      copy(n-nsdiag+i, &A[i+(nsdiag-i)*(nsdiag+1)], nsdiag+1, 
+      copy(this->n, &A[i], nsdiag+1, &Ainv[nsdiag+i], lda);
+      copy(this->n-nsdiag+i, &A[i+(nsdiag-i)*(nsdiag+1)], nsdiag+1, 
            &Ainv[3*nsdiag-i], lda);
     }
 
@@ -164,13 +164,13 @@ void ARbdSymMatrix<ARTYPE>::ExpandA()
 
     // Copying the main diagonal of A to Ainv.
 
-    copy(n, &A[0], nsdiag+1, &Ainv[2*nsdiag], lda);
+    copy(this->n, &A[0], nsdiag+1, &Ainv[2*nsdiag], lda);
 
     // Copying the subdiagonals of A to Ainv.
 
     for (i = 1; i <= nsdiag; i++) {
-      copy(n, &A[i], nsdiag+1, &Ainv[2*nsdiag+i], lda);
-      copy(n-i, &A[i], nsdiag+1, &Ainv[2*nsdiag-i+i*lda], lda);
+      copy(this->n, &A[i], nsdiag+1, &Ainv[2*nsdiag+i], lda);
+      copy(this->n-i, &A[i], nsdiag+1, &Ainv[2*nsdiag-i+i*lda], lda);
     }
 
   }
@@ -188,7 +188,7 @@ void ARbdSymMatrix<ARTYPE>::SubtractAsI(
 
   // Subtracting sigma from diagonal elements.
 
-  for (int i=(2*nsdiag); i<(lda*n); i+=lda) Ainv[i] -= sigma; 
+  for (int i=(2*nsdiag); i<(lda*this->n); i+=lda) Ainv[i] -= sigma; 
 
 } // SubtractAsI.
 
@@ -198,8 +198,8 @@ inline void ARbdSymMatrix<ARTYPE>::Creat
 {
 
   ClearMem();
-  Ainv = new ARTYPE[lda*n];
-  ipiv = new int[n];
+  Ainv = new ARTYPE[lda*this->n];
+  ipiv = new int[this->n];
 
 } // CreateStructure.
 
@@ -226,7 +226,7 @@ void ARbdSymMatrix<ARTYPE>::FactorA()
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARbdSymMatrix::FactorA");
   }
 
@@ -240,7 +240,7 @@ void ARbdSymMatrix<ARTYPE>::FactorA()
 
   // Decomposing A.
 
-  gbtrf(n, n, nsdiag, nsdiag, Ainv, lda, ipiv, info);
+  gbtrf(this->n, this->n, nsdiag, nsdiag, Ainv, lda, ipiv, info);
 
   // Handling errors.
 
@@ -257,7 +257,7 @@ void ARbdSymMatrix<ARTYPE>::FactorAsI(AR
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARbdSymMatrix::FactorAsI");
   }
 
@@ -271,7 +271,7 @@ void ARbdSymMatrix<ARTYPE>::FactorAsI(AR
 
   // Decomposing AsI.
 
-  gbtrf(n, n, nsdiag, nsdiag, Ainv, lda, ipiv, info);
+  gbtrf(this->n, this->n, nsdiag, nsdiag, Ainv, lda, ipiv, info);
 
   // Handling errors.
 
@@ -291,13 +291,13 @@ void ARbdSymMatrix<ARTYPE>::MultMv(ARTYP
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARbdSymMatrix::MultMv");
   }
 
   // Determining w = M.v.
 
-  sbmv(&uplo, n, nsdiag, one, A, nsdiag+1, v, 1, zero, w, 1);
+  sbmv(&uplo, this->n, nsdiag, one, A, nsdiag+1, v, 1, zero, w, 1);
 
 } // MultMv.
 
@@ -315,11 +315,11 @@ void ARbdSymMatrix<ARTYPE>::MultInvv(ART
 
   // Overwritting w with v.
 
-  copy(n, v, 1, w, 1);
+  copy(this->n, v, 1, w, 1);
 
   // Solving A.w = v (or AsI.w = v).
 
-  gbtrs("N", n, nsdiag, nsdiag, 1, Ainv, lda, ipiv, w, m, info);
+  gbtrs("N", this->n, nsdiag, nsdiag, 1, Ainv, lda, ipiv, w, this->m, info);
 
   // Handling errors.
 
@@ -335,13 +335,13 @@ DefineMatrix(int np, int nsdiagp, ARTYPE
 
   // Defining member variables.
 
-  m         = np;
-  n         = np;
+  this->m         = np;
+  this->n         = np;
   nsdiag    = nsdiagp;
   lda       = 3*nsdiag+1;
   uplo      = uplop;
   A         = Ap;
-  defined   = true;
+  this->defined   = true;
   Ainv      = NULL;
   ipiv      = NULL;
   info      = 0; 
@@ -367,7 +367,7 @@ operator=(const ARbdSymMatrix<ARTYPE>& o
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arbsnsym.h arpack++1.2.patched/include/arbsnsym.h
--- arpack++1.2.orig/include/arbsnsym.h	2000-02-20 14:14:28.000000000 +0100
+++ arpack++1.2.patched/include/arbsnsym.h	2006-01-26 15:37:49.000000000 +0100
@@ -18,7 +18,7 @@
 #ifndef ARBSNSYM_H
 #define ARBSNSYM_H
 
-#include <stddef.h>
+#include <cstddef>
 #include "arch.h"
 #include "arsnsym.h"
 #include "arbnsmat.h"
@@ -81,13 +81,13 @@ inline void ARluNonSymStdEig<ARFLOAT>::
 ChangeShift(ARFLOAT sigmaRp)
 {
 
-  sigmaR    = sigmaRp;
-  sigmaI    = 0.0;
-  mode      = 3;
-  iparam[7] = mode;
+   this->sigmaR    = sigmaRp;
+   this->sigmaI    = 0.0;
+   this->mode      = 3;
+   this->iparam[7] =  this->mode;
 
-  objOP->FactorAsI(sigmaR);
-  Restart();
+   this->objOP->FactorAsI( this->sigmaR);
+   this->Restart();
 
 } // ChangeShift.
 
@@ -97,7 +97,7 @@ inline void ARluNonSymStdEig<ARFLOAT>::S
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARbdNonSymMatrix<ARFLOAT, ARFLOAT> >::
-    SetRegularMode(objOP, &ARbdNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv);
+    SetRegularMode( this->objOP, &ARbdNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv);
 
 } // SetRegularMode.
 
@@ -107,7 +107,7 @@ inline void ARluNonSymStdEig<ARFLOAT>::S
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARbdNonSymMatrix<ARFLOAT, ARFLOAT> >::
-    SetShiftInvertMode(sigmap, objOP, 
+    SetShiftInvertMode(sigmap,  this->objOP, 
                        &ARbdNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv);
 
 } // SetShiftInvertMode.
@@ -121,7 +121,7 @@ ARluNonSymStdEig(int nevp, ARbdNonSymMat
 
 {
 
-  NoShift();
+   this->NoShift();
   DefineParameters(A.ncols(), nevp, &A, 
                    &(ARbdNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv),
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
@@ -151,7 +151,7 @@ operator=(const ARluNonSymStdEig<ARFLOAT
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+     this->ClearMem();
     Copy(other);
   }
   return *this;
@@ -160,4 +160,3 @@ operator=(const ARluNonSymStdEig<ARFLOAT
 
 
 #endif // ARBSNSYM_H
-
diff -rupN arpack++1.2.orig/include/arbssym.h arpack++1.2.patched/include/arbssym.h
--- arpack++1.2.orig/include/arbssym.h	2000-02-20 14:08:20.000000000 +0100
+++ arpack++1.2.patched/include/arbssym.h	2006-01-26 15:37:49.000000000 +0100
@@ -18,7 +18,7 @@
 #ifndef ARBSSYM_H
 #define ARBSSYM_H
 
-#include <stddef.h>
+#include <cstddef>
 #include "arch.h"
 #include "arssym.h"
 #include "arbsmat.h"
@@ -81,13 +81,13 @@ inline void ARluSymStdEig<ARFLOAT>::
 ChangeShift(ARFLOAT sigmaRp)
 {
 
-  sigmaR    = sigmaRp;
-  sigmaI    = 0.0;
-  mode      = 3;
-  iparam[7] = mode;
+  this->sigmaR    = sigmaRp;
+  this->sigmaI    = 0.0;
+  this->mode      = 3;
+  this->iparam[7] = this->mode;
 
-  objOP->FactorAsI(sigmaR);
-  Restart();
+  this->objOP->FactorAsI(this->sigmaR);
+  this->Restart();
 
 } // ChangeShift.
 
@@ -97,7 +97,7 @@ inline void ARluSymStdEig<ARFLOAT>::SetR
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARbdSymMatrix<ARFLOAT> >::
-    SetRegularMode(objOP, &ARbdSymMatrix<ARFLOAT>::MultMv);
+    SetRegularMode(this->objOP, &ARbdSymMatrix<ARFLOAT>::MultMv);
 
 } // SetRegularMode.
 
@@ -107,7 +107,7 @@ inline void ARluSymStdEig<ARFLOAT>::SetS
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARbdSymMatrix<ARFLOAT> >::
-    SetShiftInvertMode(sigmap, objOP, &ARbdSymMatrix<ARFLOAT>::MultInvv);
+    SetShiftInvertMode(sigmap, this->objOP, &ARbdSymMatrix<ARFLOAT>::MultInvv);
 
 } // SetShiftInvertMode.
 
@@ -119,7 +119,7 @@ ARluSymStdEig(int nevp, ARbdSymMatrix<AR
               int maxitp, ARFLOAT* residp, bool ishiftp)
 {
 
-  NoShift();
+  this->NoShift();
   DefineParameters(A.ncols(), nevp, &A, &ARbdSymMatrix<ARFLOAT>::MultMv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
@@ -147,7 +147,7 @@ operator=(const ARluSymStdEig<ARFLOAT>& 
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
@@ -156,4 +156,3 @@ operator=(const ARluSymStdEig<ARFLOAT>& 
 
 
 #endif // ARBSSYM_H
-
diff -rupN arpack++1.2.orig/include/arch.h arpack++1.2.patched/include/arch.h
--- arpack++1.2.orig/include/arch.h	2000-03-03 21:35:38.000000000 +0100
+++ arpack++1.2.patched/include/arch.h	2006-01-26 15:37:49.000000000 +0100
@@ -29,7 +29,7 @@
 // If the Standard Template Library is not available at your system
 // and you do not want to install it, comment out the following line.
 
-#include <vector.h>
+#include <vector>
 
 // If your STL vector class defines a variable other than
 // __SGI_STL_VECTOR_H, please change this variable name 
diff -rupN arpack++1.2.orig/include/arcomp.h arpack++1.2.patched/include/arcomp.h
--- arpack++1.2.orig/include/arcomp.h	2000-02-20 14:05:08.000000000 +0100
+++ arpack++1.2.patched/include/arcomp.h	2006-01-26 15:37:49.000000000 +0100
@@ -17,11 +17,11 @@
 #ifndef ARCOMP_H
 #define ARCOMP_H
 
-#include <complex.h>
+#include <complex>
 
 #ifdef __GNUG__
   
-#define arcomplex complex
+#define arcomplex std::complex
 
 #endif
 
diff -rupN arpack++1.2.orig/include/ardfmat.h arpack++1.2.patched/include/ardfmat.h
--- arpack++1.2.orig/include/ardfmat.h	2000-02-21 21:00:20.000000000 +0100
+++ arpack++1.2.patched/include/ardfmat.h	2006-01-26 15:37:49.000000000 +0100
@@ -19,11 +19,11 @@
 #ifndef ARDFMAT_H
 #define ARDFMAT_H
 
-#include <stddef.h>
-#include <fstream.h>
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
+#include <cstddef>
+#include <fstream>
+#include <cstdlib>
+#include <cstring>
+#include <cstdio>
 #include "arch.h"
 #include "arerror.h"
 
@@ -36,7 +36,7 @@ class ARdfMatrix {
   // const int linelength = 256;
 
   char*    datafile;  // Filename.
-  ifstream file;      // File handler.
+  std::ifstream file;      // File handler.
   int      m;         // Number of rows.
   int      n;         // Number of columns.
   int      blksize;   // Size of each matrix block that is read at once.
@@ -55,13 +55,13 @@ class ARdfMatrix {
 
   void SetComplexPointers(char* num, char* &realp, char* &imagp);
 			  			  
-  bool ReadEntry(ifstream& file, double& val);
+  bool ReadEntry(std::ifstream& file, double& val);
 
-  bool ReadEntry(ifstream& file, float& val);
+  bool ReadEntry(std::ifstream& file, float& val);
 
-  bool ReadEntry(ifstream& file, arcomplex<double>& val);
+  bool ReadEntry(std::ifstream& file, arcomplex<double>& val);
 
-  bool ReadEntry(ifstream& file, arcomplex<float>& val);
+  bool ReadEntry(std::ifstream& file, arcomplex<float>& val);
   
  public:
   
@@ -145,7 +145,7 @@ SetComplexPointers(char* num, char* &rea
 
 
 template<class ARTYPE>
-inline bool ARdfMatrix<ARTYPE>::ReadEntry(ifstream& file, double& val)
+inline bool ARdfMatrix<ARTYPE>::ReadEntry(std::ifstream& file, double& val)
 {
 
   char num[LINELEN];
@@ -165,7 +165,7 @@ inline bool ARdfMatrix<ARTYPE>::ReadEntr
 
 
 template<class ARTYPE>
-inline bool ARdfMatrix<ARTYPE>::ReadEntry(ifstream& file, float& val)
+inline bool ARdfMatrix<ARTYPE>::ReadEntry(std::ifstream& file, float& val)
 {
 
   double dval;
@@ -180,7 +180,7 @@ inline bool ARdfMatrix<ARTYPE>::ReadEntr
 
 template<class ARTYPE>
 inline bool ARdfMatrix<ARTYPE>::
-ReadEntry(ifstream& file, arcomplex<double>& val)
+ReadEntry(std::ifstream& file, arcomplex<double>& val)
 {
 
   char  num[LINELEN];
@@ -204,7 +204,7 @@ ReadEntry(ifstream& file, arcomplex<doub
 
 template<class ARTYPE>
 inline bool ARdfMatrix<ARTYPE>::
-ReadEntry(ifstream& file, arcomplex<float>& val)
+ReadEntry(std::ifstream& file, arcomplex<float>& val)
 {
 
   char  num[LINELEN];
diff -rupN arpack++1.2.orig/include/ardgcomp.h arpack++1.2.patched/include/ardgcomp.h
--- arpack++1.2.orig/include/ardgcomp.h	2000-02-21 00:30:26.000000000 +0100
+++ arpack++1.2.patched/include/ardgcomp.h	2006-01-26 15:37:49.000000000 +0100
@@ -18,7 +18,8 @@
 #ifndef ARDGCOMP_H
 #define ARDGCOMP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "ardnsmat.h"
 #include "ardnspen.h"
@@ -103,8 +104,8 @@ Copy(const ARluCompGenEig<ARFLOAT>& othe
   ARCompGenEig<ARFLOAT, ARdsNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT >,
                ARdsNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT> >:: Copy(other);
   Pencil = other.Pencil;
-  objOP  = &Pencil;
-  objB   = &Pencil;
+  this->objOP  = &Pencil;
+  this->objB   = &Pencil;
 
 } // Copy.
 
@@ -114,7 +115,7 @@ inline void ARluCompGenEig<ARFLOAT>::
 ChangeShift(arcomplex<ARFLOAT> sigmaRp)
 {
 
-  objOP->FactorAsB(sigmaRp);
+  this->objOP->FactorAsB(sigmaRp);
   ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmaRp);
 
 } // ChangeShift.
@@ -155,7 +156,7 @@ ARluCompGenEig(int nevp, ARdsNonSymMatri
 {
 
   Pencil.DefineMatrices(A, B);
-  NoShift();
+  this->NoShift();
   DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARdsNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvBAv,
                    &Pencil, 
@@ -192,7 +193,7 @@ operator=(const ARluCompGenEig<ARFLOAT>&
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/ardgnsym.h arpack++1.2.patched/include/ardgnsym.h
--- arpack++1.2.orig/include/ardgnsym.h	2000-02-21 00:18:48.000000000 +0100
+++ arpack++1.2.patched/include/ardgnsym.h	2006-01-26 15:37:49.000000000 +0100
@@ -18,7 +18,8 @@
 #ifndef ARDGNSYM_H
 #define ARDGNSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "ardnsmat.h"
 #include "ardnspen.h"
@@ -110,9 +111,9 @@ Copy(const ARluNonSymGenEig<ARFLOAT>& ot
   ARNonSymGenEig<ARFLOAT, ARdsNonSymPencil<ARFLOAT, ARFLOAT>,
                  ARdsNonSymPencil<ARFLOAT, ARFLOAT> >:: Copy(other);
   Pencil = other.Pencil;
-  objOP  = &Pencil;
-  objB   = &Pencil;
-  objA   = &Pencil;
+  this->objOP  = &Pencil;
+  this->objB   = &Pencil;
+  this->objA   = &Pencil;
 
 } // Copy.
 
@@ -123,10 +124,10 @@ ChangeShift(ARFLOAT sigmaRp, ARFLOAT sig
 {
 
   if (sigmaIp == 0.0) {
-    objOP->FactorAsB(sigmaRp);
+    this->objOP->FactorAsB(sigmaRp);
   }
   else {
-    objOP->FactorAsB(sigmaRp, sigmaIp, part);
+    this->objOP->FactorAsB(sigmaRp, sigmaIp, this->part);
   }
   ARrcNonSymGenEig<ARFLOAT>::ChangeShift(sigmaRp, sigmaIp);
 
@@ -178,7 +179,7 @@ ARluNonSymGenEig(int nevp, ARdsNonSymMat
 {
 
   Pencil.DefineMatrices(A, B);
-  NoShift();
+  this->NoShift();
   DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARdsNonSymPencil<ARFLOAT, ARFLOAT>::MultInvBAv, &Pencil,
                    &ARdsNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
@@ -232,7 +233,7 @@ operator=(const ARluNonSymGenEig<ARFLOAT
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/ardgsym.h arpack++1.2.patched/include/ardgsym.h
--- arpack++1.2.orig/include/ardgsym.h	2000-02-21 00:11:24.000000000 +0100
+++ arpack++1.2.patched/include/ardgsym.h	2006-01-26 15:37:49.000000000 +0100
@@ -18,7 +18,8 @@
 #ifndef ARDGSYM_H
 #define ARDGSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "ardsmat.h"
 #include "ardspen.h"
@@ -104,9 +105,9 @@ Copy(const ARluSymGenEig<ARFLOAT>& other
   ARSymGenEig<ARFLOAT, ARdsSymPencil<ARFLOAT>,
               ARdsSymPencil<ARFLOAT> >:: Copy(other);
   Pencil = other.Pencil;
-  objOP  = &Pencil;
-  objB   = &Pencil;
-  objA   = &Pencil;
+  this->objOP  = &Pencil;
+  this->objB   = &Pencil;
+  this->objA   = &Pencil;
 
 } // Copy.
 
@@ -115,7 +116,7 @@ template<class ARFLOAT>
 inline void ARluSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)
 {
 
-  objOP->FactorAsB(sigmap);
+  this->objOP->FactorAsB(sigmap);
   ARrcSymGenEig<ARFLOAT>::ChangeShift(sigmap);
 
 } // ChangeShift.
@@ -177,8 +178,8 @@ ARluSymGenEig(int nevp, ARdsSymMatrix<AR
 {
 
   Pencil.DefineMatrices(A, B);
-  InvertMode = 'S';
-  NoShift();
+  this->InvertMode = 'S';
+  this->NoShift();
   DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARdsSymPencil<ARFLOAT>::MultInvBAv, &Pencil,
                    &ARdsSymPencil<ARFLOAT>::MultBv, whichp,
@@ -201,8 +202,8 @@ ARluSymGenEig(char InvertModep, int nevp
                    &ARdsSymPencil<ARFLOAT>::MultInvAsBv, &Pencil,
                    &ARdsSymPencil<ARFLOAT>::MultBv, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
-  InvertMode = CheckInvertMode(InvertModep);
-  switch (InvertMode) {
+  this->InvertMode = this->CheckInvertMode(InvertModep);
+  switch (this->InvertMode) {
   case 'B':
     ChangeMultBx(&Pencil, &ARdsSymPencil<ARFLOAT>::MultAv);
   case 'S':
@@ -221,7 +222,7 @@ operator=(const ARluSymGenEig<ARFLOAT>& 
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/ardnsmat.h arpack++1.2.patched/include/ardnsmat.h
--- arpack++1.2.orig/include/ardnsmat.h	2000-02-21 20:58:26.000000000 +0100
+++ arpack++1.2.patched/include/ardnsmat.h	2006-01-26 15:37:49.000000000 +0100
@@ -20,7 +20,8 @@
 #ifndef ARDNSMAT_H
 #define ARDNSMAT_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "armat.h"
 #include "arerror.h"
@@ -126,9 +127,9 @@ Copy(const ARdsNonSymMatrix<ARTYPE, ARFL
 
   // Copying very fundamental variables and user-defined parameters.
 
-  m         = other.m;
-  n         = other.n;
-  defined   = other.defined;
+  this->m         = other.m;
+  this->n         = other.n;
+  this->defined   = other.defined;
   factored  = other.factored;
   info      = other.info;
   A         = other.A;
@@ -145,11 +146,11 @@ Copy(const ARdsNonSymMatrix<ARTYPE, ARFL
 
   // Copying vectors.
 
-  Ainv = new ARTYPE[m*n];
-  ipiv = new int[n];
+  Ainv = new ARTYPE[this->m*this->n];
+  ipiv = new int[this->n];
 
-  copy(m*n, other.Ainv, 1, Ainv, 1);
-  for (int i=0; i<n; i++) ipiv[i] = other.ipiv[i];
+  copy(this->m*this->n, other.Ainv, 1, Ainv, 1);
+  for (int i=0; i<this->n; i++) ipiv[i] = other.ipiv[i];
 
 } // Copy.
 
@@ -159,8 +160,8 @@ inline void ARdsNonSymMatrix<ARTYPE, ARF
 {
 
   ClearMem();
-  Ainv = new ARTYPE[m*n];
-  ipiv = new int[n];
+  Ainv = new ARTYPE[this->m*this->n];
+  ipiv = new int[this->n];
 
 } // CreateStructure.
 
@@ -187,11 +188,11 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined or is rectangular.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARdsNonSymMatrix::FactorA");
   }
 
-  if (m!=n) {
+  if (this->m!=this->n) {
     throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
                       "ARdsNonSymMatrix::FactorA");
   }
@@ -207,11 +208,11 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Copying A to Ainv;
 
-  ::copy(m*n, A, 1, Ainv, 1);
+  ::copy(this->m*this->n, A, 1, Ainv, 1);
 
   // Decomposing A.
 
-  getrf(m, n, Ainv, m, ipiv, info);
+  getrf(this->m, this->n, Ainv, this->m, ipiv, info);
 
   // Handling errors.
 
@@ -228,12 +229,12 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined or is rectangular.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED,
                       "ARdsNonSymMatrix::FactorAsI");
   }
 
-  if (m!=n) {
+  if (this->m!=this->n) {
     throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
                       "ARdsNonSymMatrix::FactorAsI");
   }
@@ -249,12 +250,12 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Subtracting sigma*I from A.
 
-  ::copy(m*n,A,1,Ainv,1);
-  for (int i=0; i<(m*n); i+=m+1) Ainv[i]-=sigma;
+  ::copy(this->m*this->n,A,1,Ainv,1);
+  for (int i=0; i<(this->m*this->n); i+=this->m+1) Ainv[i]-=sigma;
 
   // Decomposing AsI.
 
-  getrf(m, n, Ainv, m, ipiv, info);
+  getrf(this->m, this->n, Ainv, this->m, ipiv, info);
 
   // Handling errors.
 
@@ -279,7 +280,7 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARdsNonSymMatrix::MultMv");
   }
 
@@ -287,14 +288,14 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
 
   if (mat.IsOutOfCore()) {
 
-    if (m>n) { 
+    if (this->m>this->n) { 
 
       // Matrix is "tall".
 
       mat.Rewind();
       for (i=0; i<mat.NBlocks(); i++) {
         mat.ReadBlock();
-        gemv("N", mat.RowsInMemory(), n, one, mat.Entries(), 
+        gemv("N", mat.RowsInMemory(), this->n, one, mat.Entries(), 
              mat.RowsInMemory(), v, 1, zero, &w[mat.FirstIndex()], 1);
       }
 
@@ -305,12 +306,12 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
 
       mat.Rewind();
       t = new ARTYPE[mat.ColsInMemory()];
-      for (i=0; i<m; i++) w[i] = zero;
+      for (i=0; i<this->m; i++) w[i] = zero;
       for (i=0; i<mat.NBlocks(); i++) {
         mat.ReadBlock();
-        gemv("N", m, mat.ColsInMemory(), one, mat.Entries(), 
-             m, &v[mat.FirstIndex()], 1, zero, t, 1);
-        axpy(m, one, t, 1, w, 1); 
+        gemv("N", this->m, mat.ColsInMemory(), one, mat.Entries(), 
+             this->m, &v[mat.FirstIndex()], 1, zero, t, 1);
+        axpy(this->m, one, t, 1, w, 1); 
       }
       delete[] t;
 
@@ -319,7 +320,7 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
   }
   else {
 
-    gemv("N", m, n, one, A, m, v, 1, zero, w, 1);
+    gemv("N", this->m, this->n, one, A, this->m, v, 1, zero, w, 1);
 
   }
 
@@ -340,7 +341,7 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARdsNonSymMatrix::MultMtv");
   }
 
@@ -348,15 +349,15 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
 
   if (mat.IsOutOfCore()) {
 
-    if (m<=n) { 
+    if (this->m<=this->n) { 
 
       // Matrix is "fat".
 
       mat.Rewind();
       for (i=0; i<mat.NBlocks(); i++) {
         mat.ReadBlock();
-        gemv("T", m, mat.ColsInMemory(), one, mat.Entries(), 
-             m, v, 1, zero, &w[mat.FirstIndex()], 1);
+        gemv("T", this->m, mat.ColsInMemory(), one, mat.Entries(), 
+             this->m, v, 1, zero, &w[mat.FirstIndex()], 1);
       }
 
     }
@@ -366,10 +367,10 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
 
       mat.Rewind();
       t = new ARTYPE[mat.ColsInMemory()];
-      for (i=0; i<m; i++) w[i] = zero;
+      for (i=0; i<this->m; i++) w[i] = zero;
       for (i=0; i<mat.NBlocks(); i++) {
         mat.ReadBlock();
-        gemv("T", mat.RowsInMemory(), n, one, mat.Entries(), 
+        gemv("T", mat.RowsInMemory(), this->n, one, mat.Entries(), 
              mat.RowsInMemory(), &v[mat.FirstIndex()], 1, zero, t, 1);
         axpy(mat.RowsInMemory(), one, t, 1, w, 1); 
       }
@@ -380,7 +381,7 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
   }
   else {
 
-    gemv("T", m, n, one, A, m, v, 1, zero, w, 1);
+    gemv("T", this->m, this->n, one, A, this->m, v, 1, zero, w, 1);
 
   }
 
@@ -400,22 +401,22 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
   one  = (ARTYPE)0 + 1.0;
   zero = (ARTYPE)0;
 
-  if (mat.IsOutOfCore() && (m>n)) {
+  if (mat.IsOutOfCore() && (this->m>this->n)) {
 
     // Special code for "tall" matrices.
 
     t = new ARTYPE[mat.BlockSize()];
-    s = new ARTYPE[n];
+    s = new ARTYPE[this->n];
 
     mat.Rewind();
-    for (i=0; i<n; i++) w[i] = zero;
+    for (i=0; i<this->n; i++) w[i] = zero;
     for (i=0; i<mat.NBlocks(); i++) {
       mat.ReadBlock();
-      gemv("N", mat.RowsInMemory(), n, one, mat.Entries(), 
+      gemv("N", mat.RowsInMemory(), this->n, one, mat.Entries(), 
            mat.RowsInMemory(), v, 1, zero, t, 1);
-      gemv("T", mat.RowsInMemory(), n, one, mat.Entries(), 
+      gemv("T", mat.RowsInMemory(), this->n, one, mat.Entries(), 
            mat.RowsInMemory(), t, 1, zero, s, 1);
-      axpy(n, one, s, 1, w, 1); 
+      axpy(this->n, one, s, 1, w, 1); 
 
     }
 
@@ -425,7 +426,7 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
   }
   else {
 
-    t = new ARTYPE[m];
+    t = new ARTYPE[this->m];
 
     MultMv(v,t);
     MultMtv(t,w);
@@ -450,22 +451,22 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
   one  = (ARTYPE)0 + 1.0;
   zero = (ARTYPE)0;
 
-  if (mat.IsOutOfCore() && (m<=n)) {
+  if (mat.IsOutOfCore() && (this->m<=this->n)) {
 
     // Special code for "fat" matrices.
 
     t = new ARTYPE[mat.BlockSize()];
-    s = new ARTYPE[m];
+    s = new ARTYPE[this->m];
 
     mat.Rewind();
-    for (i=0; i<m; i++) w[i] = zero;
+    for (i=0; i<this->m; i++) w[i] = zero;
     for (i=0; i<mat.NBlocks(); i++) {
       mat.ReadBlock();
-      gemv("T", m, mat.ColsInMemory(), one, mat.Entries(), 
-           m, v, 1, zero, t, 1);
-      gemv("N", m, mat.ColsInMemory(), one, mat.Entries(), 
-           m, t, 1, zero, s, 1);
-      axpy(m, one, s, 1, w, 1); 
+      gemv("T", this->m, mat.ColsInMemory(), one, mat.Entries(), 
+           this->m, v, 1, zero, t, 1);
+      gemv("N", this->m, mat.ColsInMemory(), one, mat.Entries(), 
+           this->m, t, 1, zero, s, 1);
+      axpy(this->m, one, s, 1, w, 1); 
 
     }
 
@@ -475,7 +476,7 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
   }
   else {
 
-    t = new ARTYPE[n];
+    t = new ARTYPE[this->n];
 
     MultMtv(v,t);
     MultMv(t,w);
@@ -491,8 +492,8 @@ template<class ARTYPE, class ARFLOAT>
 void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::Mult0MMt0v(ARTYPE* v, ARTYPE* w)
 {
 
-  MultMv(&v[m],w);
-  MultMtv(v,&w[m]);
+  MultMv(&v[this->m],w);
+  MultMtv(v,&w[this->m]);
 
 } // Mult0MMt0v.
 
@@ -510,11 +511,11 @@ void ARdsNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Overwritting w with v.
 
-  copy(n, v, 1, w, 1);
+  copy(this->n, v, 1, w, 1);
 
   // Solving A.w = v (or AsI.w = v).
 
-  getrs("N", n, 1, Ainv, m, ipiv, w, m, info);
+  getrs("N", this->n, 1, Ainv, this->m, ipiv, w, this->m, info);
 
   // Handling errors.
 
@@ -530,10 +531,10 @@ DefineMatrix(int np, ARTYPE* Ap)
 
   // Defining member variables.
 
-  n         = np;
-  m         = np;
+  this->n         = np;
+  this->m         = np;
   A         = Ap;
-  defined   = true;
+  this->defined   = true;
   Ainv      = NULL;
   ipiv      = NULL;
   info      = 0; 
@@ -548,10 +549,10 @@ DefineMatrix(int mp, int np, ARTYPE* Ap)
 
   // Defining member variables.
 
-  m         = mp;
-  n         = np;
+  this->m         = mp;
+  this->n         = np;
   A         = Ap;
-  defined   = true;
+  this->defined   = true;
   Ainv      = NULL;
   ipiv      = NULL;
   info      = 0;
diff -rupN arpack++1.2.orig/include/ardscomp.h arpack++1.2.patched/include/ardscomp.h
--- arpack++1.2.orig/include/ardscomp.h	2000-02-21 00:22:42.000000000 +0100
+++ arpack++1.2.patched/include/ardscomp.h	2006-01-26 15:37:49.000000000 +0100
@@ -18,7 +18,8 @@
 #ifndef ARDSCOMP_H
 #define ARDSCOMP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arscomp.h"
 #include "ardnsmat.h"
@@ -84,7 +85,7 @@ inline void ARluCompStdEig<ARFLOAT>::
 ChangeShift(arcomplex<ARFLOAT> sigmaRp)
 {
 
-  objOP->FactorAsI(sigmaRp);
+  this->objOP->FactorAsI(sigmaRp);
   ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmaRp);
 
 } // ChangeShift.
@@ -96,7 +97,7 @@ inline void ARluCompStdEig<ARFLOAT>::Set
 
   ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
            ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
-    SetRegularMode(objOP, 
+    SetRegularMode(this->objOP, 
                    &ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv);
 
 } // SetRegularMode.
@@ -109,7 +110,7 @@ SetShiftInvertMode(arcomplex<ARFLOAT> si
 
   ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
            ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
-    SetShiftInvertMode(sigmap, objOP,
+    SetShiftInvertMode(sigmap, this->objOP,
                        &ARdsNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT>::MultInvv);
 
 } // SetShiftInvertMode.
@@ -123,7 +124,7 @@ ARluCompStdEig(int nevp, ARdsNonSymMatri
 
 {
 
-  NoShift();
+  this->NoShift();
   DefineParameters(A.ncols(), nevp, &A,
                    &ARdsNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
@@ -154,7 +155,7 @@ operator=(const ARluCompStdEig<ARFLOAT>&
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/ardsmat.h arpack++1.2.patched/include/ardsmat.h
--- arpack++1.2.orig/include/ardsmat.h	2000-02-20 23:56:02.000000000 +0100
+++ arpack++1.2.patched/include/ardsmat.h	2006-01-26 15:37:49.000000000 +0100
@@ -20,7 +20,8 @@
 #ifndef ARDSMAT_H
 #define ARDSMAT_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "armat.h"
 #include "arerror.h"
@@ -110,9 +111,9 @@ Copy(const ARdsSymMatrix<ARTYPE>& other)
 
   // Copying very fundamental variables and user-defined parameters.
 
-  m         = other.m;
-  n         = other.n;
-  defined   = other.defined;
+  this->m         = other.m;
+  this->n         = other.n;
+  this->defined   = other.defined;
   factored  = other.factored;
   uplo      = other.uplo;
   info      = other.info;
@@ -124,11 +125,11 @@ Copy(const ARdsSymMatrix<ARTYPE>& other)
 
   // Copying vectors.
 
-  Ainv = new ARTYPE[(n*n+n)/2];
-  ipiv = new int[n];
+  Ainv = new ARTYPE[(this->n*this->n+this->n)/2];
+  ipiv = new int[this->n];
 
-  copy((n*n+n)/2, other.Ainv, 1, Ainv, 1);
-  for (int i=0; i<n; i++) ipiv[i] = other.ipiv[i];
+  copy((this->n*this->n+this->n)/2, other.Ainv, 1, Ainv, 1);
+  for (int i=0; i<this->n; i++) ipiv[i] = other.ipiv[i];
 
 } // Copy.
 
@@ -141,15 +142,15 @@ void ARdsSymMatrix<ARTYPE>::SubtractAsI(
 
   // Copying A to Ainv.
 
-  ::copy((n*n+n)/2 ,A, 1, Ainv, 1);
+  ::copy((this->n*this->n+this->n)/2 ,A, 1, Ainv, 1);
 
   // Subtracting sigma from diagonal elements.
 
   if (uplo=='L') {
-    for (i=0, j=0; i<n; j+=(n-(i++))) Ainv[j] -= sigma;
+    for (i=0, j=0; i<this->n; j+=(this->n-(i++))) Ainv[j] -= sigma;
   }
   else {
-    for (i=0, j=0; i<n; j+=(++i)) Ainv[j] -= sigma;
+    for (i=0, j=0; i<this->n; j+=(++i)) Ainv[j] -= sigma;
   }
 
 } // SubtractAsI.
@@ -160,8 +161,8 @@ inline void ARdsSymMatrix<ARTYPE>::Creat
 {
 
   ClearMem();
-  Ainv = new ARTYPE[(n*n+n)/2];
-  ipiv = new int[n];
+  Ainv = new ARTYPE[(this->n*this->n+this->n)/2];
+  ipiv = new int[this->n];
 
 } // CreateStructure.
 
@@ -188,7 +189,7 @@ void ARdsSymMatrix<ARTYPE>::FactorA()
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARdsSymMatrix::FactorA");
   }
 
@@ -198,11 +199,11 @@ void ARdsSymMatrix<ARTYPE>::FactorA()
 
   // Copying A to Ainv;
 
-  ::copy((n*n+n)/2 ,A, 1, Ainv, 1);
+  ::copy((this->n*this->n+this->n)/2 ,A, 1, Ainv, 1);
 
   // Decomposing A.
 
-  sptrf(&uplo, n, Ainv, ipiv, info);
+  sptrf(&uplo, this->n, Ainv, ipiv, info);
 
   // Handling errors.
 
@@ -219,7 +220,7 @@ void ARdsSymMatrix<ARTYPE>::FactorAsI(AR
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARdsSymMatrix::FactorAsI");
   }
 
@@ -233,7 +234,7 @@ void ARdsSymMatrix<ARTYPE>::FactorAsI(AR
 
   // Decomposing AsI.
 
-  sptrf(&uplo, n, Ainv, ipiv, info);
+  sptrf(&uplo, this->n, Ainv, ipiv, info);
 
   // Handling errors.
 
@@ -254,26 +255,26 @@ void ARdsSymMatrix<ARTYPE>::MultMv(ARTYP
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARdsSymMatrix::MultMv");
   }
 
   // Determining w = M.v (unfortunately, the BLAS does not 
   // have a routine that works with packed matrices).
 
-  for (i=0; i<n; i++) w[i] = zero;
+  for (i=0; i<this->n; i++) w[i] = zero;
 
   if (uplo=='L') {
  
-    for (i=0, j=0; i<n; j+=(n-(i++))) {
-      w[i] += dot(n-i, &A[j], 1, &v[i], 1);
-      axpy(n-i-1, v[i], &A[j+1], 1, &w[i+1], 1);
+    for (i=0, j=0; i<this->n; j+=(this->n-(i++))) {
+      w[i] += dot(this->n-i, &A[j], 1, &v[i], 1);
+      axpy(this->n-i-1, v[i], &A[j+1], 1, &w[i+1], 1);
     }
  
   }  
   else { // uplo = 'U'
 
-    for (i=0, j=0; i<n; j+=(++i)) {
+    for (i=0, j=0; i<this->n; j+=(++i)) {
       w[i] += dot(i+1, &A[j], 1, v, 1);
       axpy(i, v[i], &A[j], 1, w, 1);
     }
@@ -296,11 +297,11 @@ void ARdsSymMatrix<ARTYPE>::MultInvv(ART
 
   // Overwritting w with v.
 
-  copy(n, v, 1, w, 1);
+  copy(this->n, v, 1, w, 1);
 
   // Solving A.w = v (or AsI.w = v).
 
-  sptrs(&uplo, n, 1, Ainv, ipiv, w, n, info);
+  sptrs(&uplo, this->n, 1, Ainv, ipiv, w, this->n, info);
 
   // Handling errors.
 
@@ -316,11 +317,11 @@ DefineMatrix(int np, ARTYPE* Ap, char up
 
   // Defining member variables.
 
-  m         = np;
-  n         = np;
+  this->m         = np;
+  this->n         = np;
   uplo      = uplop;
   A         = Ap;
-  defined   = true;
+  this->defined   = true;
   Ainv      = NULL;
   ipiv      = NULL;
   info      = 0; 
@@ -345,7 +346,7 @@ operator=(const ARdsSymMatrix<ARTYPE>& o
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/ardsnsym.h arpack++1.2.patched/include/ardsnsym.h
--- arpack++1.2.orig/include/ardsnsym.h	2000-02-21 00:14:18.000000000 +0100
+++ arpack++1.2.patched/include/ardsnsym.h	2006-01-26 15:37:49.000000000 +0100
@@ -18,7 +18,8 @@
 #ifndef ARDSNSYM_H
 #define ARDSNSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arsnsym.h"
 #include "ardnsmat.h"
@@ -81,13 +82,13 @@ inline void ARluNonSymStdEig<ARFLOAT>::
 ChangeShift(ARFLOAT sigmaRp)
 {
 
-  sigmaR    = sigmaRp;
-  sigmaI    = 0.0;
-  mode      = 3;
-  iparam[7] = mode;
+  this->sigmaR    = sigmaRp;
+  this->sigmaI    = 0.0;
+  this->mode      = 3;
+  this->iparam[7] = this->mode;
 
-  objOP->FactorAsI(sigmaR);
-  Restart();
+  this->objOP->FactorAsI(this->sigmaR);
+  this->Restart();
 
 } // ChangeShift.
 
@@ -97,7 +98,7 @@ inline void ARluNonSymStdEig<ARFLOAT>::S
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARdsNonSymMatrix<ARFLOAT, ARFLOAT> >::
-    SetRegularMode(objOP, &ARdsNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv);
+    SetRegularMode(this->objOP, &ARdsNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv);
 
 } // SetRegularMode.
 
@@ -107,7 +108,7 @@ inline void ARluNonSymStdEig<ARFLOAT>::S
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARdsNonSymMatrix<ARFLOAT, ARFLOAT> >::
-    SetShiftInvertMode(sigmap, objOP, 
+    SetShiftInvertMode(sigmap, this->objOP, 
                        &ARdsNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv);
 
 } // SetShiftInvertMode.
@@ -121,7 +122,7 @@ ARluNonSymStdEig(int nevp, ARdsNonSymMat
 
 {
 
-  NoShift();
+  this->NoShift();
   DefineParameters(A.ncols(), nevp, &A, 
                    &ARdsNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
@@ -151,7 +152,7 @@ operator=(const ARluNonSymStdEig<ARFLOAT
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
@@ -160,4 +161,3 @@ operator=(const ARluNonSymStdEig<ARFLOAT
 
 
 #endif // ARDSNSYM_H
-
diff -rupN arpack++1.2.orig/include/ardssym.h arpack++1.2.patched/include/ardssym.h
--- arpack++1.2.orig/include/ardssym.h	2000-02-21 00:09:40.000000000 +0100
+++ arpack++1.2.patched/include/ardssym.h	2006-01-26 15:37:49.000000000 +0100
@@ -18,7 +18,8 @@
 #ifndef ARDSSYM_H
 #define ARDSSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arssym.h"
 #include "ardsmat.h"
@@ -81,13 +82,13 @@ inline void ARluSymStdEig<ARFLOAT>::
 ChangeShift(ARFLOAT sigmaRp)
 {
 
-  sigmaR    = sigmaRp;
-  sigmaI    = 0.0;
-  mode      = 3;
-  iparam[7] = mode;
+  this->sigmaR    = sigmaRp;
+  this->sigmaI    = 0.0;
+  this->mode      = 3;
+  this->iparam[7] = this->mode;
 
-  objOP->FactorAsI(sigmaR);
-  Restart();
+  this->objOP->FactorAsI(this->sigmaR);
+  this->Restart();
 
 } // ChangeShift.
 
@@ -97,7 +98,7 @@ inline void ARluSymStdEig<ARFLOAT>::SetR
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARdsSymMatrix<ARFLOAT> >::
-    SetRegularMode(objOP, &ARdsSymMatrix<ARFLOAT>::MultMv);
+    SetRegularMode(this->objOP, &ARdsSymMatrix<ARFLOAT>::MultMv);
 
 } // SetRegularMode.
 
@@ -107,7 +108,7 @@ inline void ARluSymStdEig<ARFLOAT>::SetS
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARdsSymMatrix<ARFLOAT> >::
-    SetShiftInvertMode(sigmap, objOP, &ARdsSymMatrix<ARFLOAT>::MultInvv);
+    SetShiftInvertMode(sigmap, this->objOP, &ARdsSymMatrix<ARFLOAT>::MultInvv);
 
 } // SetShiftInvertMode.
 
@@ -119,7 +120,7 @@ ARluSymStdEig(int nevp, ARdsSymMatrix<AR
               int maxitp, ARFLOAT* residp, bool ishiftp)
 {
 
-  NoShift();
+  this->NoShift();
   DefineParameters(A.ncols(), nevp, &A, &ARdsSymMatrix<ARFLOAT>::MultMv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
@@ -147,7 +148,7 @@ operator=(const ARluSymStdEig<ARFLOAT>& 
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
@@ -156,4 +157,3 @@ operator=(const ARluSymStdEig<ARFLOAT>& 
 
 
 #endif // ARDSSYM_H
-
diff -rupN arpack++1.2.orig/include/arerror.h arpack++1.2.patched/include/arerror.h
--- arpack++1.2.orig/include/arerror.h	2000-03-01 19:59:37.000000000 +0100
+++ arpack++1.2.patched/include/arerror.h	2006-01-26 15:37:49.000000000 +0100
@@ -29,9 +29,10 @@
 #ifndef ARERROR_H
 #define ARERROR_H
 
+#include <iostream>
+#include <cstdlib>
+
 #include "arch.h"
-#include <iostream.h>
-#include <stdlib.h>
 
 class ArpackError {
 
@@ -151,8 +152,8 @@ inline void ArpackError::Print(const cha
 {
 
 #ifndef ARPACK_SILENT_MODE
-  cerr << "Arpack error in " << where << "." << endl;
-  cerr << "-> " << message << "." << endl;
+  std::cerr << "Arpack error in " << where << "." << std::endl;
+  std::cerr << "-> " << message << "." << std::endl;
 #endif
 
 } // Print
diff -rupN arpack++1.2.orig/include/argcomp.h arpack++1.2.patched/include/argcomp.h
--- arpack++1.2.orig/include/argcomp.h	2000-02-21 00:49:24.000000000 +0100
+++ arpack++1.2.patched/include/argcomp.h	2006-01-26 15:37:50.000000000 +0100
@@ -17,7 +17,8 @@
 #ifndef ARGCOMP_H
 #define ARGCOMP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arscomp.h"
 #include "argeig.h"
@@ -83,7 +84,7 @@ ARCompGenEig(int np, int nevp, ARFOP* ob
 
 {
 
-  NoShift();
+  this->NoShift();
   DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
@@ -114,7 +115,7 @@ operator=(const ARCompGenEig<ARFLOAT, AR
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
@@ -123,4 +124,3 @@ operator=(const ARCompGenEig<ARFLOAT, AR
 
 
 #endif // ARGCOMP_H
-
diff -rupN arpack++1.2.orig/include/argeig.h arpack++1.2.patched/include/argeig.h
--- arpack++1.2.orig/include/argeig.h	2000-02-21 00:39:06.000000000 +0100
+++ arpack++1.2.patched/include/argeig.h	2006-01-26 15:37:50.000000000 +0100
@@ -19,7 +19,8 @@
 #ifndef ARGEIG_H
 #define ARGEIG_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arerror.h"
 #include "arrgeig.h"
@@ -149,7 +150,7 @@ ChangeMultBx(ARFB* objBp, void (ARFB::* 
 
   objB   = objBp;
   MultBx = MultBxp;
-  Restart();
+  this->Restart();
 
 } // ChangeMultBx.
 
@@ -158,46 +159,46 @@ template<class ARFLOAT, class ARTYPE, cl
 int ARGenEig<ARFLOAT, ARTYPE, ARFOP, ARFB>::FindArnoldiBasis()
 {
 
-  if (!BasisOK) Restart();
+  if (!this->BasisOK) this->Restart();
 
   // Changing to auto shift mode.
 
-  if (!AutoShift) {
+  if (!this->AutoShift) {
     ArpackError::Set(ArpackError::CHANGING_AUTOSHIFT, "FindArnoldiBasis");
-    AutoShift=true;
+    this->AutoShift=true;
   }
 
   // ARPACK main loop.
 
-  while (!BasisOK) {
+  while (!this->BasisOK) {
 
     // Calling Aupp.
 
-    try { TakeStep(); }
+    try { this->TakeStep(); }
     catch (ArpackError) {
       ArpackError(ArpackError::CANNOT_FIND_BASIS, "FindArnoldiBasis");
       return 0;
     }
 
-    switch (ido) {
+    switch (this->ido) {
     case -1:
 
       // Performing y <- OP*B*x for the first time when mode != 2.
 
-      if (mode != 2) {
-        ipntr[3] = ipntr[2]+n; // not a clever idea, but...
-        (objB->*MultBx)(&workd[ipntr[1]],&workd[ipntr[3]]);
+      if (this->mode != 2) {
+        this->ipntr[3] = this->ipntr[2]+this->n; // not a clever idea, but...
+        (this->objB->*MultBx)(&this->workd[this->ipntr[1]],&this->workd[this->ipntr[3]]);
       }
 
     case  1:
 
       // Performing y <- OP*w.
 
-      if (mode == 2) { // w = x if mode = 2.
-        (objOP->*MultOPx)(&workd[ipntr[1]],&workd[ipntr[2]]);
+      if (this->mode == 2) { // w = x if mode = 2.
+        (this->objOP->*(this->MultOPx))(&this->workd[this->ipntr[1]],&this->workd[this->ipntr[2]]);
       }
       else {           // w = B*x otherwise.
-        (objOP->*MultOPx)(&workd[ipntr[3]],&workd[ipntr[2]]);
+        (this->objOP->*(this->MultOPx))(&this->workd[this->ipntr[3]],&this->workd[this->ipntr[2]]);
       }
       break;
 
@@ -205,11 +206,11 @@ int ARGenEig<ARFLOAT, ARTYPE, ARFOP, ARF
 
       // Performing y <- B*x.
 
-      (objB->*MultBx)(&workd[ipntr[1]],&workd[ipntr[2]]);
+      (this->objB->*MultBx)(&this->workd[this->ipntr[1]],&this->workd[this->ipntr[2]]);
 
     }
   }
-  return nconv;
+  return this->nconv;
 
 } // FindArnoldiBasis.
 
@@ -220,7 +221,7 @@ operator=(const ARGenEig<ARFLOAT, ARTYPE
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/argnsym.h arpack++1.2.patched/include/argnsym.h
--- arpack++1.2.orig/include/argnsym.h	2000-02-21 19:21:34.000000000 +0100
+++ arpack++1.2.patched/include/argnsym.h	2006-01-26 15:48:23.000000000 +0100
@@ -17,7 +17,8 @@
 #ifndef ARGNSYM_H
 #define ARGNSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "blas1c.h"
 #include "lapackc.h"
@@ -94,7 +95,7 @@ class ARNonSymGenEig:
 
  // d.3) Constructors and destructor.
 
-  ARNonSymGenEig() { part = 'R'; }
+  ARNonSymGenEig() { this->part = 'R'; }
   // Short constructor (Does nothing but calling base classes constructors).
 
   ARNonSymGenEig(int np, int nevp, ARFOP* objOPp,
@@ -148,7 +149,7 @@ Copy(const ARNonSymGenEig<ARFLOAT, ARFOP
   ARGenEig<ARFLOAT, ARFLOAT, ARFOP, ARFB>::Copy(other);
   objA   = other.objA;
   MultAx = other.MultAx;
-  part   = other.part;
+  this->part   = other.part;
 
 } // Copy.
 
@@ -161,22 +162,22 @@ void ARNonSymGenEig<ARFLOAT, ARFOP, ARFB
   ARFLOAT  numr, numi, denr, deni;
   ARFLOAT* Ax;
 
-  Ax = new ARFLOAT[n];
+  Ax = new ARFLOAT[this->n];
 
-  for (j=0; j<nconv; j++) {
+  for (j=0; j<this->nconv; j++) {
 
-    ColJ   = j*n;
-    ColJp1 = ColJ+n;
+    ColJ   = j*this->n;
+    ColJp1 = ColJ+this->n;
 
-    if (EigValI[j] == (ARFLOAT)0.0) {
+    if (this->EigValI[j] == (ARFLOAT)0.0) {
 
       // Eigenvalue is real. Computing EigVal = x'(Ax)/x'(Mx).
 
-      (objB->*MultAx)(&EigVec[ColJ], Ax);
-      numr = dot(n, &EigVec[ColJ], 1, Ax, 1);
-      (objB->*MultBx)(&EigVec[ColJ], Ax);
-      denr = dot(n, &EigVec[ColJ], 1, Ax, 1);
-      EigValR[j] =  numr / denr;
+      (this->objB->*MultAx)(&this->EigVec[ColJ], Ax);
+      numr = dot(this->n, &this->EigVec[ColJ], 1, Ax, 1);
+      (this->objB->*(this->MultBx))(&this->EigVec[ColJ], Ax);
+      denr = dot(this->n, &this->EigVec[ColJ], 1, Ax, 1);
+      this->EigValR[j] =  numr / denr;
 
     }
     else {
@@ -185,32 +186,32 @@ void ARNonSymGenEig<ARFLOAT, ARFOP, ARFB
 
       // Computing x'(Ax).
 
-      (objB->*MultAx)(&EigVec[ColJ], Ax);
-      numr = dot(n, &EigVec[ColJ], 1, Ax, 1);
-      numi = dot(n, &EigVec[ColJp1], 1, Ax, 1);
-      (objB->*MultAx)(&EigVec[ColJp1], Ax);
-      numr = numr + dot(n, &EigVec[ColJp1], 1, Ax, 1);
-      numi = -numi + dot(n, &EigVec[ColJ], 1, Ax, 1);
+      (this->objB->*MultAx)(&this->EigVec[ColJ], Ax);
+      numr = dot(this->n, &this->EigVec[ColJ], 1, Ax, 1);
+      numi = dot(this->n, &this->EigVec[ColJp1], 1, Ax, 1);
+      (this->objB->*MultAx)(&this->EigVec[ColJp1], Ax);
+      numr = numr + dot(this->n, &this->EigVec[ColJp1], 1, Ax, 1);
+      numi = -numi + dot(this->n, &this->EigVec[ColJ], 1, Ax, 1);
 
       // Computing x'(Mx).
 
-      (objB->*MultBx)(&EigVec[ColJ], Ax);
-      denr = dot(n, &EigVec[ColJ], 1, Ax, 1);
-      deni = dot(n, &EigVec[ColJp1], 1, Ax, 1);
-      (objB->*MultBx)(&EigVec[ColJp1], Ax);
-      denr = denr + dot(n, &EigVec[ColJp1], 1, Ax, 1);
-      deni = -deni + dot(n, &EigVec[ColJ], 1, Ax, 1);
+      (this->objB->*(this->MultBx))(&this->EigVec[ColJ], Ax);
+      denr = dot(this->n, &this->EigVec[ColJ], 1, Ax, 1);
+      deni = dot(this->n, &this->EigVec[ColJp1], 1, Ax, 1);
+      (this->objB->*(this->MultBx))(&this->EigVec[ColJp1], Ax);
+      denr = denr + dot(this->n, &this->EigVec[ColJp1], 1, Ax, 1);
+      deni = -deni + dot(this->n, &this->EigVec[ColJ], 1, Ax, 1);
 
       // Computing the first eigenvalue of the conjugate pair.
 
-      EigValR[j] = (numr*denr+numi*deni) / lapy2(denr, deni);
-      EigValI[j] = (numi*denr-numr*deni) / lapy2(denr, deni);
+      this->EigValR[j] = (numr*denr+numi*deni) / lapy2(denr, deni);
+      this->EigValI[j] = (numi*denr-numr*deni) / lapy2(denr, deni);
 
       // Getting the second eigenvalue of the conjugate pair by taking
       // the conjugate of the first.
 
-      EigValR[j+1] = EigValR[j];
-      EigValI[j+1] = -EigValI[j];
+      this->EigValR[j+1] = this->EigValR[j];
+      this->EigValI[j+1] = -this->EigValI[j];
       j++;
 
     }
@@ -228,9 +229,9 @@ SetShiftInvertMode(ARFLOAT sigmaRp, ARFO
                    void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]))
 {
 
-  part    = 'R';
-  objOP   = objOPp;
-  MultOPx = MultOPxp;
+  this->part    = 'R';
+  this->objOP   = objOPp;
+  this->MultOPx = MultOPxp;
   ChangeShift(sigmaRp);
 
 } // SetShiftInvertMode.
@@ -244,11 +245,11 @@ SetComplexShiftMode(char partp, ARFLOAT 
                     ARFB* objAp, void (ARFB::* MultAxp)(ARFLOAT[], ARFLOAT[]))
 {
 
-  objOP   = objOPp;
-  MultOPx = MultOPxp;
+  this->objOP   = objOPp;
+  this->MultOPx = MultOPxp;
   objA    = objAp;
   MultAx  = MultAxp;
-  part    = CheckPart(partp);
+  this->part    = this->CheckPart(partp);
   ChangeShift(sigmaRp, sigmaIp);
 
 } // SetComplexShiftMode.
@@ -258,9 +259,9 @@ template<class ARFLOAT, class ARFOP, cla
 inline int ARNonSymGenEig<ARFLOAT, ARFOP, ARFB>::FindEigenvalues()
 {
 
-  nconv = ARStdEig<ARFLOAT, ARFLOAT, ARFOP>::FindEigenvalues();
-  if (sigmaI != 0.0) RecoverEigenvalues();
-  return nconv;
+  this->nconv = ARStdEig<ARFLOAT, ARFLOAT, ARFOP>::FindEigenvalues();
+  if (this->sigmaI != 0.0) RecoverEigenvalues();
+  return this->nconv;
 
 } // FindEigenvalues.
 
@@ -269,9 +270,9 @@ template<class ARFLOAT, class ARFOP, cla
 inline int ARNonSymGenEig<ARFLOAT, ARFOP, ARFB>::FindEigenvectors(bool schurp)
 {
 
-  nconv = ARStdEig<ARFLOAT, ARFLOAT, ARFOP>::FindEigenvectors(schurp);
-  if (sigmaI != 0.0) RecoverEigenvalues();
-  return nconv;
+  this->nconv = ARStdEig<ARFLOAT, ARFLOAT, ARFOP>::FindEigenvectors(schurp);
+  if (this->sigmaI != 0.0) RecoverEigenvalues();
+  return this->nconv;
 
 } // FindEigenvectors.
 
@@ -280,9 +281,9 @@ template<class ARFLOAT, class ARFOP, cla
 int ARNonSymGenEig<ARFLOAT, ARFOP, ARFB>::FindSchurVectors()
 {
 
-  nconv = ARStdEig<ARFLOAT, ARFLOAT, ARFOP>::FindSchurVectors();
-  if (sigmaI != 0.0) RecoverEigenvalues();
-  return nconv;
+  this->nconv = ARStdEig<ARFLOAT, ARFLOAT, ARFOP>::FindSchurVectors();
+  if (this->sigmaI != 0.0) RecoverEigenvalues();
+  return this->nconv;
 
 } // FindSchurVectors.
 
@@ -297,8 +298,8 @@ ARNonSymGenEig(int np, int nevp, ARFOP* 
 
 {
 
-  part = 'R';                // Considering mode = 3 in ChangeShift.
-  NoShift();
+  this->part = 'R';                // Considering mode = 3 in ChangeShift.
+  this->NoShift();
   DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
@@ -349,7 +350,7 @@ operator=(const ARNonSymGenEig<ARFLOAT, 
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/argsym.h arpack++1.2.patched/include/argsym.h
--- arpack++1.2.orig/include/argsym.h	2000-02-21 19:22:35.000000000 +0100
+++ arpack++1.2.patched/include/argsym.h	2006-01-26 15:37:50.000000000 +0100
@@ -17,7 +17,8 @@
 #ifndef ARGSYM_H
 #define ARGSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arssym.h"
 #include "arrgsym.h"
@@ -79,7 +80,7 @@ class ARSymGenEig:
 
  // d.3) Constructors and destructor.
 
-  ARSymGenEig() { InvertMode = 'S'; }
+  ARSymGenEig() { this->InvertMode = 'S'; }
   // Short constructor that does almost nothing.
 
   ARSymGenEig(int np, int nevp, ARFOP* objOPp,
@@ -132,7 +133,7 @@ Copy(const ARSymGenEig<ARFLOAT, ARFOP, A
   ARGenEig<ARFLOAT, ARFLOAT, ARFOP, ARFB>::Copy(other);
   objA       = other.objA;
   MultAx     = other.MultAx;
-  InvertMode = other.InvertMode;
+  this->InvertMode = other.InvertMode;
 
 } // Copy.
 
@@ -143,9 +144,9 @@ SetShiftInvertMode(ARFLOAT sigmap, ARFOP
                    void (ARFOP::* MultOPxp)(ARFLOAT[], ARFLOAT[]))
 {
 
-  InvertMode = 'S';
-  objOP      = objOPp;
-  MultOPx    = MultOPxp;
+  this->InvertMode = 'S';
+  this->objOP      = objOPp;
+  this->MultOPx    = MultOPxp;
   ChangeShift(sigmap);
 
 } // SetShiftInvertMode.
@@ -158,9 +159,9 @@ SetBucklingMode(ARFLOAT sigmap, ARFOP* o
 
 {
 
-  InvertMode = 'B';
-  objOP      = objOPp;
-  MultOPx    = MultOPxp;
+  this->InvertMode = 'B';
+  this->objOP      = objOPp;
+  this->MultOPx    = MultOPxp;
   ChangeShift(sigmap);
 
 } // SetBucklingMode.
@@ -174,9 +175,9 @@ SetCayleyMode(ARFLOAT sigmap, ARFOP* obj
 
 {
 
-  InvertMode = 'C';
-  objOP      = objOPp;
-  MultOPx    = MultOPxp;
+  this->InvertMode = 'C';
+  this->objOP      = objOPp;
+  this->MultOPx    = MultOPxp;
   objA       = objAp;
   MultAx     = MultAxp;
   ChangeShift(sigmap);
@@ -190,64 +191,64 @@ int ARSymGenEig<ARFLOAT, ARFOP, ARFB>::F
 
   ARFLOAT* temp;
 
-  if (mode != 5) {  // Using base function if not in Cayley mode.
+  if (this->mode != 5) {  // Using base function if not in Cayley mode.
     return ARGenEig<ARFLOAT, ARFLOAT, ARFOP, ARFB>::FindArnoldiBasis();
   }
   else {
 
-    temp = new ARFLOAT[n+1];
+    temp = new ARFLOAT[this->n+1];
 
-    if (!BasisOK) Restart();
+    if (!this->BasisOK) this->Restart();
 
     // Changing to auto shift mode.
 
-    if (!AutoShift) {
+    if (!this->AutoShift) {
       ArpackError::Set(ArpackError::CHANGING_AUTOSHIFT, "FindArnoldiBasis");
-      AutoShift=true;
+      this->AutoShift=true;
     }
 
     // ARPACK main loop.
 
-    while (!BasisOK) {
+    while (!this->BasisOK) {
 
       // Calling Aupp.
 
-      try { TakeStep(); }
+      try { this->TakeStep(); }
       catch (ArpackError) {
         ArpackError(ArpackError::CANNOT_FIND_BASIS, "FindArnoldiBasis");
         delete[] temp;
         return 0;
       }
 
-      switch (ido) {
+      switch (this->ido) {
       case -1:
 
         // Performing y <- B*x for the first time.
 
-        ipntr[3] = ipntr[2]+n; // not a clever idea, but...
-        (objB->*MultBx)(&workd[ipntr[1]],&workd[ipntr[3]]);
+        this->ipntr[3] = this->ipntr[2]+this->n; // not a clever idea, but...
+        (this->objB->*(this->MultBx))(&this->workd[this->ipntr[1]],&this->workd[this->ipntr[3]]);
 
       case  1:
 
         // Performing y <- OP*(A+sigma*B)*x, B*x is already available.
 
-        (objB->*MultAx)(&workd[ipntr[1]], temp);
-        axpy(n, sigmaR, &workd[ipntr[3]], 1, temp, 1);
-        (objOP->*MultOPx)(temp, &workd[ipntr[2]]);
+        (this->objB->*MultAx)(&this->workd[this->ipntr[1]], temp);
+        axpy(this->n, this->sigmaR, &this->workd[this->ipntr[3]], 1, temp, 1);
+        (this->objOP->*(this->MultOPx))(temp, &this->workd[this->ipntr[2]]);
         break;
 
       case  2:
 
         // Performing y <- B*x.
 
-        (objB->*MultBx)(&workd[ipntr[1]],&workd[ipntr[2]]);
+        (this->objB->*(this->MultBx))(&this->workd[this->ipntr[1]],&this->workd[this->ipntr[2]]);
 
       }
     }
 
     delete[] temp;
    
-    return nconv;
+    return this->nconv;
   }
 
 } // FindArnoldiBasis.
@@ -263,8 +264,8 @@ ARSymGenEig(int np, int nevp, ARFOP* obj
 
 {
 
-  InvertMode = 'S';   
-  NoShift();
+  this->InvertMode = 'S';   
+  this->NoShift();
   DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
@@ -281,7 +282,7 @@ ARSymGenEig(char InvertModep, int np, in
 
 {
 
-  InvertMode = CheckInvertMode(InvertModep); // InvertMode = 'S' or 'B'.
+  this->InvertMode = this->CheckInvertMode(InvertModep); // InvertMode = 'S' or 'B'.
   ChangeShift(sigmap);
   DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
@@ -300,7 +301,7 @@ ARSymGenEig(int np, int nevp, ARFOP* obj
 
 {
 
-  SetCayleyMode(sigmap, objOPp, MultOPx, objAp, MultAxp);
+  SetCayleyMode(sigmap, objOPp, this->MultOPx, objAp, MultAxp);
   DefineParameters(np, nevp, objOPp, MultOPxp, objBp, MultBxp,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
@@ -313,7 +314,7 @@ operator=(const ARSymGenEig<ARFLOAT, ARF
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arhbmat.h arpack++1.2.patched/include/arhbmat.h
--- arpack++1.2.orig/include/arhbmat.h	2000-02-21 19:37:14.000000000 +0100
+++ arpack++1.2.patched/include/arhbmat.h	2006-01-26 15:37:50.000000000 +0100
@@ -20,10 +20,11 @@
 #ifndef ARHBMAT_H
 #define ARHBMAT_H
 
-#include <stddef.h>
-#include <fstream.h>
-#include <stdlib.h>
-#include <string.h>
+#include <cstddef>
+#include <fstream>
+#include <cstdlib>
+#include <cstring>
+
 #include "arch.h"
 #include "arerror.h"
 
@@ -46,17 +47,17 @@ class ARhbMatrix {
 
   void ConvertDouble(char* num);
 
-  bool ReadEntry(ifstream& file, int nval, int fval, int& j, double& val);
+  bool ReadEntry(std::ifstream& file, int nval, int fval, int& j, double& val);
 
-  bool ReadEntry(ifstream& file, int nval, int fval, int& j, float& val);
+  bool ReadEntry(std::ifstream& file, int nval, int fval, int& j, float& val);
 
-  bool ReadEntry(ifstream& file, int nval, int fval,
+  bool ReadEntry(std::ifstream& file, int nval, int fval,
                  int& j, arcomplex<double>& val);
 
-  bool ReadEntry(ifstream& file, int nval, int fval,
+  bool ReadEntry(std::ifstream& file, int nval, int fval,
                  int& j, arcomplex<float>& val);
 
-  void ReadFormat(ifstream& file, int& n, int& fmt);
+  void ReadFormat(std::ifstream& file, int& n, int& fmt);
 
  public:
 
@@ -131,7 +132,7 @@ inline void ARhbMatrix<ARINT, ARTYPE>::C
 
 template<class ARINT, class ARTYPE>
 inline bool ARhbMatrix<ARINT, ARTYPE>::
-ReadEntry(ifstream& file, int nval, int fval, int& j, double& val)
+ReadEntry(std::ifstream& file, int nval, int fval, int& j, double& val)
 {
 
   char num[81];
@@ -152,7 +153,7 @@ ReadEntry(ifstream& file, int nval, int 
 
 template<class ARINT, class ARTYPE>
 inline bool ARhbMatrix<ARINT, ARTYPE>::
-ReadEntry(ifstream& file, int nval, int fval, int& j, float& val)
+ReadEntry(std::ifstream& file, int nval, int fval, int& j, float& val)
 {
 
   double dval;
@@ -167,7 +168,7 @@ ReadEntry(ifstream& file, int nval, int 
 
 template<class ARINT, class ARTYPE>
 inline bool ARhbMatrix<ARINT, ARTYPE>::
-ReadEntry(ifstream& file, int nval, int fval,
+ReadEntry(std::ifstream& file, int nval, int fval,
           int& j, arcomplex<double>& val)
 {
 
@@ -196,7 +197,7 @@ ReadEntry(ifstream& file, int nval, int 
 
 template<class ARINT, class ARTYPE>
 inline bool ARhbMatrix<ARINT, ARTYPE>::
-ReadEntry(ifstream& file, int nval, int fval,
+ReadEntry(std::ifstream& file, int nval, int fval,
           int& j, arcomplex<float>& val)
 {
 
@@ -227,7 +228,7 @@ ReadEntry(ifstream& file, int nval, int 
 
 
 template<class ARINT, class ARTYPE>
-void ARhbMatrix<ARINT, ARTYPE>::ReadFormat(ifstream& file, int& n, int& fmt)
+void ARhbMatrix<ARINT, ARTYPE>::ReadFormat(std::ifstream& file, int& n, int& fmt)
 {
 
   char c;
@@ -267,7 +268,7 @@ void ARhbMatrix<ARINT, ARTYPE>::Define(c
   // Opening file.
 
   datafile = filename;
-  ifstream file(datafile);
+  std::ifstream file(datafile);
   
   if (!file) {
     throw ArpackError(ArpackError::CANNOT_OPEN_FILE, "ARhbMatrix");
diff -rupN arpack++1.2.orig/include/arlgcomp.h arpack++1.2.patched/include/arlgcomp.h
--- arpack++1.2.orig/include/arlgcomp.h	2000-02-21 01:31:04.000000000 +0100
+++ arpack++1.2.patched/include/arlgcomp.h	2006-01-26 15:37:50.000000000 +0100
@@ -18,7 +18,8 @@
 #ifndef ARLGCOMP_H
 #define ARLGCOMP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arlnsmat.h"
 #include "arlnspen.h"
@@ -103,9 +104,9 @@ Copy(const ARluCompGenEig<ARFLOAT>& othe
   ARCompGenEig<ARFLOAT, ARluNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT >,
                ARluNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT> >:: Copy(other);
   Pencil = other.Pencil;
-  objOP  = &Pencil;
-  objB   = &Pencil;
-  if (mode > 2) objOP->FactorAsB(sigmaR);
+  this->objOP  = &Pencil;
+  this->objB   = &Pencil;
+  if (this->mode > 2) this->objOP->FactorAsB(this->sigmaR);
 
 } // Copy.
 
@@ -114,7 +115,7 @@ template<class ARFLOAT>
 inline void ARluCompGenEig<ARFLOAT>::ChangeShift(arcomplex<ARFLOAT> sigmap)
 {
 
-  objOP->FactorAsB(sigmap);
+  this->objOP->FactorAsB(sigmap);
   ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmap);
 
 } // ChangeShift.
@@ -155,7 +156,7 @@ ARluCompGenEig(int nevp, ARluNonSymMatri
 {
 
   Pencil.DefineMatrices(A, B);
-  NoShift();
+  this->NoShift();
   DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARluNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvBAv,
                    &Pencil, 
@@ -192,7 +193,7 @@ operator=(const ARluCompGenEig<ARFLOAT>&
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arlgnsym.h arpack++1.2.patched/include/arlgnsym.h
--- arpack++1.2.orig/include/arlgnsym.h	2000-02-21 01:25:52.000000000 +0100
+++ arpack++1.2.patched/include/arlgnsym.h	2006-01-26 15:37:50.000000000 +0100
@@ -18,7 +18,8 @@
 #ifndef ARLGNSYM_H
 #define ARLGNSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arlnsmat.h"
 #include "arlnspen.h"
@@ -110,15 +111,15 @@ Copy(const ARluNonSymGenEig<ARFLOAT>& ot
   ARNonSymGenEig<ARFLOAT, ARluNonSymPencil<ARFLOAT, ARFLOAT>,
                  ARluNonSymPencil<ARFLOAT, ARFLOAT> >:: Copy(other);
   Pencil = other.Pencil;
-  objOP  = &Pencil;
-  objB   = &Pencil;
-  objA   = &Pencil;
-  if (mode > 2) {
-    if (sigmaI == 0.0) {
-      objOP->FactorAsB(sigmaR);
+  this->objOP  = &Pencil;
+  this->objB   = &Pencil;
+  this->objA   = &Pencil;
+  if (this->mode > 2) {
+    if (this->sigmaI == 0.0) {
+      this->objOP->FactorAsB(this->sigmaR);
     }
     else {
-      objOP->FactorAsB(sigmaR, sigmaI, part);
+      this->objOP->FactorAsB(this->sigmaR, this->sigmaI, this->part);
     }
   }
 
@@ -131,10 +132,10 @@ ChangeShift(ARFLOAT sigmaRp, ARFLOAT sig
 {
 
   if (sigmaIp == 0.0) {
-    objOP->FactorAsB(sigmaRp);
+    this->objOP->FactorAsB(sigmaRp);
   }
   else {
-    objOP->FactorAsB(sigmaRp, sigmaIp, part);
+    this->objOP->FactorAsB(sigmaRp, sigmaIp, this->part);
   }
   ARrcNonSymGenEig<ARFLOAT>::ChangeShift(sigmaRp, sigmaIp);
 
@@ -186,7 +187,7 @@ ARluNonSymGenEig(int nevp, ARluNonSymMat
 {
 
   Pencil.DefineMatrices(A, B);
-  NoShift();
+  this->NoShift();
   DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARluNonSymPencil<ARFLOAT, ARFLOAT>::MultInvBAv, &Pencil,
                    &ARluNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
@@ -240,7 +241,7 @@ operator=(const ARluNonSymGenEig<ARFLOAT
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arlgsym.h arpack++1.2.patched/include/arlgsym.h
--- arpack++1.2.orig/include/arlgsym.h	2000-02-21 01:20:30.000000000 +0100
+++ arpack++1.2.patched/include/arlgsym.h	2006-01-26 15:37:50.000000000 +0100
@@ -19,7 +19,8 @@
 #ifndef ARLGSYM_H
 #define ARLGSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arlsmat.h"
 #include "arlspen.h"
@@ -105,10 +106,10 @@ Copy(const ARluSymGenEig<ARFLOAT>& other
   ARSymGenEig<ARFLOAT, ARluSymPencil<ARFLOAT>,
               ARluSymPencil<ARFLOAT> >:: Copy(other);
   Pencil = other.Pencil;
-  objOP  = &Pencil;
-  objB   = &Pencil;
-  objA   = &Pencil;
-  if (mode > 2) objOP->FactorAsB(sigmaR);
+  this->objOP  = &Pencil;
+  this->objB   = &Pencil;
+  this->objA   = &Pencil;
+  if (this->mode > 2) this->objOP->FactorAsB(this->sigmaR);
 
 } // Copy.
 
@@ -117,7 +118,7 @@ template<class ARFLOAT>
 inline void ARluSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)
 {
 
-  objOP->FactorAsB(sigmap);
+  this->objOP->FactorAsB(sigmap);
   ARrcSymGenEig<ARFLOAT>::ChangeShift(sigmap);
 
 } // ChangeShift.
@@ -179,8 +180,8 @@ ARluSymGenEig(int nevp, ARluSymMatrix<AR
 {
 
   Pencil.DefineMatrices(A, B);
-  InvertMode = 'S';
-  NoShift();
+  this->InvertMode = 'S';
+  this->NoShift();
   DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARluSymPencil<ARFLOAT>::MultInvBAv, &Pencil,
                    &ARluSymPencil<ARFLOAT>::MultBv, whichp,
@@ -203,8 +204,8 @@ ARluSymGenEig(char InvertModep, int nevp
                    &ARluSymPencil<ARFLOAT>::MultInvAsBv, &Pencil,
                    &ARluSymPencil<ARFLOAT>::MultBv, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
-  InvertMode = CheckInvertMode(InvertModep);
-  switch (InvertMode) {
+  this->InvertMode = this->CheckInvertMode(InvertModep);
+  switch (this->InvertMode) {
   case 'B':  // Buckling mode.
     ChangeMultBx(&Pencil, &ARluSymPencil<ARFLOAT>::MultAv);
   case 'S':  // Shift and invert mode.
@@ -223,7 +224,7 @@ operator=(const ARluSymGenEig<ARFLOAT>& 
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arlnsmat.h arpack++1.2.patched/include/arlnsmat.h
--- arpack++1.2.orig/include/arlnsmat.h	2000-02-22 14:27:32.000000000 +0100
+++ arpack++1.2.patched/include/arlnsmat.h	2006-01-26 15:37:50.000000000 +0100
@@ -20,7 +20,8 @@
 #ifndef ARLNSMAT_H
 #define ARLNSMAT_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "armat.h"
 #include "arhbmat.h"
@@ -130,16 +131,16 @@ bool ARluNonSymMatrix<ARTYPE, ARFLOAT>::
   // Checking if pcol is in ascending order.
 
   i = 0;
-  while ((i!=n)&&(pcol[i]<=pcol[i+1])) i++;
-  if (i!=n) return false;
+  while ((i!=this->n)&&(pcol[i]<=pcol[i+1])) i++;
+  if (i!=this->n) return false;
 
   // Checking if irow components are in order and within bounds.
 
-  for (i=0; i!=n; i++) {
+  for (i=0; i!=this->n; i++) {
     j = pcol[i];
     k = pcol[i+1]-1;
     if (j<=k) {
-      if ((irow[j]<0)||(irow[k]>=n)) return false;
+      if ((irow[j]<0)||(irow[k]>=this->n)) return false;
       while ((j!=k)&&(irow[j]<irow[j+1])) j++;
       if (j!=k) return false;
     }
@@ -157,12 +158,12 @@ Copy(const ARluNonSymMatrix<ARTYPE, ARFL
 
   // Copying very fundamental variables.
 
-  defined   = other.defined;
+  this->defined   = other.defined;
   factored  = other.factored;
 
   // Returning from here if "other" was not initialized.
 
-  if (!defined) return;
+  if (!this->defined) return;
 
   // Copying user-defined parameters.
 
@@ -198,7 +199,7 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
     Destroy_CompCol_Matrix(&U);
     StatFree();
   }
-  if (defined) {
+  if (this->defined) {
     Destroy_SuperMatrix_Store(&A); // delete A.Store;
     delete[] permc;
     delete[] permr;
@@ -231,7 +232,7 @@ SubtractAsI(ARTYPE sigma, NCformat& A, N
   k = 0;
   AsI.colptr[0] = 0;
 
-  for (i=0; i!=n; i++) {
+  for (i=0; i!=this->n; i++) {
 
     j = A.colptr[i];
     end = A.colptr[i+1];
@@ -264,7 +265,7 @@ SubtractAsI(ARTYPE sigma, NCformat& A, N
 
   }
 
-  AsI.nnz = AsI.colptr[n];
+  AsI.nnz = AsI.colptr[this->n];
 
 } // SubtractAsI.
 
@@ -281,13 +282,13 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARluNonSymMatrix::FactorA");
   }
 
   // Quitting the function if A is not square.
 
-  if (m != n) {
+  if (this->m != this->n) {
     throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
                       "ARluNonSymMatrix::FactorA");
   }
@@ -308,7 +309,7 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Reserving memory for etree (used in matrix decomposition).
 
-  etree = new int[n];
+  etree = new int[this->n];
 
   // Defining LUStat.
 
@@ -342,7 +343,7 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
     throw ArpackError(ArpackError::PARAMETER_ERROR,
                       "ARluNonSymMatrix::FactorA");
   }
-  else if (info > n) {    // Memory is not sufficient.
+  else if (info > this->n) {    // Memory is not sufficient.
     throw ArpackError(ArpackError::MEMORY_OVERFLOW,
                       "ARluNonSymMatrix::FactorA");
   }
@@ -360,14 +361,14 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED,
                       "ARluNonSymMatrix::FactorAsI");
   }
 
   // Quitting the function if A is not square.
 
-  if (m != n) {
+  if (this->m != this->n) {
     throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
                       "ARluNonSymMatrix::FactorAsI");
   }
@@ -400,10 +401,10 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Creating a temporary matrix AsI.
 
-  irowi = new int[nnz+n];
-  pcoli = new int[n+1];
-  asi   = new ARTYPE[nnz+n];
-  Create_CompCol_Matrix(&AsI, n,  n, nnz, asi, irowi, pcoli, NC, GE);
+  irowi = new int[nnz+this->n];
+  pcoli = new int[this->n+1];
+  asi   = new ARTYPE[nnz+this->n];
+  Create_CompCol_Matrix(&AsI, this->n,  this->n, nnz, asi, irowi, pcoli, NC, GE);
 
   // Subtracting sigma*I from A and storing the result on AsI.
 
@@ -413,7 +414,7 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Reserving memory for etree (used in matrix decomposition).
 
-  etree = new int[n];
+  etree = new int[this->n];
 
   // Defining LUStat.
 
@@ -448,7 +449,7 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
     throw ArpackError(ArpackError::PARAMETER_ERROR,
                       "ARluNonSymMatrix::FactorAsI");
   }
-  else if (info > n) {    // Memory is not sufficient.
+  else if (info > this->n) {    // Memory is not sufficient.
     throw ArpackError(ArpackError::MEMORY_OVERFLOW,
                       "ARluNonSymMatrix::FactorAsI");
   }
@@ -469,15 +470,15 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARluNonSymMatrix::MultMv");
   }
 
   // Determining w = M.v.
 
-  for (i=0; i!=m; i++) w[i]=(ARTYPE)0;
+  for (i=0; i!=this->m; i++) w[i]=(ARTYPE)0;
 
-  for (i=0; i!=n; i++) {
+  for (i=0; i!=this->n; i++) {
     t = v[i];
     for (j=pcol[i]; j!=pcol[i+1]; j++) {
       w[irow[j]] += t*a[j];
@@ -496,13 +497,13 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARluNonSymMatrix::MultMtv");
   }
 
   // Determining w = M'.v.
 
-  for (i=0; i!=n; i++) {
+  for (i=0; i!=this->n; i++) {
     t = (ARTYPE)0;
     for (j=pcol[i]; j!=pcol[i+1]; j++) {
       t += v[irow[j]]*a[j];
@@ -517,7 +518,7 @@ template<class ARTYPE, class ARFLOAT>
 void ARluNonSymMatrix<ARTYPE, ARFLOAT>::MultMtMv(ARTYPE* v, ARTYPE* w)
 {
 
-  ARTYPE* t = new ARTYPE[m];
+  ARTYPE* t = new ARTYPE[this->m];
 
   MultMv(v,t);
   MultMtv(t,w);
@@ -531,7 +532,7 @@ template<class ARTYPE, class ARFLOAT>
 void ARluNonSymMatrix<ARTYPE, ARFLOAT>::MultMMtv(ARTYPE* v, ARTYPE* w)
 {
 
-  ARTYPE* t = new ARTYPE[n];
+  ARTYPE* t = new ARTYPE[this->n];
 
   MultMtv(v,t);
   MultMv(t,w);
@@ -545,8 +546,8 @@ template<class ARTYPE, class ARFLOAT>
 void ARluNonSymMatrix<ARTYPE, ARFLOAT>::Mult0MMt0v(ARTYPE* v, ARTYPE* w)
 {
 
-  MultMv(&v[m],w);
-  MultMtv(v,&w[m]);
+  MultMv(&v[this->m],w);
+  MultMtv(v,&w[this->m]);
 
 } // Mult0MMt0v.
 
@@ -567,8 +568,8 @@ void ARluNonSymMatrix<ARTYPE, ARFLOAT>::
   int         info;
   SuperMatrix B;
 
-  if (&v != &w) copy(n, v, 1, w, 1);
-  Create_Dense_Matrix(&B, n, 1, w, n, DN, GE);
+  if (&v != &w) copy(this->n, v, 1, w, 1);
+  Create_Dense_Matrix(&B, this->n, 1, w, this->n, DN, GE);
   gstrs("N", &L, &U, permr, permc, &B, &info);
   Destroy_SuperMatrix_Store(&B); // delete B.Store;
 
@@ -581,13 +582,13 @@ DefineMatrix(int np, int nnzp, ARTYPE* a
              double thresholdp, int orderp, bool check)
 {
 
-  m         = np;
-  n         = np;
+  this->m         = np;
+  this->n         = np;
   nnz       = nnzp;
   a         = ap;
   irow      = irowp;
   pcol      = pcolp;
-  pcol[n]   = nnz;
+  pcol[this->n]   = nnz;
   threshold = thresholdp;
   order     = orderp;
 
@@ -600,14 +601,14 @@ DefineMatrix(int np, int nnzp, ARTYPE* a
 
   // Creating SuperMatrix A.
 
-  Create_CompCol_Matrix(&A, n, n, nnz, a, irow, pcol, NC, GE);
+  Create_CompCol_Matrix(&A, this->n, this->n, nnz, a, irow, pcol, NC, GE);
 
   // Reserving memory for vectors used in matrix decomposition.
 
-  permc = new int[n];
-  permr = new int[n];
+  permc = new int[this->n];
+  permr = new int[this->n];
 
-  defined = true;
+  this->defined = true;
 
 } // DefineMatrix (square).
 
@@ -617,14 +618,14 @@ inline void ARluNonSymMatrix<ARTYPE, ARF
 DefineMatrix(int mp, int np, int nnzp, ARTYPE* ap, int* irowp, int* pcolp)
 {
 
-  m       = mp;
-  n       = np;
+  this->m       = mp;
+  this->n       = np;
   nnz     = nnzp;
   a       = ap;
   irow    = irowp;
   pcol    = pcolp;
-  pcol[n] = nnz;
-  defined = true;
+  pcol[this->n] = nnz;
+  this->defined = true;
   permc   = NULL;
   permr   = NULL;
 
diff -rupN arpack++1.2.orig/include/arlnspen.h arpack++1.2.patched/include/arlnspen.h
--- arpack++1.2.orig/include/arlnspen.h	2000-02-22 14:18:59.000000000 +0100
+++ arpack++1.2.patched/include/arlnspen.h	2006-01-26 15:37:50.000000000 +0100
@@ -17,7 +17,8 @@
 #ifndef ARLNSPEN_H
 #define ARLNSPEN_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arerror.h"
 #include "blas1c.h"
diff -rupN arpack++1.2.orig/include/arlscomp.h arpack++1.2.patched/include/arlscomp.h
--- arpack++1.2.orig/include/arlscomp.h	2000-02-21 01:28:44.000000000 +0100
+++ arpack++1.2.patched/include/arlscomp.h	2006-01-26 15:37:50.000000000 +0100
@@ -18,7 +18,8 @@
 #ifndef ARLSCOMP_H
 #define ARLSCOMP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arscomp.h"
 #include "arlnsmat.h"
@@ -97,7 +98,7 @@ Copy(const ARluCompStdEig<ARFLOAT>& othe
   ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
            ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
     Copy(other);
-  if (mode > 2) objOP->FactorAsI(sigmaR);
+  if (this->mode > 2) this->objOP->FactorAsI(this->sigmaR);
 
 } // Copy.
 
@@ -106,7 +107,7 @@ template<class ARFLOAT>
 inline void ARluCompStdEig<ARFLOAT>::ChangeShift(arcomplex<ARFLOAT> sigmap)
 {
 
-  objOP->FactorAsI(sigmap);
+  this->objOP->FactorAsI(sigmap);
   ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmap);
 
 } // ChangeShift.
@@ -118,7 +119,7 @@ inline void ARluCompStdEig<ARFLOAT>::Set
 
   ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
            ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
-    SetRegularMode(objOP, 
+    SetRegularMode(this->objOP, 
                    &ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv);
 
 } // SetRegularMode.
@@ -131,7 +132,7 @@ SetShiftInvertMode(arcomplex<ARFLOAT> si
 
   ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
            ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
-    SetShiftInvertMode(sigmap, objOP,
+    SetShiftInvertMode(sigmap, this->objOP,
                        &ARluNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT>::MultInvv);
 
 } // SetShiftInvertMode.
@@ -145,7 +146,7 @@ ARluCompStdEig(int nevp, ARluNonSymMatri
 
 {
 
-  NoShift();
+  this->NoShift();
   DefineParameters(A.ncols(), nevp, &A,
                    &ARluNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
@@ -176,7 +177,7 @@ operator=(const ARluCompStdEig<ARFLOAT>&
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arlsmat.h arpack++1.2.patched/include/arlsmat.h
--- arpack++1.2.orig/include/arlsmat.h	2000-02-22 14:19:46.000000000 +0100
+++ arpack++1.2.patched/include/arlsmat.h	2006-01-26 15:37:50.000000000 +0100
@@ -20,7 +20,7 @@
 #ifndef ARLSMAT_H
 #define ARLSMAT_H
 
-#include <stddef.h>
+#include <cstddef>
 #include "arch.h"
 #include "armat.h"
 #include "arhbmat.h"
@@ -117,12 +117,12 @@ bool ARluSymMatrix<ARTYPE>::DataOK()
   // Checking if pcol is in ascending order.
 
   i = 0;
-  while ((i!=n)&&(pcol[i]<=pcol[i+1])) i++;
-  if (i!=n) return false;
+  while ((i!=this->n)&&(pcol[i]<=pcol[i+1])) i++;
+  if (i!=this->n) return false;
 
   // Checking if irow components are in order and within bounds.
 
-  for (i=0; i!=n; i++) {
+  for (i=0; i!=this->n; i++) {
     j = pcol[i];
     k = pcol[i+1]-1;
     if (j<=k) {
@@ -130,7 +130,7 @@ bool ARluSymMatrix<ARTYPE>::DataOK()
         if ((irow[j]<0)||(irow[k]>i)) return false;
       }
       else { // uplo == 'L'.
-        if ((irow[j]<i)||(irow[k]>=n)) return false;
+        if ((irow[j]<i)||(irow[k]>=this->n)) return false;
       }
       while ((j!=k)&&(irow[j]<irow[j+1])) j++;
       if (j!=k) return false;
@@ -148,12 +148,12 @@ inline void ARluSymMatrix<ARTYPE>::Copy(
 
   // Copying very fundamental variables.
 
-  defined   = other.defined;
+  this->defined   = other.defined;
   factored  = other.factored;
 
   // Returning from here if "other" was not initialized.
 
-  if (!defined) return;
+  if (!this->defined) return;
 
   // Copying user-defined parameters.
 
@@ -183,7 +183,7 @@ void ARluSymMatrix<ARTYPE>::ClearMem()
     Destroy_CompCol_Matrix(&U);
     StatFree();
   }
-  if (defined) {
+  if (this->defined) {
     Destroy_SuperMatrix_Store(&A); // delete A.Store;
     delete[] permc;
     delete[] permr;
@@ -223,13 +223,13 @@ ExpandA(NCformat& A, NCformat& Aexp, ART
 
   // Filling colE with zeros.
 
-  for (i=0; i<=n; i++) colE[i] = 0;
+  for (i=0; i<=this->n; i++) colE[i] = 0;
 
   // Counting the elements in each column of A.
 
   if (uplo == 'U') {
 
-    for (i=0; i!=n; i++) {
+    for (i=0; i!=this->n; i++) {
       k = colA[i+1];
       if ((k!=colA[i])&&(indA[k-1]==i)) {
         k--;
@@ -243,7 +243,7 @@ ExpandA(NCformat& A, NCformat& Aexp, ART
   }
   else { // uplo == 'L'
 
-    for (i=0; i!=n; i++) {
+    for (i=0; i!=this->n; i++) {
       k = colA[i];
       if ((k!=colA[i+1])&&(indA[k]==i)) {
         k++;
@@ -258,18 +258,18 @@ ExpandA(NCformat& A, NCformat& Aexp, ART
 
   // Summing up colE elements.
 
-  for (i=0; i<n; i++) colE[i+1]+=colE[i];
+  for (i=0; i<this->n; i++) colE[i+1]+=colE[i];
 
   // Adding colA to colE.
 
-  for (i=n; i>0; i--) colE[i] = colE[i-1]+colA[i];
+  for (i=this->n; i>0; i--) colE[i] = colE[i-1]+colA[i];
   colE[0] = colA[0];    
 
   // Expanding A.
 
   if (uplo == 'U') {
 
-    for (i=0; i<n; i++) {
+    for (i=0; i<this->n; i++) {
       for (j=colA[i]; j<(colA[i+1]-1); j++) {
         indE[colE[i]] = indA[j];
         indE[colE[indA[j]]] = i; 
@@ -296,7 +296,7 @@ ExpandA(NCformat& A, NCformat& Aexp, ART
   }
   else { // uplo  == 'L'
 
-    for (i=0; i<n; i++) {
+    for (i=0; i<this->n; i++) {
       k=colA[i];
       if ((k!=colA[i+1])&&(indA[k]==i)) {
         indE[colE[i]] = i;
@@ -326,12 +326,12 @@ ExpandA(NCformat& A, NCformat& Aexp, ART
 
   // Adjusting index.
 
-  for (i=n; i>0; i--) {
+  for (i=this->n; i>0; i--) {
     colE[i] = colE[i-1];
   } 
   colE[0] = 0;
 
-  Aexp.nnz = colE[n];
+  Aexp.nnz = colE[this->n];
 
 } // ExpandA.
 
@@ -342,7 +342,7 @@ void ARluSymMatrix<ARTYPE>::FactorA()
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARluSymMatrix::FactorA");
   }
 
@@ -375,9 +375,9 @@ void ARluSymMatrix<ARTYPE>::FactorA()
   // Creating a temporary matrix Aexp.
 
   irowi = new int[nnz*2];
-  pcoli = new int[n+1];
+  pcoli = new int[this->n+1];
   aexp  = new ARTYPE[nnz*2];
-  Create_CompCol_Matrix(&Aexp, n,  n, nnz, aexp, irowi, pcoli, NC, GE);
+  Create_CompCol_Matrix(&Aexp, this->n,  this->n, nnz, aexp, irowi, pcoli, NC, GE);
 
   // Expanding A.
 
@@ -387,7 +387,7 @@ void ARluSymMatrix<ARTYPE>::FactorA()
 
   // Reserving memory for etree (used in matrix decomposition).
 
-  etree = new int[n];
+  etree = new int[this->n];
 
   // Defining LUStat.
 
@@ -421,7 +421,7 @@ void ARluSymMatrix<ARTYPE>::FactorA()
     throw ArpackError(ArpackError::PARAMETER_ERROR,
                       "ARluSymMatrix::FactorA");
   }
-  else if (info > n) {    // Memory is not sufficient.
+  else if (info > this->n) {    // Memory is not sufficient.
     throw ArpackError(ArpackError::MEMORY_OVERFLOW,
                       "ARluSymMatrix::FactorA");
   }
@@ -439,7 +439,7 @@ void ARluSymMatrix<ARTYPE>::FactorAsI(AR
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARluSymMatrix::FactorAsI");
   }
 
@@ -471,10 +471,10 @@ void ARluSymMatrix<ARTYPE>::FactorAsI(AR
 
   // Creating a temporary matrix AsI.
 
-  irowi = new int[nnz*2+n];
-  pcoli = new int[n+1];
-  asi   = new ARTYPE[nnz*2+n];
-  Create_CompCol_Matrix(&AsI, n,  n, nnz, asi, irowi, pcoli, NC, GE);
+  irowi = new int[nnz*2+this->n];
+  pcoli = new int[this->n+1];
+  asi   = new ARTYPE[nnz*2+this->n];
+  Create_CompCol_Matrix(&AsI, this->n,  this->n, nnz, asi, irowi, pcoli, NC, GE);
 
   // Subtracting sigma*I from A and storing the result on AsI.
 
@@ -484,7 +484,7 @@ void ARluSymMatrix<ARTYPE>::FactorAsI(AR
 
   // Reserving memory for etree (used in matrix decomposition).
 
-  etree = new int[n];
+  etree = new int[this->n];
 
   // Defining LUStat.
 
@@ -518,7 +518,7 @@ void ARluSymMatrix<ARTYPE>::FactorAsI(AR
     throw ArpackError(ArpackError::PARAMETER_ERROR,
                       "ARluSymMatrix::FactorAsI");
   }
-  else if (info > n) {    // Memory is not sufficient.
+  else if (info > this->n) {    // Memory is not sufficient.
     throw ArpackError(ArpackError::MEMORY_OVERFLOW,
                       "ARluSymMatrix::FactorAsI");
   }
@@ -539,17 +539,17 @@ void ARluSymMatrix<ARTYPE>::MultMv(ARTYP
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARluSymMatrix::MultMv");
   }
 
   // Determining w = M.v.
 
-  for (i=0; i!=m; i++) w[i]=(ARTYPE)0;
+  for (i=0; i!=this->m; i++) w[i]=(ARTYPE)0;
 
   if (uplo == 'U') {
 
-    for (i=0; i!=n; i++) {
+    for (i=0; i!=this->n; i++) {
       t = v[i];
       k = pcol[i+1];
       if ((k!=pcol[i])&&(irow[k-1]==i)) {
@@ -565,7 +565,7 @@ void ARluSymMatrix<ARTYPE>::MultMv(ARTYP
   }
   else {
 
-    for (i=0; i!=n; i++) {
+    for (i=0; i!=this->n; i++) {
       t = v[i];
       k = pcol[i];
       if ((k!=pcol[i+1])&&(irow[k]==i)) {
@@ -599,8 +599,8 @@ void ARluSymMatrix<ARTYPE>::MultInvv(ART
   int         info;
   SuperMatrix B;
 
-  if (&v != &w) copy(n, v, 1, w, 1);
-  Create_Dense_Matrix(&B, n, 1, w, n, DN, GE);
+  if (&v != &w) copy(this->n, v, 1, w, 1);
+  Create_Dense_Matrix(&B, this->n, 1, w, this->n, DN, GE);
   gstrs("N", &L, &U, permr, permc, &B, &info);
   Destroy_SuperMatrix_Store(&B); // delete B.Store;
 
@@ -613,13 +613,13 @@ DefineMatrix(int np, int nnzp, ARTYPE* a
              char uplop, double thresholdp, int orderp, bool check)
 {
 
-  m         = np;
-  n         = np;
+  this->m         = np;
+  this->n         = np;
   nnz       = nnzp;
   a         = ap;
   irow      = irowp;
   pcol      = pcolp;
-  pcol[n]   = nnz;
+  pcol[this->n]   = nnz;
   uplo      = uplop;
   threshold = thresholdp;
   order     = orderp;
@@ -633,14 +633,14 @@ DefineMatrix(int np, int nnzp, ARTYPE* a
 
   // Creating SuperMatrix A.
 
-  Create_CompCol_Matrix(&A, n, n, nnz, a, irow, pcol, NC, GE);
+  Create_CompCol_Matrix(&A, this->n, this->n, nnz, a, irow, pcol, NC, GE);
 
   // Reserving memory for vectors used in matrix decomposition.
 
-  permc = new int[n];
-  permr = new int[n];
+  permc = new int[this->n];
+  permr = new int[this->n];
 
-  defined = true;
+  this->defined = true;
 
 } // DefineMatrix.
 
diff -rupN arpack++1.2.orig/include/arlsnsym.h arpack++1.2.patched/include/arlsnsym.h
--- arpack++1.2.orig/include/arlsnsym.h	2000-02-21 01:22:42.000000000 +0100
+++ arpack++1.2.patched/include/arlsnsym.h	2006-01-26 15:37:50.000000000 +0100
@@ -18,7 +18,8 @@
 #ifndef ARLSNSYM_H
 #define ARLSNSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arsnsym.h"
 #include "arlnsmat.h"
@@ -91,7 +92,7 @@ Copy(const ARluNonSymStdEig<ARFLOAT>& ot
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARluNonSymMatrix<ARFLOAT, ARFLOAT> >:: Copy(other);
-  if (mode > 2) objOP->FactorAsI(sigmaR);
+  if (this->mode > 2) this->objOP->FactorAsI(this->sigmaR);
 
 } // Copy.
 
@@ -100,13 +101,13 @@ template<class ARFLOAT>
 inline void ARluNonSymStdEig<ARFLOAT>::ChangeShift(ARFLOAT sigmaRp)
 {
 
-  sigmaR    = sigmaRp;
-  sigmaI    = 0.0;
-  mode      = 3;
-  iparam[7] = mode;
+  this->sigmaR    = sigmaRp;
+  this->sigmaI    = 0.0;
+  this->mode      = 3;
+  this->iparam[7] = this->mode;
 
-  objOP->FactorAsI(sigmaR);
-  Restart();
+  this->objOP->FactorAsI(this->sigmaR);
+  this->Restart();
 
 } // ChangeShift.
 
@@ -116,7 +117,7 @@ inline void ARluNonSymStdEig<ARFLOAT>::S
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARluNonSymMatrix<ARFLOAT, ARFLOAT> >::
-    SetRegularMode(objOP, &ARluNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv);
+    SetRegularMode(this->objOP, &ARluNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv);
 
 } // SetRegularMode.
 
@@ -126,7 +127,7 @@ inline void ARluNonSymStdEig<ARFLOAT>::S
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARluNonSymMatrix<ARFLOAT, ARFLOAT> >::
-    SetShiftInvertMode(sigmap, objOP, 
+    SetShiftInvertMode(sigmap, this->objOP, 
                        &ARluNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv);
 
 } // SetShiftInvertMode.
@@ -140,7 +141,7 @@ ARluNonSymStdEig(int nevp, ARluNonSymMat
 
 {
 
-  NoShift();
+  this->NoShift();
   DefineParameters(A.ncols(), nevp, &A, 
                    &ARluNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
@@ -170,7 +171,7 @@ operator=(const ARluNonSymStdEig<ARFLOAT
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arlspen.h arpack++1.2.patched/include/arlspen.h
--- arpack++1.2.orig/include/arlspen.h	2000-02-22 14:20:33.000000000 +0100
+++ arpack++1.2.patched/include/arlspen.h	2006-01-26 15:37:50.000000000 +0100
@@ -17,7 +17,8 @@
 #ifndef ARLSPEN_H
 #define ARLSPEN_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arerror.h"
 #include "blas1c.h"
diff -rupN arpack++1.2.orig/include/arlssym.h arpack++1.2.patched/include/arlssym.h
--- arpack++1.2.orig/include/arlssym.h	2000-03-03 22:13:06.000000000 +0100
+++ arpack++1.2.patched/include/arlssym.h	2006-01-26 15:37:50.000000000 +0100
@@ -19,7 +19,8 @@
 #ifndef ARLSSYM_H
 #define ARLSSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arssym.h"
 #include "arlsmat.h"
@@ -92,7 +93,7 @@ inline void ARluSymStdEig<ARFLOAT>::Copy
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARluSymMatrix<ARFLOAT> >:: Copy(other);
-  if (mode > 2) objOP->FactorAsI(sigmaR);
+  if (this->mode > 2) this->objOP->FactorAsI(this->sigmaR);
 
 } // Copy.
 
@@ -101,13 +102,13 @@ template<class ARFLOAT>
 inline void ARluSymStdEig<ARFLOAT>::ChangeShift(ARFLOAT sigmaRp)
 {
 
-  sigmaR    = sigmaRp;
-  sigmaI    = 0.0;
-  mode      = 3;
-  iparam[7] = mode;
+  this->sigmaR    = sigmaRp;
+  this->sigmaI    = 0.0;
+  this->mode      = 3;
+  this->iparam[7] = this->mode;
 
-  objOP->FactorAsI(sigmaR);
-  Restart();
+  this->objOP->FactorAsI(this->sigmaR);
+  this->Restart();
 
 } // ChangeShift.
 
@@ -117,7 +118,7 @@ inline void ARluSymStdEig<ARFLOAT>::SetR
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARluSymMatrix<ARFLOAT> >::
-    SetRegularMode(objOP, &ARluSymMatrix<ARFLOAT>::MultMv);
+    SetRegularMode(this->objOP, &ARluSymMatrix<ARFLOAT>::MultMv);
 
 } // SetRegularMode.
 
@@ -127,7 +128,7 @@ inline void ARluSymStdEig<ARFLOAT>::SetS
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARluSymMatrix<ARFLOAT> >::
-    SetShiftInvertMode(sigmap, objOP, &ARluSymMatrix<ARFLOAT>::MultInvv);
+    SetShiftInvertMode(sigmap, this->objOP, &ARluSymMatrix<ARFLOAT>::MultInvv);
 
 } // SetShiftInvertMode.
 
@@ -139,7 +140,7 @@ ARluSymStdEig(int nevp, ARluSymMatrix<AR
               int maxitp, ARFLOAT* residp, bool ishiftp)
 {
 
-  NoShift();
+  this->NoShift();
   DefineParameters(A.ncols(), nevp, &A, &ARluSymMatrix<ARFLOAT>::MultMv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
@@ -167,7 +168,7 @@ operator=(const ARluSymStdEig<ARFLOAT>& 
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arrgcomp.h arpack++1.2.patched/include/arrgcomp.h
--- arpack++1.2.orig/include/arrgcomp.h	2000-02-21 17:29:48.000000000 +0100
+++ arpack++1.2.patched/include/arrgcomp.h	2006-01-26 15:37:50.000000000 +0100
@@ -17,7 +17,8 @@
 #ifndef ARRGCOMP_H
 #define ARRGCOMP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arrscomp.h"
 #include "arrgeig.h"
@@ -71,7 +72,7 @@ ARrcCompGenEig(int np, int nevp, char* w
 
 {
 
-  NoShift();
+  this->NoShift();
   DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (regular mode).
@@ -97,7 +98,7 @@ operator=(const ARrcCompGenEig<ARFLOAT>&
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arrgeig.h arpack++1.2.patched/include/arrgeig.h
--- arpack++1.2.orig/include/arrgeig.h	2000-02-21 17:28:50.000000000 +0100
+++ arpack++1.2.patched/include/arrgeig.h	2006-01-26 15:37:50.000000000 +0100
@@ -66,11 +66,11 @@ template<class ARFLOAT, class ARTYPE>
 inline void ARrcGenEig<ARFLOAT, ARTYPE>::NoShift()
 {
 
-  sigmaR    = (ARTYPE)0;
-  sigmaI    = 0.0;
-  mode      = 2;
-  iparam[7] = mode;
-  Restart();
+  this->sigmaR    = (ARTYPE)0;
+  this->sigmaI    = 0.0;
+  this->mode      = 2;
+  this->iparam[7] = this->mode;
+  this->Restart();
 
 } // NoShift.
 
@@ -79,8 +79,8 @@ template<class ARFLOAT, class ARTYPE>
 inline ARrcGenEig<ARFLOAT, ARTYPE>::ARrcGenEig()
 {
 
-  bmat = 'G';   // This is a generalized problem.
-  NoShift();
+  this->bmat = 'G';   // This is a generalized problem.
+  this->NoShift();
 
 } // Short constructor.
 
@@ -91,7 +91,7 @@ operator=(const ARrcGenEig<ARFLOAT, ARTY
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arrgnsym.h arpack++1.2.patched/include/arrgnsym.h
--- arpack++1.2.orig/include/arrgnsym.h	2000-02-21 17:27:48.000000000 +0100
+++ arpack++1.2.patched/include/arrgnsym.h	2006-01-26 15:37:50.000000000 +0100
@@ -17,7 +17,8 @@
 #ifndef ARRGNSYM_H
 #define ARRGNSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arrsnsym.h"
 #include "arrgeig.h"
@@ -50,7 +51,7 @@ class ARrcNonSymGenEig:
 
  // c.1) Functions that provides access to internal variables' values.
 
-  ARFLOAT GetShiftImag() { return sigmaI; }
+  ARFLOAT GetShiftImag() { return this->sigmaI; }
   // Returns the imaginary part of the shift (when in shift and invert mode).
 
 
@@ -141,13 +142,13 @@ inline void ARrcNonSymGenEig<ARFLOAT>::C
 
   part = CheckPart(partp);
   if (part == 'R') {
-    mode    = 3;    // Real part.
+    this->mode    = 3;    // Real part.
   }
   else {
-    mode    = 4;    // Imaginary part.
+    this->mode    = 4;    // Imaginary part.
   }
-  iparam[7] = mode;
-  Restart();
+  this->iparam[7] = this->mode;
+  this->Restart();
 
 } // ChangePart.
 
@@ -157,8 +158,8 @@ inline void ARrcNonSymGenEig<ARFLOAT>::
 ChangeShift(ARFLOAT sigmaRp, ARFLOAT sigmaIp)
 {
 
-  sigmaR    = sigmaRp;
-  sigmaI    = sigmaIp;
+  this->sigmaR    = sigmaRp;
+  this->sigmaI    = sigmaIp;
   ChangePart(part);
 
 } // ChangeShift.
@@ -193,7 +194,7 @@ ARrcNonSymGenEig(int np, int nevp, char*
 {
 
   part = 'R';                // Considering mode = 3 in ChangeShift.
-  NoShift();
+  this->NoShift();
   DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (regular mode).
@@ -231,7 +232,7 @@ operator=(const ARrcNonSymGenEig<ARFLOAT
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arrgsym.h arpack++1.2.patched/include/arrgsym.h
--- arpack++1.2.orig/include/arrgsym.h	2000-02-21 15:50:06.000000000 +0100
+++ arpack++1.2.patched/include/arrgsym.h	2006-01-26 15:37:50.000000000 +0100
@@ -17,7 +17,8 @@
 #ifndef ARRGSYM_H
 #define ARRGSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arrssym.h"
 #include "arrgeig.h"
@@ -129,17 +130,17 @@ inline void ARrcSymGenEig<ARFLOAT>::Chan
   InvertMode = CheckInvertMode(InvertModep);
   switch (InvertMode) {
   case 'S':
-    mode    = 3;    // Shift and invert mode.
+    this->mode    = 3;    // Shift and invert mode.
     break;
   case 'B':
-    mode    = 4;    // Buckling mode.
+    this->mode    = 4;    // Buckling mode.
     break;
   case 'C':
-    mode    = 5;    // Cayley mode.
+    this->mode    = 5;    // Cayley mode.
     break;
   }
-  iparam[7] = mode;
-  Restart();
+  this->iparam[7] = this->mode;
+  this->Restart();
 
 } // ChangeInvertMode.
 
@@ -148,8 +149,8 @@ template<class ARFLOAT>
 inline void ARrcSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)
 {
 
-  sigmaR    = sigmap;
-  sigmaI    = 0.0;
+  this->sigmaR    = sigmap;
+  this->sigmaI    = 0.0;
   ChangeInvertMode(InvertMode);
 
 } // ChangeShift.
@@ -196,7 +197,7 @@ ARrcSymGenEig(int np, int nevp, char* wh
 {
 
   InvertMode = 'S';   // Considering mode = 3 in ChangeShift.
-  NoShift();
+  this->NoShift();
   DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (regular mode).
@@ -223,7 +224,7 @@ operator=(const ARrcSymGenEig<ARFLOAT>& 
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arrscomp.h arpack++1.2.patched/include/arrscomp.h
--- arpack++1.2.orig/include/arrscomp.h	2000-03-03 21:29:58.000000000 +0100
+++ arpack++1.2.patched/include/arrscomp.h	2006-01-26 15:37:50.000000000 +0100
@@ -17,7 +17,8 @@
 #ifndef ARRSCOMP_H
 #define ARRSCOMP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arerror.h"
 #include "debug.h"
@@ -138,12 +139,12 @@ template<class ARFLOAT>
 inline void ARrcCompStdEig<ARFLOAT>::WorkspaceAllocate()
 {
 
-  lworkl  = ncv*(3*ncv+6);
-  lworkv  = 2*ncv;
-  lrwork  = ncv;
-  workl   = new arcomplex<ARFLOAT>[lworkl+1];
-  workv   = new arcomplex<ARFLOAT>[lworkv+1];
-  rwork   = new ARFLOAT[lrwork+1];
+  this->lworkl  = this->ncv*(3*this->ncv+6);
+  this->lworkv  = 2*this->ncv;
+  this->lrwork  = this->ncv;
+  this->workl   = new arcomplex<ARFLOAT>[this->lworkl+1];
+  this->workv   = new arcomplex<ARFLOAT>[this->lworkv+1];
+  this->rwork   = new ARFLOAT[this->lrwork+1];
 
 } // WorkspaceAllocate.
 
@@ -152,8 +153,8 @@ template<class ARFLOAT>
 inline void ARrcCompStdEig<ARFLOAT>::Aupp()
 {
 
-  caupp(ido, bmat, n, which, nev, tol, resid, ncv, V, n,
-        iparam, ipntr, workd, workl, lworkl, rwork, info);
+  caupp(this->ido, this->bmat, this->n, this->which, this->nev, this->tol, this->resid, this->ncv, this->V, this->n,
+        this->iparam, this->ipntr, this->workd, this->workl, this->lworkl, this->rwork, this->info);
 
 } // Aupp.
 
@@ -162,9 +163,9 @@ template<class ARFLOAT>
 inline void ARrcCompStdEig<ARFLOAT>::Eupp()
 {
 
-  ceupp(rvec, HowMny, EigValR, EigVec, n, sigmaR, workv,
-        bmat, n, which, nev, tol, resid, ncv, V, n, iparam,
-        ipntr, workd, workl, lworkl, rwork, info);
+  ceupp(this->rvec, this->HowMny, this->EigValR, this->EigVec, this->n, this->sigmaR, this->workv,
+        this->bmat, this->n, this->which, this->nev, this->tol, this->resid, this->ncv, this->V, this->n, this->iparam,
+        this->ipntr, this->workd, this->workl, this->lworkl, this->rwork, this->info);
 
 } // Eupp.
 
@@ -174,36 +175,36 @@ int ARrcCompStdEig<ARFLOAT>::
 Eigenvalues(arcomplex<ARFLOAT>* &EigValp, bool ivec, bool ischur)
 {
 
-  if (ValuesOK) {                      // Eigenvalues are available .
+  if (this->ValuesOK) {                      // Eigenvalues are available .
     if (EigValp == NULL) {             // Moving eigenvalues.
-      EigValp  = EigValR;
-      EigValR  = NULL;
-      newVal   = false;
-      ValuesOK = false;
+      EigValp  = this->EigValR;
+      this->EigValR  = NULL;
+      this->newVal   = false;
+      this->ValuesOK = false;
     }
     else {                             // Copying eigenvalues.
-      copy(nconv,EigValR,1,EigValp,1);
+      copy(this->nconv,this->EigValR,1,EigValp,1);
     }
   }
   else {
-    if (newVal) {
-      delete[] EigValR;
-      newVal = false;
+    if (this->newVal) {
+      delete[] this->EigValR;
+      this->newVal = false;
     }
     if (EigValp == NULL) {
-      try { EigValp = new arcomplex<ARFLOAT>[ValSize()]; }
+      try { EigValp = new arcomplex<ARFLOAT>[this->ValSize()]; }
       catch (ArpackError) { return 0; }
     }
-    EigValR = EigValp;
+    this->EigValR = EigValp;
     if (ivec) {                        // Finding eigenvalues and eigenvectors.
-      nconv = FindEigenvectors(ischur);
+      this->nconv = this->FindEigenvectors(ischur);
     }
     else {                             // Finding eigenvalues only.
-      nconv = FindEigenvalues();
+      this->nconv = this->FindEigenvalues();
     }
-    EigValR = NULL;
+    this->EigValR = NULL;
   }
-  return nconv;
+  return this->nconv;
 
 } // Eigenvalues(EigValp, ivec, ischur).
 
@@ -214,31 +215,31 @@ EigenValVectors(arcomplex<ARFLOAT>* &Eig
                 bool ischur)
 {
 
-  if (ValuesOK) {                  // Eigenvalues are already available.
-    nconv = Eigenvalues(EigValp, false);
-    nconv = Eigenvectors(EigVecp, ischur);
+  if (this->ValuesOK) {                  // Eigenvalues are already available.
+    this->nconv = Eigenvalues(EigValp, false);
+    this->nconv = Eigenvectors(EigVecp, ischur);
   }
   else {                           // Eigenvalues and vectors are not available.
-    if (newVec) {
-      delete[] EigVec;
-      newVec = false;
+    if (this->newVec) {
+      delete[] this->EigVec;
+      this->newVec = false;
     }
-    if (newVal) {
-      delete[] EigValR;
-      newVal = false;
+    if (this->newVal) {
+      delete[] this->EigValR;
+      this->newVal = false;
     }  
     try {
-      if (EigVecp == NULL) EigVecp = new arcomplex<ARFLOAT>[ValSize()*n];
-      if (EigValp == NULL) EigValp = new arcomplex<ARFLOAT>[ValSize()];
+      if (EigVecp == NULL) EigVecp = new arcomplex<ARFLOAT>[this->ValSize()*this->n];
+      if (EigValp == NULL) EigValp = new arcomplex<ARFLOAT>[this->ValSize()];
     }
     catch (ArpackError) { return 0; }
-    EigVec  = EigVecp;
-    EigValR = EigValp;
-    nconv   = FindEigenvectors(ischur);
-    EigVec  = NULL;
-    EigValR = NULL;
+    this->EigVec  = EigVecp;
+    this->EigValR = EigValp;
+    this->nconv   = this->FindEigenvectors(ischur);
+    this->EigVec  = NULL;
+    this->EigValR = NULL;
   }
-  return nconv;
+  return this->nconv;
 
 } // EigenValVectors(EigVecp, EigValp, ischur).
 
@@ -251,13 +252,13 @@ inline arcomplex<ARFLOAT> ARrcCompStdEig
 
   // Returning i-eth eigenvalue.
 
-  if (!ValuesOK) {
+  if (!this->ValuesOK) {
     throw ArpackError(ArpackError::VALUES_NOT_OK, "Eigenvalue(i)");
   }
-  else if ((i>=nconv)||(i<0)) {
+  else if ((i>=this->nconv)||(i<0)) {
     throw ArpackError(ArpackError::RANGE_ERROR, "Eigenvalue(i)");
   }
-  return EigValR[i];
+  return this->EigValR[i];
 
 } // Eigenvalue(i).
 
@@ -269,13 +270,13 @@ Eigenvector(int i, int j)
 
   // Returning element j of i-eth eigenvector.
 
-  if (!VectorsOK) {
+  if (!this->VectorsOK) {
     throw ArpackError(ArpackError::VECTORS_NOT_OK, "Eigenvector(i,j)");
   }
-  else if ((i>=nconv)||(i<0)||(j>=n)||(j<0)) {
+  else if ((i>=this->nconv)||(i<0)||(j>=this->n)||(j<0)) {
     throw ArpackError(ArpackError::RANGE_ERROR, "Eigenvector(i,j)");
   }
-  return EigVec[i*n+j];
+  return this->EigVec[i*this->n+j];
 
 } // Eigenvector(i,j).
 
@@ -336,7 +337,7 @@ ARrcCompStdEig(int np, int nevp, char* w
 
 {
 
-  NoShift();
+  this->NoShift();
   DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (regular mode).
@@ -362,7 +363,7 @@ operator=(const ARrcCompStdEig<ARFLOAT>&
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arrseig.h arpack++1.2.patched/include/arrseig.h
--- arpack++1.2.orig/include/arrseig.h	2000-03-03 22:09:44.000000000 +0100
+++ arpack++1.2.patched/include/arrseig.h	2006-01-26 15:37:50.000000000 +0100
@@ -19,8 +19,9 @@
 #ifndef ARRSEIG_H
 #define ARRSEIG_H
 
-#include <new.h>
-#include <stddef.h>
+#include <new>
+#include <cstddef>
+
 #include "arch.h"
 #include "arerror.h"
 #include "debug.h"
@@ -837,7 +838,7 @@ DefineParameters(int np, int nevp, char*
 
   // Providing a "new" handler.
 
-  set_new_handler(MemoryOverflow);
+  std::set_new_handler ( MemoryOverflow );
 
   // Setting user defined parameters.
 
diff -rupN arpack++1.2.orig/include/arrsnsym.h arpack++1.2.patched/include/arrsnsym.h
--- arpack++1.2.orig/include/arrsnsym.h	2000-03-03 21:30:50.000000000 +0100
+++ arpack++1.2.patched/include/arrsnsym.h	2006-01-26 15:37:50.000000000 +0100
@@ -17,7 +17,8 @@
 #ifndef ARRSNSYM_H
 #define ARRSNSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arerror.h"
 #include "debug.h"
@@ -35,7 +36,7 @@ class ARrcNonSymStdEig: public virtual A
 
  // a.1) Memory control functions.
 
-  int ValSize() { return nev+1; }
+  int ValSize() { return this->nev+1; }
   // Provides the size of array EigVal.
 
   void ValAllocate();
@@ -226,10 +227,10 @@ template<class ARFLOAT>
 inline void ARrcNonSymStdEig<ARFLOAT>::ValAllocate()
 {
 
-  if (EigValR == NULL) {
-    EigValR = new ARFLOAT[ValSize()];
-    EigValI = new ARFLOAT[ValSize()];
-    newVal = true;
+  if (this->EigValR == NULL) {
+    this->EigValR = new ARFLOAT[ValSize()];
+    this->EigValI = new ARFLOAT[ValSize()];
+    this->newVal = true;
   }
 
 } // ValAllocate.
@@ -239,11 +240,11 @@ template<class ARFLOAT>
 inline void ARrcNonSymStdEig<ARFLOAT>::WorkspaceAllocate()
 {
 
-  lworkl  = 3*ncv*(ncv+2);
-  lworkv  = 3*ncv;
-  lrwork  = 0;
-  workl   = new ARFLOAT[lworkl+1];
-  workv   = new ARFLOAT[lworkv+1];
+  this->lworkl  = 3*this->ncv*(this->ncv+2);
+  this->lworkv  = 3*this->ncv;
+  this->lrwork  = 0;
+  this->workl   = new ARFLOAT[this->lworkl+1];
+  this->workv   = new ARFLOAT[this->lworkv+1];
 
 } // WorkspaceAllocate.
 
@@ -252,8 +253,8 @@ template<class ARFLOAT>
 inline void ARrcNonSymStdEig<ARFLOAT>::Aupp()
 {
 
-  naupp(ido, bmat, n, which, nev, tol, resid, ncv, V, n,
-        iparam, ipntr, workd, workl, lworkl, info);
+  naupp(this->ido,this-> bmat, this->n, this->which, this->nev, this->tol, this->resid, this->ncv, this->V, this->n,
+        this->iparam, this->ipntr, this->workd, this->workl, this->lworkl, this->info);
 
 } // Aupp.
 
@@ -262,9 +263,9 @@ template<class ARFLOAT>
 inline void ARrcNonSymStdEig<ARFLOAT>::Eupp()
 {
 
-  neupp(rvec, HowMny, EigValR, EigValI, EigVec, n, sigmaR,
-        sigmaI, workv, bmat, n, which, nev, tol, resid, ncv, V,
-        n, iparam, ipntr, workd, workl, lworkl, info);
+  neupp(this->rvec, this->HowMny, this->EigValR, this->EigValI, this->EigVec, this->n, this->sigmaR,
+        this->sigmaI, this->workv, this->bmat, this->n, this->which, this->nev, this->tol, this->resid, this->ncv, this->V,
+        this->n, this->iparam, this->ipntr, this->workd, this->workl, this->lworkl, this->info);
 
 } // Eupp.
 
@@ -273,7 +274,7 @@ template<class ARFLOAT>
 inline int ARrcNonSymStdEig<ARFLOAT>::CheckNev(int nevp)
 {
 
-  if ((nevp<=1)||(nevp>=(n-1))) { // nev must satisfy 1 < nev < n-1.
+  if ((nevp<=1)||(nevp>=(this->n-1))) { // nev must satisfy 1 < nev < n-1.
     throw ArpackError(ArpackError::NEV_OUT_OF_BOUNDS);
   }
   return nevp;
@@ -285,9 +286,9 @@ template<class ARFLOAT>
 bool ARrcNonSymStdEig<ARFLOAT>::ConjEigVec(int i)
 {
 
-  if (EigValI[i] == (ARFLOAT)0.0) return false;
+  if (this->EigValI[i] == (ARFLOAT)0.0) return false;
   int j = i-1;
-  while ((j >= 0) && (EigValI[j] != (ARFLOAT)0.0)) j--;
+  while ((j >= 0) && (this->EigValI[j] != (ARFLOAT)0.0)) j--;
   if (((i-j)%2) == 0) {
     return true;
   }
@@ -395,10 +396,10 @@ template<class ARFLOAT>
 ARFLOAT* ARrcNonSymStdEig<ARFLOAT>::GetVectorImag()
 {
 
-  if (ido != 3) {
+  if (this->ido != 3) {
     throw ArpackError(ArpackError::CANNOT_GET_VECTOR, "GetVectorImag");
   }
-  return &workl[ipntr[6]];
+  return &this->workl[this->ipntr[6]];
 
 } // GetVectorImag.
 
@@ -408,14 +409,14 @@ int ARrcNonSymStdEig<ARFLOAT>::
 Eigenvalues(ARFLOAT* &EigValRp, ARFLOAT* &EigValIp, bool ivec, bool ischur)
 {
 
-  if (ValuesOK) {                                 // Eigenvalues are available.
+  if (this->ValuesOK) {                                 // Eigenvalues are available.
     if ((EigValRp == NULL)&&(EigValIp == NULL)) { // Moving eigenvalues.
-      EigValRp = EigValR;
-      EigValIp = EigValI;
-      EigValR  = NULL;
-      EigValI  = NULL;
-      newVal   = false;
-      ValuesOK = false;
+      EigValRp = this->EigValR;
+      EigValIp = this->EigValI;
+      this->EigValR  = NULL;
+      this->EigValI  = NULL;
+      this->newVal   = false;
+      this->ValuesOK = false;
     }
     else {                                        // Copying eigenvalues.
       try {
@@ -423,33 +424,33 @@ Eigenvalues(ARFLOAT* &EigValRp, ARFLOAT*
         if (EigValIp == NULL) EigValIp = new ARFLOAT[ValSize()];
       }
       catch (ArpackError) { return 0; }
-      copy(nconv,EigValR,1,EigValRp,1);
-      copy(nconv,EigValI,1,EigValIp,1);
+      copy(this->nconv,this->EigValR,1,EigValRp,1);
+      copy(this->nconv,this->EigValI,1,EigValIp,1);
     }
   }
   else {
-    if (newVal) {
-      delete[] EigValR;
-      delete[] EigValI;
-      newVal = false;
+    if (this->newVal) {
+      delete[] this->EigValR;
+      delete[] this->EigValI;
+      this->newVal = false;
     }
     try {
       if (EigValRp == NULL) EigValRp = new ARFLOAT[ValSize()];
       if (EigValIp == NULL) EigValIp = new ARFLOAT[ValSize()];
     }
     catch (ArpackError) { return 0; }
-    EigValR = EigValRp;
-    EigValI = EigValIp;
+    this->EigValR = EigValRp;
+    this->EigValI = EigValIp;
     if (ivec) {                              // Finding eigenvalues and vectors.
-      nconv = FindEigenvectors(ischur);
+      this->nconv = this->FindEigenvectors(ischur);
     }
     else {                                   // Finding eigenvalues only.
-      nconv = FindEigenvalues();
+      this->nconv = this->FindEigenvalues();
     }
-    EigValR = NULL;
-    EigValI = NULL;
+    this->EigValR = NULL;
+    this->EigValI = NULL;
   }
-  return nconv;
+  return this->nconv;
 
 } // Eigenvalues(EigValRp, EigValIp, ivec, ischur).
 
@@ -460,35 +461,35 @@ EigenValVectors(ARFLOAT* &EigVecp, ARFLO
                 ARFLOAT* &EigValIp, bool ischur)
 {
 
-  if (ValuesOK) {               // Eigenvalues are already available .
-    nconv = Eigenvalues(EigValRp, EigValIp, false);
-    nconv = Eigenvectors(EigVecp, ischur);
+  if (this->ValuesOK) {               // Eigenvalues are already available .
+    this->nconv = Eigenvalues(EigValRp, EigValIp, false);
+    this->nconv = Eigenvectors(EigVecp, ischur);
   }
   else {                        // Eigenvalues ans vectors are not available.
-    if (newVec) {
-      delete[] EigVec;
-      newVec = false;
-    }
-    if (newVal) {
-      delete[] EigValR;
-      delete[] EigValI;
-      newVal = false;
+    if (this->newVec) {
+      delete[] this->EigVec;
+      this->newVec = false;
+    }
+    if (this->newVal) {
+      delete[] this->EigValR;
+      delete[] this->EigValI;
+      this->newVal = false;
     }
     try {
-      if (EigVecp  == NULL) EigVecp  = new ARFLOAT[ValSize()*n];
+      if (EigVecp  == NULL) EigVecp  = new ARFLOAT[ValSize()*this->n];
       if (EigValRp == NULL) EigValRp = new ARFLOAT[ValSize()];
       if (EigValIp == NULL) EigValIp = new ARFLOAT[ValSize()];
     }
     catch (ArpackError) { return 0; }
-    EigVec  = EigVecp;
-    EigValR = EigValRp;
-    EigValI = EigValIp;
-    nconv   = FindEigenvectors(ischur);
-    EigVec  = NULL;
-    EigValR = NULL;
-    EigValI = NULL;
+    this->EigVec  = EigVecp;
+    this->EigValR = EigValRp;
+    this->EigValI = EigValIp;
+    this->nconv   = this->FindEigenvectors(ischur);
+    this->EigVec  = NULL;
+    this->EigValR = NULL;
+    this->EigValI = NULL;
   }
-  return nconv;
+  return this->nconv;
 
 } // EigenValVectors(EigVecp, EigValRp, EigValIp, ischur).
 
@@ -500,13 +501,13 @@ inline arcomplex<ARFLOAT> ARrcNonSymStdE
 
   // Returning i-eth eigenvalue.
 
-  if (!ValuesOK) {
+  if (!this->ValuesOK) {
     throw ArpackError(ArpackError::VALUES_NOT_OK, "Eigenvalue(i)");
   }
-  else if ((i>=nconv)||(i<0)) {
+  else if ((i>=this->nconv)||(i<0)) {
     throw ArpackError(ArpackError::RANGE_ERROR, "Eigenvalue(i)");
   }
-  return arcomplex<ARFLOAT>(EigValR[i],EigValI[i]);
+  return arcomplex<ARFLOAT>(this->EigValR[i],this->EigValI[i]);
 
 } // Eigenvalue(i).
 #endif // ARCOMP_H
@@ -518,13 +519,13 @@ inline ARFLOAT ARrcNonSymStdEig<ARFLOAT>
 
   // Returning the real part of i-eth eigenvalue.
 
-  if (!ValuesOK) {
+  if (!this->ValuesOK) {
     throw ArpackError(ArpackError::VALUES_NOT_OK, "EigenvalueReal(i)");
   }
-  else if ((i>=nconv)||(i<0)) {
+  else if ((i>=this->nconv)||(i<0)) {
     throw ArpackError(ArpackError::RANGE_ERROR, "EigenvalueReal(i)");
   }
-  return EigValR[i];
+  return this->EigValR[i];
 
 } // EigenvalueReal(i).
 
@@ -535,13 +536,13 @@ inline ARFLOAT ARrcNonSymStdEig<ARFLOAT>
 
   // Returning the imaginary part of i-eth eigenvalue.
 
-  if (!ValuesOK) {
+  if (!this->ValuesOK) {
     throw ArpackError(ArpackError::VALUES_NOT_OK, "EigenvalueImag(i)");
   }
-  else if ((i>=nconv)||(i<0)) {
+  else if ((i>=this->nconv)||(i<0)) {
     throw ArpackError(ArpackError::RANGE_ERROR, "EigenvalueImag(i)");
   }
-  return EigValI[i];
+  return this->EigValI[i];
 
 } // EigenvalueImag(i).
 
@@ -554,21 +555,21 @@ Eigenvector(int i, int j)
 
   // Returning element j of i-eth eigenvector.
 
-  if ((!VectorsOK)||(!ValuesOK)) {
+  if ((!this->VectorsOK)||(!this->ValuesOK)) {
     throw ArpackError(ArpackError::VECTORS_NOT_OK, "Eigenvector(i,j)");
   }
-  else if ((i>=nconv)||(i<0)||(j>=n)||(j<0)) {
+  else if ((i>=this->nconv)||(i<0)||(j>=this->n)||(j<0)) {
     throw ArpackError(ArpackError::RANGE_ERROR, "Eigenvector(i,j)");
   }
-  if (EigValI[i]==(ARFLOAT)0.0) {   // Real eigenvalue.
-    return arcomplex<ARFLOAT>(EigVec[i*n+j],(ARFLOAT)0.0);
+  if (this->EigValI[i]==(ARFLOAT)0.0) {   // Real eigenvalue.
+    return arcomplex<ARFLOAT>(this->EigVec[i*this->n+j],(ARFLOAT)0.0);
   }
   else {                            // Complex eigenvalue.
-    if (EigValI[i]>(ARFLOAT)0.0) {  // with positive imaginary part.
-      return arcomplex<ARFLOAT>(EigVec[i*n+j], EigVec[(i+1)*n+j]);
+    if (this->EigValI[i]>(ARFLOAT)0.0) {  // with positive imaginary part.
+      return arcomplex<ARFLOAT>(this->EigVec[i*this->n+j], this->EigVec[(i+1)*this->n+j]);
     }
     else {                          // with negative imaginary part.
-      return arcomplex<ARFLOAT>(EigVec[(i-1)*n+j], -EigVec[i*n+j]);
+      return arcomplex<ARFLOAT>(this->EigVec[(i-1)*this->n+j], -this->EigVec[i*this->n+j]);
     }
   }
 
@@ -582,13 +583,13 @@ inline ARFLOAT ARrcNonSymStdEig<ARFLOAT>
 
   // Returning the real part of element j of i-eth eigenvector.
 
-  if (!VectorsOK) {
+  if (!this->VectorsOK) {
     throw ArpackError(ArpackError::VECTORS_NOT_OK, "EigenvectorReal(i,j)");
   }
-  else if ((i>=nconv)||(i<0)||(j>=n)||(j<0)) {
+  else if ((i>=this->nconv)||(i<0)||(j>=this->n)||(j<0)) {
     throw ArpackError(ArpackError::RANGE_ERROR, "EigenvectorReal(i,j)");
   }
-  return EigVec[i*n+j];
+  return this->EigVec[i*this->n+j];
 
 } // EigenvectorReal(i,j).
 
@@ -599,21 +600,21 @@ inline ARFLOAT ARrcNonSymStdEig<ARFLOAT>
 
   // Returning the imaginary part of element j of i-eth eigenvector.
 
-  if ((!VectorsOK)||(!ValuesOK)) {
+  if ((!this->VectorsOK)||(!this->ValuesOK)) {
     throw ArpackError(ArpackError::VECTORS_NOT_OK, "EigenvectorImag(i,j)");
   }
-  else if ((i>=nconv)||(i<0)||(j>=n)||(j<0)) {
+  else if ((i>=this->nconv)||(i<0)||(j>=this->n)||(j<0)) {
     throw ArpackError(ArpackError::RANGE_ERROR, "EigenvectorImag(i,j)");
   }
-  if (EigValI[i]==(ARFLOAT)0.0) {   // Real eigenvalue.
+  if (this->EigValI[i]==(ARFLOAT)0.0) {   // Real eigenvalue.
     return (ARFLOAT)0.0;
   }
   else {                            // Complex eigenvalue.
-    if (EigValI[i]>(ARFLOAT)0.0) {  // with positive imaginary part.
-      return EigVec[(i+1)*n+j];
+    if (this->EigValI[i]>(ARFLOAT)0.0) {  // with positive imaginary part.
+      return this->EigVec[(i+1)*this->n+j];
     }
     else {                          // with negative imaginary part.
-      return -EigVec[i*n+j];
+      return -this->EigVec[i*this->n+j];
     }
   }
 
@@ -624,10 +625,10 @@ template<class ARFLOAT>
 inline ARFLOAT* ARrcNonSymStdEig<ARFLOAT>::RawEigenvaluesImag()
 {
 
-  if (!ValuesOK) {
+  if (!this->ValuesOK) {
     throw ArpackError(ArpackError::VALUES_NOT_OK, "RawEigenvaluesImag");
   }
-  return EigValI;
+  return this->EigValI;
 
 } // RawEigenvaluesImag.
 
@@ -822,7 +823,7 @@ ARrcNonSymStdEig(int np, int nevp, char*
 
 {
 
-  NoShift();
+  this->NoShift();
   DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (regular mode).
@@ -847,7 +848,7 @@ operator=(const ARrcNonSymStdEig<ARFLOAT
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arrssym.h arpack++1.2.patched/include/arrssym.h
--- arpack++1.2.orig/include/arrssym.h	2000-03-03 21:29:21.000000000 +0100
+++ arpack++1.2.patched/include/arrssym.h	2006-01-26 15:37:50.000000000 +0100
@@ -17,7 +17,7 @@
 #ifndef ARRSSYM_H
 #define ARRSSYM_H
 
-#include <stddef.h>
+#include <cstddef>
 #include "arch.h"
 #include "arerror.h"
 #include "debug.h"
@@ -157,10 +157,10 @@ template<class ARFLOAT>
 inline void ARrcSymStdEig<ARFLOAT>::WorkspaceAllocate()
 {
 
-  lworkl  = ncv*(ncv+9);
-  lworkv  = 0;
-  lrwork  = 0;
-  workl   = new ARFLOAT[lworkl+1];
+  this->lworkl  = this->ncv*(this->ncv+9);
+  this->lworkv  = 0;
+  this->lrwork  = 0;
+  this->workl   = new ARFLOAT[this->lworkl+1];
 
 } // WorkspaceAllocate.
 
@@ -169,8 +169,8 @@ template<class ARFLOAT>
 inline void ARrcSymStdEig<ARFLOAT>::Aupp()
 {
 
-  saupp(ido, bmat, n, which, nev, tol, resid, ncv, V, n,
-        iparam, ipntr, workd, workl, lworkl, info);
+  saupp(this->ido, this->bmat, this->n, this->which, this->nev, this->tol, this->resid, this->ncv, this->V, this->n,
+        this->iparam, this->ipntr, this->workd, this->workl, this->lworkl, this->info);
 
 } // Aupp.
 
@@ -179,9 +179,9 @@ template<class ARFLOAT>
 inline void ARrcSymStdEig<ARFLOAT>::Eupp()
 {
 
-  seupp(rvec, HowMny, EigValR, EigVec, n, sigmaR, bmat,
-        n, which, nev, tol, resid, ncv, V, n, iparam,
-        ipntr, workd, workl, lworkl, info);
+  seupp(this->rvec, this->HowMny, this->EigValR, this->EigVec, this->n, this->sigmaR, this->bmat,
+        this->n, this->which, this->nev, this->tol, this->resid, this->ncv, this->V, this->n, this->iparam,
+        this->ipntr, this->workd, this->workl, this->lworkl, this->info);
 
 } // Eupp.
 
@@ -211,13 +211,13 @@ template<class ARFLOAT>
 ARFLOAT* ARrcSymStdEig<ARFLOAT>::PutVector()
 {
 
-  switch (ido) {
+  switch (this->ido) {
   case -1:
   case  1:                    // Returning OP*x.
   case  2:
-    return &workd[ipntr[2]];  // Returning B*x.
+    return &this->workd[this->ipntr[2]];  // Returning B*x.
   case  3:
-    return &workl[ipntr[11]]; // Returning shifts.
+    return &this->workl[this->ipntr[11]]; // Returning shifts.
   default:
     throw ArpackError(ArpackError::CANNOT_PUT_VECTOR, "PutVector");
   }
@@ -230,36 +230,36 @@ int ARrcSymStdEig<ARFLOAT>::
 Eigenvalues(ARFLOAT* &EigValp, bool ivec, bool ischur)
 {
 
-  if (ValuesOK) {                      // Eigenvalues are available.
+  if (this->ValuesOK) {                      // Eigenvalues are available.
     if (EigValp == NULL) {             // Moving eigenvalues.
-      EigValp  = EigValR;
-      EigValR  = NULL;
-      newVal   = false;
-      ValuesOK = false;
+      EigValp  = this->EigValR;
+      this->EigValR  = NULL;
+      this->newVal   = false;
+      this->ValuesOK = false;
     }
     else {                             // Copying eigenvalues.
-      copy(nconv,EigValR,1,EigValp,1);
+      copy(this->nconv,this->EigValR,1,EigValp,1);
     }
   }
   else {                               // Eigenvalues are not available.
-    if (newVal) {
-      delete[] EigValR;
-      newVal = false;
+    if (this->newVal) {
+      delete[] this->EigValR;
+      this->newVal = false;
     }
     if (EigValp == NULL) {
-      try { EigValp = new ARFLOAT[ValSize()]; }
+      try { EigValp = new ARFLOAT[this->ValSize()]; }
       catch (ArpackError) { return 0; }
     }
-    EigValR = EigValp;
+    this->EigValR = EigValp;
     if (ivec) {                        // Finding eigenvalues and eigenvectors.
-      nconv = FindEigenvectors(ischur);
+      this->nconv = this->FindEigenvectors(ischur);
     }
     else {                             // Finding eigenvalues only.
-      nconv = FindEigenvalues();
+      this->nconv = this->FindEigenvalues();
     }
-    EigValR = NULL;
+    this->EigValR = NULL;
   }
-  return nconv;
+  return this->nconv;
 
 } // Eigenvalues(EigValp, ivec, ischur).
 
@@ -269,31 +269,31 @@ int ARrcSymStdEig<ARFLOAT>::
 EigenValVectors(ARFLOAT* &EigVecp, ARFLOAT* &EigValp, bool ischur)
 {
 
-  if (ValuesOK) {                  // Eigenvalues are already available .
-    nconv = Eigenvalues(EigValp, false);
-    nconv = Eigenvectors(EigVecp, ischur);
+  if (this->ValuesOK) {                  // Eigenvalues are already available .
+    this->nconv = Eigenvalues(EigValp, false);
+    this->nconv = Eigenvectors(EigVecp, ischur);
   }
   else {                           // Eigenvalues and vectors are not available.
     try {
-      if (EigVecp == NULL) EigVecp = new ARFLOAT[ValSize()*n];
-      if (EigValp == NULL) EigValp = new ARFLOAT[ValSize()];
+      if (EigVecp == NULL) EigVecp = new ARFLOAT[this->ValSize()*this->n];
+      if (EigValp == NULL) EigValp = new ARFLOAT[this->ValSize()];
     }
     catch (ArpackError) { return 0; }
-    if (newVec) {
-      delete[] EigVec;
-      newVec = false;
+    if (this->newVec) {
+      delete[] this->EigVec;
+      this->newVec = false;
     }
-    if (newVal) {
-      delete[] EigValR;
-      newVal = false;
+    if (this->newVal) {
+      delete[] this->EigValR;
+      this->newVal = false;
     }
-    EigVec  = EigVecp;
-    EigValR = EigValp;
-    nconv   = FindEigenvectors(ischur);
-    EigVec  = NULL;
-    EigValR = NULL;
+    this->EigVec  = EigVecp;
+    this->EigValR = EigValp;
+    this->nconv   = this->FindEigenvectors(ischur);
+    this->EigVec  = NULL;
+    this->EigValR = NULL;
   }
-  return nconv;
+  return this->nconv;
 
 } // EigenValVectors(EigVecp, EigValp, ischur).
 
@@ -304,13 +304,13 @@ inline ARFLOAT ARrcSymStdEig<ARFLOAT>::E
 
   // Returning i-eth eigenvalue.
 
-  if (!ValuesOK) {
+  if (!this->ValuesOK) {
     throw ArpackError(ArpackError::VALUES_NOT_OK, "Eigenvalue(i)");
   }
-  else if ((i>=nconv)||(i<0)) {
+  else if ((i>=this->nconv)||(i<0)) {
     throw ArpackError(ArpackError::RANGE_ERROR, "Eigenvalue(i)");
   }
-  return EigValR[i];
+  return this->EigValR[i];
 
 } // Eigenvalue(i).
 
@@ -321,13 +321,13 @@ inline ARFLOAT ARrcSymStdEig<ARFLOAT>::E
 
   // Returning element j of i-eth eigenvector.
 
-  if (!VectorsOK) {
+  if (!this->VectorsOK) {
     throw ArpackError(ArpackError::VECTORS_NOT_OK, "Eigenvector(i,j)");
   }
-  else if ((i>=nconv)||(i<0)||(j>=n)||(j<0)) {
+  else if ((i>=this->nconv)||(i<0)||(j>=this->n)||(j<0)) {
     throw ArpackError(ArpackError::RANGE_ERROR, "Eigenvector(i,j)");
   }
-  return EigVec[i*n+j];
+  return this->EigVec[i*this->n+j];
 
 } // Eigenvector(i,j).
 
@@ -385,7 +385,7 @@ ARrcSymStdEig(int np, int nevp, char* wh
 
 {
 
-  NoShift();
+  this->NoShift();
   DefineParameters(np, nevp, whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
 } // Long constructor (regular mode).
@@ -411,7 +411,7 @@ operator=(const ARrcSymStdEig<ARFLOAT>& 
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arscomp.h arpack++1.2.patched/include/arscomp.h
--- arpack++1.2.orig/include/arscomp.h	2000-02-21 14:36:40.000000000 +0100
+++ arpack++1.2.patched/include/arscomp.h	2006-01-26 15:37:50.000000000 +0100
@@ -17,7 +17,8 @@
 #ifndef ARSCOMP_H
 #define ARSCOMP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arseig.h"
 #include "arrscomp.h"
@@ -76,7 +77,7 @@ ARCompStdEig(int np, int nevp, ARFOP* ob
 
 {
 
-  NoShift();
+  this->NoShift();
   DefineParameters(np, nevp, objOPp, MultOPxp, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
 
@@ -106,7 +107,7 @@ operator=(const ARCompStdEig<ARFLOAT, AR
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
@@ -115,4 +116,3 @@ operator=(const ARCompStdEig<ARFLOAT, AR
 
 
 #endif // ARSCOMP_H
-
diff -rupN arpack++1.2.orig/include/arseig.h arpack++1.2.patched/include/arseig.h
--- arpack++1.2.orig/include/arseig.h	2000-03-03 17:14:14.000000000 +0100
+++ arpack++1.2.patched/include/arseig.h	2006-01-26 15:37:50.000000000 +0100
@@ -19,7 +19,7 @@
 #ifndef ARSEIG_H
 #define ARSEIG_H
 
-#include <stddef.h>
+#include <cstddef>
 #include "arch.h"
 #include "arerror.h"
 #include "arrseig.h"
@@ -152,7 +152,7 @@ ChangeMultOPx(ARFOP* objOPp, void (ARFOP
 
   objOP   = objOPp;
   MultOPx = MultOPxp;
-  Restart();
+  this->Restart();
 
 } // ChangeMultOPx.
 
@@ -163,7 +163,7 @@ SetRegularMode(ARFOP* objOPp, void (ARFO
 {
 
   ChangeMultOPx(objOPp, MultOPxp);
-  NoShift();
+  this->NoShift();
 
 } // SetRegularMode.
 
@@ -184,37 +184,37 @@ template<class ARFLOAT, class ARTYPE, cl
 int ARStdEig<ARFLOAT, ARTYPE, ARFOP>::FindArnoldiBasis()
 {
 
-  if (!BasisOK) Restart();
+  if (!this->BasisOK) this->Restart();
 
   // Changing to auto shift mode.
 
-  if (!AutoShift) {
+  if (!this->AutoShift) {
     ArpackError::Set(ArpackError::CHANGING_AUTOSHIFT, "FindArnoldiBasis");
-    AutoShift=true;
+    this->AutoShift=true;
   }
 
   // ARPACK main loop.
 
-  while (!BasisOK) {
+  while (!this->BasisOK) {
 
     // Calling Aupp.
 
-    try { TakeStep(); }
+    try { this->TakeStep(); }
     catch (ArpackError) {
       ArpackError(ArpackError::CANNOT_FIND_BASIS, "FindArnoldiBasis");
       return 0;
     }
 
-    if ((ido == -1) || (ido == 1)) {
+    if ((this->ido == -1) || (this->ido == 1)) {
 
       // Performing Matrix vector multiplication: y <- OP*x.
 
-      (objOP->*MultOPx)(&workd[ipntr[1]],&workd[ipntr[2]]);
+      (objOP->*MultOPx)(&this->workd[this->ipntr[1]],&this->workd[this->ipntr[2]]);
 
     }
 
   }
-  return nconv;
+  return this->nconv;
 
 } // FindArnoldiBasis.
 
@@ -225,7 +225,7 @@ operator=(const ARStdEig<ARFLOAT, ARTYPE
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arsnsym.h arpack++1.2.patched/include/arsnsym.h
--- arpack++1.2.orig/include/arsnsym.h	2000-02-21 13:06:14.000000000 +0100
+++ arpack++1.2.patched/include/arsnsym.h	2006-01-26 15:37:50.000000000 +0100
@@ -17,7 +17,8 @@
 #ifndef ARSNSYM_H
 #define ARSNSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arseig.h"
 #include "arrsnsym.h"
@@ -76,7 +77,7 @@ ARNonSymStdEig(int np, int nevp, ARFOP* 
 
 {
 
-  NoShift();
+  this->NoShift();
   DefineParameters(np, nevp, objOPp, MultOPxp, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
 
@@ -105,7 +106,7 @@ operator=(const ARNonSymStdEig<ARFLOAT, 
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
@@ -114,4 +115,3 @@ operator=(const ARNonSymStdEig<ARFLOAT, 
 
 
 #endif // ARSNSYM_H
-
diff -rupN arpack++1.2.orig/include/arssym.h arpack++1.2.patched/include/arssym.h
--- arpack++1.2.orig/include/arssym.h	2000-02-21 13:05:00.000000000 +0100
+++ arpack++1.2.patched/include/arssym.h	2006-01-26 15:37:50.000000000 +0100
@@ -17,7 +17,8 @@
 #ifndef ARSSYM_H
 #define ARSSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arseig.h"
 #include "arrssym.h"
@@ -76,7 +77,7 @@ ARSymStdEig(int np, int nevp, ARFOP* obj
 
 {
 
-  NoShift();
+  this->NoShift();
   DefineParameters(np, nevp, objOPp, MultOPxp, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
 
@@ -105,7 +106,7 @@ operator=(const ARSymStdEig<ARFLOAT, ARF
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arugcomp.h arpack++1.2.patched/include/arugcomp.h
--- arpack++1.2.orig/include/arugcomp.h	2000-02-21 18:46:32.000000000 +0100
+++ arpack++1.2.patched/include/arugcomp.h	2006-01-26 15:37:50.000000000 +0100
@@ -18,7 +18,8 @@
 #ifndef ARUGCOMP_H
 #define ARUGCOMP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arunsmat.h"
 #include "arunspen.h"
@@ -103,8 +104,8 @@ Copy(const ARluCompGenEig<ARFLOAT>& othe
   ARCompGenEig<ARFLOAT, ARumNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT >,
                ARumNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT> >:: Copy(other);
   Pencil = other.Pencil;
-  objOP  = &Pencil;
-  objB   = &Pencil;
+  this->objOP  = &Pencil;
+  this->objB   = &Pencil;
 
 } // Copy.
 
@@ -114,7 +115,7 @@ inline void ARluCompGenEig<ARFLOAT>::
 ChangeShift(arcomplex<ARFLOAT> sigmaRp)
 {
 
-  objOP->FactorAsB(sigmaRp);
+  this->objOP->FactorAsB(sigmaRp);
   ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmaRp);
 
 } // ChangeShift.
@@ -155,7 +156,7 @@ ARluCompGenEig(int nevp, ARumNonSymMatri
 {
 
   Pencil.DefineMatrices(A, B);
-  NoShift();
+  this->NoShift();
   DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARumNonSymPencil<arcomplex<ARFLOAT>, ARFLOAT>::MultInvBAv,
                    &Pencil, 
@@ -192,7 +193,7 @@ operator=(const ARluCompGenEig<ARFLOAT>&
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arugnsym.h arpack++1.2.patched/include/arugnsym.h
--- arpack++1.2.orig/include/arugnsym.h	2000-02-21 18:42:32.000000000 +0100
+++ arpack++1.2.patched/include/arugnsym.h	2006-01-26 15:37:50.000000000 +0100
@@ -18,7 +18,8 @@
 #ifndef ARUGNSYM_H
 #define ARUGNSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arunsmat.h"
 #include "arunspen.h"
@@ -111,9 +112,9 @@ Copy(const ARluNonSymGenEig<ARFLOAT>& ot
   ARNonSymGenEig<ARFLOAT, ARumNonSymPencil<ARFLOAT, ARFLOAT>,
                  ARumNonSymPencil<ARFLOAT, ARFLOAT> >:: Copy(other);
   Pencil = other.Pencil;
-  objOP  = &Pencil;
-  objB   = &Pencil;
-  objA   = &Pencil;
+  this->objOP  = &Pencil;
+  this->objB   = &Pencil;
+  this->objA   = &Pencil;
 
 } // Copy.
 
@@ -124,10 +125,10 @@ ChangeShift(ARFLOAT sigmaRp, ARFLOAT sig
 {
 
   if (sigmaIp == 0.0) {
-    objOP->FactorAsB(sigmaRp);
+    this->objOP->FactorAsB(sigmaRp);
   }
   else {
-    objOP->FactorAsB(sigmaRp, sigmaIp, part);
+    this->objOP->FactorAsB(sigmaRp, sigmaIp, this->part);
   }
   ARrcNonSymGenEig<ARFLOAT>::ChangeShift(sigmaRp, sigmaIp);
 
@@ -179,7 +180,7 @@ ARluNonSymGenEig(int nevp, ARumNonSymMat
 {
 
   Pencil.DefineMatrices(A, B);
-  NoShift();
+  this->NoShift();
   DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARumNonSymPencil<ARFLOAT, ARFLOAT>::MultInvBAv, &Pencil,
                    &ARumNonSymPencil<ARFLOAT, ARFLOAT>::MultBv, whichp,
@@ -233,7 +234,7 @@ operator=(const ARluNonSymGenEig<ARFLOAT
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arugsym.h arpack++1.2.patched/include/arugsym.h
--- arpack++1.2.orig/include/arugsym.h	2000-02-21 18:00:41.000000000 +0100
+++ arpack++1.2.patched/include/arugsym.h	2006-01-26 15:37:50.000000000 +0100
@@ -19,7 +19,8 @@
 #ifndef ARUGSYM_H
 #define ARUGSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arusmat.h"
 #include "aruspen.h"
@@ -105,9 +106,9 @@ Copy(const ARluSymGenEig<ARFLOAT>& other
   ARSymGenEig<ARFLOAT, ARumSymPencil<ARFLOAT>,
               ARumSymPencil<ARFLOAT> >:: Copy(other);
   Pencil = other.Pencil;
-  objOP  = &Pencil;
-  objB   = &Pencil;
-  objA   = &Pencil;
+  this->objOP  = &Pencil;
+  this->objB   = &Pencil;
+  this->objA   = &Pencil;
 
 } // Copy.
 
@@ -116,7 +117,7 @@ template<class ARFLOAT>
 inline void ARluSymGenEig<ARFLOAT>::ChangeShift(ARFLOAT sigmap)
 {
 
-  objOP->FactorAsB(sigmap);
+  this->objOP->FactorAsB(sigmap);
   ARrcSymGenEig<ARFLOAT>::ChangeShift(sigmap);
 
 } // ChangeShift.
@@ -178,8 +179,8 @@ ARluSymGenEig(int nevp, ARumSymMatrix<AR
 {
 
   Pencil.DefineMatrices(A, B);
-  InvertMode = 'S';
-  NoShift();
+  this->InvertMode = 'S';
+  this->NoShift();
   DefineParameters(A.ncols(), nevp, &Pencil,
                    &ARumSymPencil<ARFLOAT>::MultInvBAv, &Pencil,
                    &ARumSymPencil<ARFLOAT>::MultBv, whichp,
@@ -202,8 +203,8 @@ ARluSymGenEig(char InvertModep, int nevp
                    &ARumSymPencil<ARFLOAT>::MultInvAsBv, &Pencil,
                    &ARumSymPencil<ARFLOAT>::MultBv, whichp,
                    ncvp, tolp, maxitp, residp, ishiftp);
-  InvertMode = CheckInvertMode(InvertModep);
-  switch (InvertMode) {
+  this->InvertMode = this->CheckInvertMode(InvertModep);
+  switch (this->InvertMode) {
   case 'B':  // Buckling mode.
     ChangeMultBx(&Pencil, &ARumSymPencil<ARFLOAT>::MultAv);
   case 'S':  // Shift and invert mode.
@@ -222,7 +223,7 @@ operator=(const ARluSymGenEig<ARFLOAT>& 
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+   this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arunsmat.h arpack++1.2.patched/include/arunsmat.h
--- arpack++1.2.orig/include/arunsmat.h	2000-02-21 17:42:41.000000000 +0100
+++ arpack++1.2.patched/include/arunsmat.h	2006-01-26 15:37:50.000000000 +0100
@@ -20,7 +20,8 @@
 #ifndef ARUNSMAT_H
 #define ARUNSMAT_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "armat.h"
 #include "arhbmat.h"
@@ -145,16 +146,16 @@ bool ARumNonSymMatrix<ARTYPE, ARFLOAT>::
   // Checking if pcol is in ascending order.
 
   i = 0;
-  while ((i!=n)&&(pcol[i]<=pcol[i+1])) i++;
-  if (i!=n) return false;
+  while ((i!=this->n)&&(pcol[i]<=pcol[i+1])) i++;
+  if (i!=this->n) return false;
 
   // Checking if irow components are in order and within bounds.
 
-  for (i=0; i!=n; i++) {
+  for (i=0; i!=this->n; i++) {
     j = pcol[i];
     k = pcol[i+1]-1;
     if (j<=k) {
-      if ((irow[j]<0)||(irow[k]>=n)) return false;
+      if ((irow[j]<0)||(irow[k]>=this->n)) return false;
       while ((j!=k)&&(irow[j]<irow[j+1])) j++;
       if (j!=k) return false;
     }  
@@ -190,9 +191,9 @@ Copy(const ARumNonSymMatrix<ARTYPE, ARFL
 
   // Copying very fundamental variables and user-defined parameters.
 
-  m         = other.m;
-  n         = other.n;
-  defined   = other.defined;
+  this->m         = other.m;
+  this->n         = other.n;
+  this->defined   = other.defined;
   factored  = other.factored;
   fillin    = other.fillin;
   nnz       = other.nnz;
@@ -205,7 +206,7 @@ Copy(const ARumNonSymMatrix<ARTYPE, ARFL
 
   // Returning from here if "other" was not initialized.
 
-  if (!defined) return;
+  if (!this->defined) return;
 
   // Copying arrays with static dimension.
 
@@ -237,10 +238,10 @@ void ARumNonSymMatrix<ARTYPE, ARFLOAT>::
   // Subtracting sigma from diagonal elements.
 
   k        = 0;
-  ki       = n+1;
+  ki       = this->n+1;
   index[0] = 1;
 
-  for (i=0; i!=n; i++) {
+  for (i=0; i!=this->n; i++) {
 
     j = pcol[i];
     end = pcol[i+1];
@@ -280,11 +281,11 @@ template<class ARTYPE, class ARFLOAT>
 inline void ARumNonSymMatrix<ARTYPE, ARFLOAT>::CreateStructure()
 {
 
-  int dimfact = (((fillin+1)*nnz)<(n*n)) ? (fillin+1)*nnz : n*n;
+  int dimfact = (((fillin+1)*nnz)<(this->n*this->n)) ? (fillin+1)*nnz : this->n*this->n;
 
-  ClearMem();
+  this->ClearMem();
 
-  lindex = 30*n+dimfact;     // ?????
+  lindex = 30*this->n+dimfact;     // ?????
   lvalue = dimfact;
 
   value  = new ARTYPE[lvalue];
@@ -319,13 +320,13 @@ void ARumNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED,"ARumNonSymMatrix::FactorA");
   }
 
   // Quitting the function if A is not square.
 
-  if (m != n) {
+  if (this->m != this->n) {
     throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
                       "ARumNonSymMatrix::FactorA");
   }
@@ -344,13 +345,13 @@ void ARumNonSymMatrix<ARTYPE, ARFLOAT>::
   copy(nnz, a, 1, value, 1);
   pi=pcol;
   pj=index;
-  for (i=0; i<=n; i++) *pj++ = (*pi++)+1;
+  for (i=0; i<=this->n; i++) *pj++ = (*pi++)+1;
   pi=irow;
   for (i=0; i<nnz; i++) *pj++ = (*pi++)+1;
 
   // Decomposing A.
 
-  um2fa(n, nnz, 0, false, lvalue, lindex, value, 
+  um2fa(this->n, nnz, 0, false, lvalue, lindex, value, 
         index, keep, cntl, icntl, info, rinfo);
 
   // Handling errors.
@@ -368,14 +369,14 @@ void ARumNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED,
                       "ARumNonSymMatrix::FactorAsI");
   }
 
   // Quitting the function if A is not square.
 
-  if (m != n) {
+  if (this->m != this->n) {
     throw ArpackError(ArpackError::NOT_SQUARE_MATRIX,
                       "ARumNonSymMatrix::FactorAsI");
   }
@@ -390,7 +391,7 @@ void ARumNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Decomposing AsI.
 
-  um2fa(n, nnz, 0, false, lvalue, lindex, value,
+  um2fa(this->n, nnz, 0, false, lvalue, lindex, value,
         index, keep, cntl, icntl, info, rinfo);
 
   // Handling errors.
@@ -411,15 +412,15 @@ void ARumNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARumNonSymMatrix::MultMv");
   }
 
   // Determining w = M.v.
 
-  for (i=0; i!=m; i++) w[i]=(ARTYPE)0;
+  for (i=0; i!=this->m; i++) w[i]=(ARTYPE)0;
 
-  for (i=0; i!=n; i++) {
+  for (i=0; i!=this->n; i++) {
     t = v[i];
     for (j=pcol[i]; j!=pcol[i+1]; j++) {
       w[irow[j]] += t*a[j];
@@ -438,13 +439,13 @@ void ARumNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED,"ARumNonSymMatrix::MultMtv");
   }
 
   // Determining w = M'.v.
 
-  for (i=0; i!=n; i++) {
+  for (i=0; i!=this->n; i++) {
     t = (ARTYPE)0;
     for (j=pcol[i]; j!=pcol[i+1]; j++) {
       t += v[irow[j]]*a[j];
@@ -459,7 +460,7 @@ template<class ARTYPE, class ARFLOAT>
 void ARumNonSymMatrix<ARTYPE, ARFLOAT>::MultMtMv(ARTYPE* v, ARTYPE* w)
 {
 
-  ARTYPE* t = new ARTYPE[m];
+  ARTYPE* t = new ARTYPE[this->m];
 
   MultMv(v,t);
   MultMtv(t,w);
@@ -473,7 +474,7 @@ template<class ARTYPE, class ARFLOAT>
 void ARumNonSymMatrix<ARTYPE, ARFLOAT>::MultMMtv(ARTYPE* v, ARTYPE* w)
 {
 
-  ARTYPE* t = new ARTYPE[n];
+  ARTYPE* t = new ARTYPE[this->n];
 
   MultMtv(v,t);
   MultMv(t,w);
@@ -487,8 +488,8 @@ template<class ARTYPE, class ARFLOAT>
 void ARumNonSymMatrix<ARTYPE, ARFLOAT>::Mult0MMt0v(ARTYPE* v, ARTYPE* w)
 {
 
-  MultMv(&v[m],w);
-  MultMtv(v,&w[m]);
+  MultMv(&v[this->m],w);
+  MultMtv(v,&w[this->m]);
 
 } // Mult0MMt0v.
 
@@ -506,9 +507,9 @@ void ARumNonSymMatrix<ARTYPE, ARFLOAT>::
 
   // Solving A.w = v (or AsI.w = v).
 
-  ARTYPE* space = new ARTYPE[2*n];
+  ARTYPE* space = new ARTYPE[2*this->n];
 
-  um2so(n, 0, false, lvalue, lindex, value, index,
+  um2so(this->n, 0, false, lvalue, lindex, value, index,
         keep, v, w, space, cntl, icntl, info, rinfo);
 
   delete[] space;
@@ -525,13 +526,13 @@ DefineMatrix(int np, int nnzp, ARTYPE* a
 
   // Defining member variables.
 
-  m         = np;
-  n         = np;
+  this->m         = np;
+  this->n         = np;
   nnz       = nnzp;
   a         = ap;
   irow      = irowp;
   pcol      = pcolp;
-  pcol[n]   = nnz;
+  pcol[this->n]   = nnz;
   fillin    = (fillinp>2) ? fillinp : 2;
   threshold = thresholdp;
   value     = NULL;
@@ -548,7 +549,7 @@ DefineMatrix(int np, int nnzp, ARTYPE* a
                       "ARumNonSymMatrix::DefineMatrix");
   }
   else {
-    defined = true;
+    this->defined = true;
   }
 
 } // DefineMatrix (square).
@@ -561,15 +562,15 @@ DefineMatrix(int mp, int np, int nnzp, A
 
   // Defining member variables.
 
-  m        = mp;
-  n        = np;
+  this->m        = mp;
+  this->n        = np;
   nnz      = nnzp;
   a        = ap;
   irow     = irowp;
   pcol     = pcolp;
-  pcol[n]  = nnz;
+  pcol[this->n]  = nnz;
   fillin   = 0;
-  defined  = true;
+  this->defined  = true;
 
 } // DefineMatrix (rectangular).
 
diff -rupN arpack++1.2.orig/include/aruscomp.h arpack++1.2.patched/include/aruscomp.h
--- arpack++1.2.orig/include/aruscomp.h	2000-02-21 18:38:55.000000000 +0100
+++ arpack++1.2.patched/include/aruscomp.h	2006-01-26 15:37:50.000000000 +0100
@@ -18,7 +18,8 @@
 #ifndef ARUSCOMP_H
 #define ARUSCOMP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arscomp.h"
 #include "arunsmat.h"
@@ -84,7 +85,7 @@ inline void ARluCompStdEig<ARFLOAT>::
 ChangeShift(arcomplex<ARFLOAT> sigmaRp)
 {
 
-  objOP->FactorAsI(sigmaRp);
+  this->objOP->FactorAsI(sigmaRp);
   ARrcStdEig<ARFLOAT, arcomplex<ARFLOAT> >::ChangeShift(sigmaRp);
 
 } // ChangeShift.
@@ -96,7 +97,7 @@ inline void ARluCompStdEig<ARFLOAT>::Set
 
   ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
            ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
-    SetRegularMode(objOP, 
+    SetRegularMode(this->objOP, 
                    &ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv);
 
 } // SetRegularMode.
@@ -109,7 +110,7 @@ SetShiftInvertMode(arcomplex<ARFLOAT> si
 
   ARStdEig<ARFLOAT, arcomplex<ARFLOAT>, 
            ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT> >::
-    SetShiftInvertMode(sigmap, objOP,
+    SetShiftInvertMode(sigmap, this->objOP,
                        &ARumNonSymMatrix<arcomplex<ARFLOAT>,ARFLOAT>::MultInvv);
 
 } // SetShiftInvertMode.
@@ -123,7 +124,7 @@ ARluCompStdEig(int nevp, ARumNonSymMatri
 
 {
 
-  NoShift();
+  this->NoShift();
   DefineParameters(A.ncols(), nevp, &A,
                    &ARumNonSymMatrix<arcomplex<ARFLOAT>, ARFLOAT>::MultMv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
@@ -154,7 +155,7 @@ operator=(const ARluCompStdEig<ARFLOAT>&
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/arusmat.h arpack++1.2.patched/include/arusmat.h
--- arpack++1.2.orig/include/arusmat.h	2000-02-21 17:53:51.000000000 +0100
+++ arpack++1.2.patched/include/arusmat.h	2006-01-26 15:37:50.000000000 +0100
@@ -20,7 +20,8 @@
 #ifndef ARUSMAT_H
 #define ARUSMAT_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "armat.h"
 #include "arhbmat.h"
@@ -125,12 +126,12 @@ bool ARumSymMatrix<ARTYPE>::DataOK()
   // Checking if pcol is in ascending order.
 
   i = 0;
-  while ((i!=n)&&(pcol[i]<=pcol[i+1])) i++;
-  if (i!=n) return false;
+  while ((i!=this->n)&&(pcol[i]<=pcol[i+1])) i++;
+  if (i!=this->n) return false;
 
   // Checking if irow components are in order and within bounds.
 
-  for (i=0; i!=n; i++) {
+  for (i=0; i!=this->n; i++) {
     j = pcol[i];
     k = pcol[i+1]-1;
     if (j<=k) {
@@ -138,7 +139,7 @@ bool ARumSymMatrix<ARTYPE>::DataOK()
         if ((irow[j]<0)||(irow[k]>i)) return false;
       }
       else { // uplo == 'L'.
-        if ((irow[j]<i)||(irow[k]>=n)) return false;
+        if ((irow[j]<i)||(irow[k]>=this->n)) return false;
       }
       while ((j!=k)&&(irow[j]<irow[j+1])) j++;
       if (j!=k) return false;
@@ -174,9 +175,9 @@ void ARumSymMatrix<ARTYPE>::Copy(const A
 
   // Copying very fundamental variables and user-defined parameters.
 
-  m         = other.m;
-  n         = other.n;
-  defined   = other.defined;
+  this->m         = other.m;
+  this->n         = other.n;
+  this->defined   = other.defined;
   factored  = other.factored;
   fillin    = other.fillin;
   nnz       = other.nnz;
@@ -190,7 +191,7 @@ void ARumSymMatrix<ARTYPE>::Copy(const A
 
   // Returning from here if "other" was not initialized.
 
-  if (!defined) return;
+  if (!this->defined) return;
 
   // Copying arrays with static dimension.
 
@@ -226,13 +227,13 @@ void ARumSymMatrix<ARTYPE>::ExpandA(ARTY
 
   // Filling index with zeros.
 
-  for (i=0; i<=n; i++) index[i] = 0;
+  for (i=0; i<=this->n; i++) index[i] = 0;
 
   // Counting the elements in each column of A.
 
   if (uplo == 'U') {
 
-    for (i=0; i!=n; i++) {
+    for (i=0; i!=this->n; i++) {
       k = pcol[i+1];
       if ((k!=pcol[i])&&(irow[k-1]==i)) {
         k--;
@@ -246,7 +247,7 @@ void ARumSymMatrix<ARTYPE>::ExpandA(ARTY
   }
   else { // uplo == 'L'
 
-    for (i=0; i!=n; i++) {
+    for (i=0; i!=this->n; i++) {
       k = pcol[i];
       if ((k!=pcol[i+1])&&(irow[k]==i)) {
         k++;
@@ -261,20 +262,20 @@ void ARumSymMatrix<ARTYPE>::ExpandA(ARTY
 
   // Summing up index elements.
 
-  for (i=0; i<n; i++) index[i+1]+=index[i];
+  for (i=0; i<this->n; i++) index[i+1]+=index[i];
 
   // Adding pcol to index.
 
-  for (i=n; i>0; i--) index[i] = index[i-1]+pcol[i];
+  for (i=this->n; i>0; i--) index[i] = index[i-1]+pcol[i];
   index[0] = pcol[0];    
 
   // Expanding A.
 
-  ki = n+1;
+  ki = this->n+1;
 
   if (uplo == 'U') {
 
-    for (i=0; i<n; i++) {
+    for (i=0; i<this->n; i++) {
       for (j=pcol[i]; j<(pcol[i+1]-1); j++) {
         index[ki+index[i]] = irow[j]+1;
         index[ki+index[irow[j]]] = i+1; 
@@ -301,7 +302,7 @@ void ARumSymMatrix<ARTYPE>::ExpandA(ARTY
   }
   else { // uplo  == 'L'
 
-    for (i=0; i<n; i++) {
+    for (i=0; i<this->n; i++) {
       k=pcol[i];
       if ((k!=pcol[i+1])&&(irow[k]==i)) {
         index[ki+index[i]] = i+1;
@@ -331,7 +332,7 @@ void ARumSymMatrix<ARTYPE>::ExpandA(ARTY
 
   // Adjusting index.
 
-  for (i=n; i>0; i--) {
+  for (i=this->n; i>0; i--) {
     index[i] = index[i-1]+1;
   } 
   index[0] = 1;
@@ -343,11 +344,11 @@ template<class ARTYPE>
 inline void ARumSymMatrix<ARTYPE>::CreateStructure()
 {
 
-  int dimfact = (((fillin+1)*nnz*2)<(n*n)) ? (fillin+1)*nnz*2 : n*n;
+  int dimfact = (((fillin+1)*nnz*2)<(this->n*this->n)) ? (fillin+1)*nnz*2 : this->n*this->n;
 
   ClearMem();
 
-  lindex = 30*n+dimfact;          // ?????
+  lindex = 30*this->n+dimfact;          // ?????
   lvalue = dimfact;
 
   value  = new ARTYPE[lvalue];
@@ -382,7 +383,7 @@ void ARumSymMatrix<ARTYPE>::FactorA()
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARumSymMatrix::FactorA");
   }
 
@@ -396,7 +397,7 @@ void ARumSymMatrix<ARTYPE>::FactorA()
 
   // Decomposing A.
 
-  um2fa(n, index[n], 0, false, lvalue, lindex, value, 
+  um2fa(this->n, index[this->n], 0, false, lvalue, lindex, value, 
         index, keep, cntl, icntl, info, rinfo);
 
   // Handling errors.
@@ -414,7 +415,7 @@ void ARumSymMatrix<ARTYPE>::FactorAsI(AR
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARumSymMatrix::FactorAsI");
   }
 
@@ -428,7 +429,7 @@ void ARumSymMatrix<ARTYPE>::FactorAsI(AR
 
   // Decomposing AsI.
 
-  um2fa(n, index[n], 0, false, lvalue, lindex, value,
+  um2fa(this->n, index[this->n], 0, false, lvalue, lindex, value,
         index, keep, cntl, icntl, info, rinfo);
 
   // Handling errors.
@@ -449,17 +450,17 @@ void ARumSymMatrix<ARTYPE>::MultMv(ARTYP
 
   // Quitting the function if A was not defined.
 
-  if (!IsDefined()) {
+  if (!this->IsDefined()) {
     throw ArpackError(ArpackError::DATA_UNDEFINED, "ARumSymMatrix::MultMv");
   }
 
   // Determining w = M.v.
 
-  for (i=0; i!=m; i++) w[i]=(ARTYPE)0;
+  for (i=0; i!=this->m; i++) w[i]=(ARTYPE)0;
 
   if (uplo == 'U') {
 
-    for (i=0; i!=n; i++) {
+    for (i=0; i!=this->n; i++) {
       t = v[i];
       k = pcol[i+1];
       if ((k!=pcol[i])&&(irow[k-1]==i)) {
@@ -475,7 +476,7 @@ void ARumSymMatrix<ARTYPE>::MultMv(ARTYP
   }
   else {
 
-    for (i=0; i!=n; i++) {
+    for (i=0; i!=this->n; i++) {
       t = v[i];
       k = pcol[i];
       if ((k!=pcol[i+1])&&(irow[k]==i)) {
@@ -506,9 +507,9 @@ void ARumSymMatrix<ARTYPE>::MultInvv(ART
 
   // Solving A.w = v (or AsI.w = v).
 
-  ARTYPE* space = new ARTYPE[2*n];
+  ARTYPE* space = new ARTYPE[2*this->n];
 
-  um2so(n, 0, false, lvalue, lindex, value, index,
+  um2so(this->n, 0, false, lvalue, lindex, value, index,
         keep, v, w, space, cntl, icntl, info, rinfo);
 
   delete[] space;
@@ -525,13 +526,13 @@ DefineMatrix(int np, int nnzp, ARTYPE* a
 
   // Defining member variables.
 
-  m         = np;
-  n         = np;
+  this->m         = np;
+  this->n         = np;
   nnz       = nnzp;
   a         = ap;
   irow      = irowp;
   pcol      = pcolp;
-  pcol[n]   = nnz;
+  pcol[this->n]   = nnz;
   uplo      = uplop;
   fillin    = (fillinp>2) ? fillinp : 2;
   threshold = thresholdp;
@@ -549,7 +550,7 @@ DefineMatrix(int np, int nnzp, ARTYPE* a
                       "ARumSymMatrix::DefineMatrix");
   }
   else {
-    defined = true;
+    this->defined = true;
   }
 
 } // DefineMatrix.
diff -rupN arpack++1.2.orig/include/arusnsym.h arpack++1.2.patched/include/arusnsym.h
--- arpack++1.2.orig/include/arusnsym.h	2000-02-21 18:35:24.000000000 +0100
+++ arpack++1.2.patched/include/arusnsym.h	2006-01-26 15:37:50.000000000 +0100
@@ -18,7 +18,8 @@
 #ifndef ARUSNSYM_H
 #define ARUSNSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arsnsym.h"
 #include "arunsmat.h"
@@ -80,13 +81,13 @@ template<class ARFLOAT>
 inline void ARluNonSymStdEig<ARFLOAT>::ChangeShift(ARFLOAT sigmaRp)
 {
 
-  sigmaR    = sigmaRp;
-  sigmaI    = 0.0;
-  mode      = 3;
-  iparam[7] = mode;
+  this->sigmaR    = sigmaRp;
+  this->sigmaI    = 0.0;
+  this->mode      = 3;
+  this->iparam[7] = this->mode;
 
-  objOP->FactorAsI(sigmaR);
-  Restart();
+  this->objOP->FactorAsI(this->sigmaR);
+  this->Restart();
 
 } // ChangeShift.
 
@@ -96,7 +97,7 @@ inline void ARluNonSymStdEig<ARFLOAT>::S
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARumNonSymMatrix<ARFLOAT, ARFLOAT> >::
-    SetRegularMode(objOP, &ARumNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv);
+    SetRegularMode(this->objOP, &ARumNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv);
 
 } // SetRegularMode.
 
@@ -106,7 +107,7 @@ inline void ARluNonSymStdEig<ARFLOAT>::S
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARumNonSymMatrix<ARFLOAT, ARFLOAT> >::
-    SetShiftInvertMode(sigmap, objOP, 
+    SetShiftInvertMode(sigmap, this->objOP, 
                        &ARumNonSymMatrix<ARFLOAT, ARFLOAT>::MultInvv);
 
 } // SetShiftInvertMode.
@@ -120,7 +121,7 @@ ARluNonSymStdEig(int nevp, ARumNonSymMat
 
 {
 
-  NoShift();
+  this->NoShift();
   DefineParameters(A.ncols(), nevp, &A, 
                    &ARumNonSymMatrix<ARFLOAT, ARFLOAT>::MultMv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
@@ -150,7 +151,7 @@ operator=(const ARluNonSymStdEig<ARFLOAT
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
@@ -159,4 +160,3 @@ operator=(const ARluNonSymStdEig<ARFLOAT
 
 
 #endif // ARUSNSYM_H
-
diff -rupN arpack++1.2.orig/include/arussym.h arpack++1.2.patched/include/arussym.h
--- arpack++1.2.orig/include/arussym.h	2000-02-21 17:57:27.000000000 +0100
+++ arpack++1.2.patched/include/arussym.h	2006-01-26 15:37:50.000000000 +0100
@@ -18,7 +18,8 @@
 #ifndef ARUSSYM_H
 #define ARUSSYM_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arssym.h"
 #include "arusmat.h"
@@ -80,13 +81,13 @@ template<class ARFLOAT>
 inline void ARluSymStdEig<ARFLOAT>::ChangeShift(ARFLOAT sigmaRp)
 {
 
-  sigmaR    = sigmaRp;
-  sigmaI    = 0.0;
-  mode      = 3;
-  iparam[7] = mode;
+  this->sigmaR    = sigmaRp;
+  this->sigmaI    = 0.0;
+  this->mode      = 3;
+  this->iparam[7] = this->mode;
 
-  objOP->FactorAsI(sigmaR);
-  Restart();
+  this->objOP->FactorAsI(this->sigmaR);
+  this->Restart();
 
 } // ChangeShift.
 
@@ -96,7 +97,7 @@ inline void ARluSymStdEig<ARFLOAT>::SetR
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARumSymMatrix<ARFLOAT> >::
-    SetRegularMode(objOP, &ARumSymMatrix<ARFLOAT>::MultMv);
+    SetRegularMode(this->objOP, &ARumSymMatrix<ARFLOAT>::MultMv);
 
 } // SetRegularMode.
 
@@ -106,7 +107,7 @@ inline void ARluSymStdEig<ARFLOAT>::SetS
 {
 
   ARStdEig<ARFLOAT, ARFLOAT, ARumSymMatrix<ARFLOAT> >::
-    SetShiftInvertMode(sigmap, objOP, &ARumSymMatrix<ARFLOAT>::MultInvv);
+    SetShiftInvertMode(sigmap, this->objOP, &ARumSymMatrix<ARFLOAT>::MultInvv);
 
 } // SetShiftInvertMode.
 
@@ -118,7 +119,7 @@ ARluSymStdEig(int nevp, ARumSymMatrix<AR
               int maxitp, ARFLOAT* residp, bool ishiftp)
 {
 
-  NoShift();
+  this->NoShift();
   DefineParameters(A.ncols(), nevp, &A, &ARumSymMatrix<ARFLOAT>::MultMv,
                    whichp, ncvp, tolp, maxitp, residp, ishiftp);
 
@@ -146,7 +147,7 @@ operator=(const ARluSymStdEig<ARFLOAT>& 
 {
 
   if (this != &other) { // Stroustrup suggestion.
-    ClearMem();
+    this->ClearMem();
     Copy(other);
   }
   return *this;
diff -rupN arpack++1.2.orig/include/ceupp.h arpack++1.2.patched/include/ceupp.h
--- arpack++1.2.orig/include/ceupp.h	2000-02-21 12:54:11.000000000 +0100
+++ arpack++1.2.patched/include/ceupp.h	2006-01-26 15:37:50.000000000 +0100
@@ -17,7 +17,8 @@
 #ifndef CEUPP_H
 #define CEUPP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arpackf.h"
 
diff -rupN arpack++1.2.orig/include/neupp.h arpack++1.2.patched/include/neupp.h
--- arpack++1.2.orig/include/neupp.h	2000-02-21 12:51:10.000000000 +0100
+++ arpack++1.2.patched/include/neupp.h	2006-01-26 15:37:50.000000000 +0100
@@ -17,7 +17,8 @@
 #ifndef NEUPP_H
 #define NEUPP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arpackf.h"
 
diff -rupN arpack++1.2.orig/include/seupp.h arpack++1.2.patched/include/seupp.h
--- arpack++1.2.orig/include/seupp.h	2000-02-21 12:57:23.000000000 +0100
+++ arpack++1.2.patched/include/seupp.h	2006-01-26 15:37:50.000000000 +0100
@@ -17,7 +17,8 @@
 #ifndef SEUPP_H
 #define SEUPP_H
 
-#include <stddef.h>
+#include <cstddef>
+
 #include "arch.h"
 #include "arpackf.h"
 
diff -rupN arpack++1.2.orig/Makefile.inc arpack++1.2.patched/Makefile.inc
--- arpack++1.2.orig/Makefile.inc	2000-04-05 14:00:59.000000000 +0200
+++ arpack++1.2.patched/Makefile.inc	2006-01-26 15:37:50.000000000 +0100
@@ -6,7 +6,7 @@
 
 # Defining the machine.
 
-PLAT         = solaris
+PLAT         = linux
 
 # Defining the compiler.
 
@@ -16,7 +16,8 @@ CPP          = g++
 # ARPACKPP_INC is the directory that contains all arpack++ header files.
 # SUPERLU_DIR and UMFPACK_DIR must be set to ARPACKPP_INC.
 
-ARPACKPP_DIR = $(HOME)/arpack++
+#ARPACKPP_DIR = $(HOME)/arpack++
+ARPACKPP_DIR = ../../..
 ARPACKPP_INC = $(ARPACKPP_DIR)/include
 SUPERLU_DIR  = $(ARPACKPP_INC)
 UMFPACK_DIR  = $(ARPACKPP_INC)
@@ -33,14 +34,12 @@ UMFPACK_DIR  = $(ARPACKPP_INC)
 # Other libraries should be defined if the user intends to compile
 # arpack++ on another environment.
 
-ARPACK_LIB   = $(HOME)/lib/arpack_$(PLAT).a
-LAPACK_LIB   = /opt/LAPACK/lapack_$(PLAT).a
-UMFPACK_LIB  = $(HOME)/lib/umfpack_$(PLAT).a
-SUPERLU_LIB  = $(HOME)/lib/superlu_$(PLAT).a
-BLAS_LIB     = /opt/LAPACK/blas_$(PLAT).a 
-FORTRAN_LIBS = /opt/SUNWspro/SC4.0/lib/libF77.a \
-               /opt/SUNWspro/SC4.0/lib/libM77.a \
-               /opt/SUNWspro/SC4.0/lib/libsunmath.a
+ARPACK_LIB   = -larpack
+LAPACK_LIB   = -llapack
+UMFPACK_LIB  = #-lumfpack
+SUPERLU_LIB  = /usr/lib/libsuperlu.a
+BLAS_LIB     = -lblas
+FORTRAN_LIBS = -lg2c
 
 # Defining g++ flags and directories.
 
@@ -49,7 +48,7 @@ CPP_WARNINGS = -Wall -ansi -pedantic-err
 CPP_DEBUG    = -g
 CPP_OPTIM    = -O
 CPP_LIBS     = 
-CPP_INC      = /usr/local/include/g++-3
+CPP_INC      = 
 
 CPP_FLAGS    = $(CPP_DEBUG) -D$(PLAT) -I$(ARPACKPP_INC) -I$(CPP_INC) \
                $(CPP_WARNINGS)
