//============================================================================
//
// This file is part of the Thea project.
//
// This software is covered by the following BSD license, except for portions
// derived from other works which are covered by their respective licenses.
// For full licensing information including reproduction of these external
// licenses, see the file LICENSE.txt provided in the documentation.
//
// Copyright (c) 2011, Stanford University
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright notice,
// this list of conditions and the following disclaimer in the documentation
// and/or other materials provided with the distribution.
//
// * Neither the name of the copyright holders nor the names of contributors
// to this software may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
//============================================================================

#ifndef __Thea_Algorithms_Zernike2_hpp__
#define __Thea_Algorithms_Zernike2_hpp__

#include "../Common.hpp"
#include "../AddressableMatrix.hpp"
#include "../Array.hpp"
#include "../VectorN.hpp"
#include <boost/multi_array.hpp>
#include <complex>

namespace Thea {
namespace Algorithms {

/**
 * Compute Zernike moments of a 2D distribution, represented as a matrix of density values. The density values may be
 * multidimensional, i.e. the matrix elements may be vectors or colors.
 *
 * This class adapts code for the LightField Descriptor from Ding-Yun Chen et al.,
 * http://3d.csie.ntu.edu.tw/~dynamic/3DRetrieval/index.html .
 */
class THEA_API Zernike2
{
  public:
    /** %Options for generating Zernike moments. */
    struct Options
    {
      int angular_steps;  ///< Number of angular steps.
      int radial_steps;   ///< Number of radial steps.
      int lut_radius;     ///< Radius of Zernike basis function for lookup table.

      /** Constructor. */
      Options(int angular_steps_ = 12, int radial_steps_ = 3, int lut_radius_ = 50)
      : angular_steps(angular_steps_), radial_steps(radial_steps_), lut_radius(lut_radius_)
      {}

      /** Get the set of default options. */
      static Options const & defaults() { static Options const def; return def; }

    }; // struct Options

    /** Constructor. */
    Zernike2(Options const & opts_ = Options::defaults());

    /** Get the number of moments generated by a call to compute(). */
    long numMoments() const { return opts.angular_steps * opts.radial_steps; }

    /**
     * Compute Zernike moments of a 2D distribution, represented as a matrix of single-dimensional density values.
     *
     * @param distrib The distribution represented as an addressable matrix of single-dimensional density values.
     * @param center_x The x-coordinate (column) of the center of the non-zero region of the distribution, in matrix
     *   coordinates.
     * @param center_y The y-coordinate (row) of the center of the non-zero region of the distribution, in matrix coordinates.
     * @param radius The radius of the non-zero region of the distribution, measured from the center, in matrix coordinates. All
     *   zero elements can be ignored when specifying this number.
     * @param moments Used to return the Zernike moments, specified in "angle-major, radius-minor" order.
     *
     * @return The number of pixels that have non-zero values and were used to compute the moments.
     */
    template <typename AddressableMatrixT, typename ScalarT>
    long compute(AddressableMatrixT const & distrib, double center_x, double center_y, double radius,
                 TheaArray< std::complex<ScalarT> > & moments) const
    {
      return computeImpl<ScalarT>(distrib, center_x, center_y, radius, moments);
    }

    /**
     * Compute Zernike moments of a 2D distribution, represented as a matrix of multidimensional density values (such as vectors
     * or colors). The density values should allow array addressing (<code>operator[](long i)</code>) and should have a
     * constructor that takes 0 as the (only) argument and constructs the zero density. The template parameter N, inferred from
     * the last argument, must be the same as the number of dimensions of the input.
     *
     * @param distrib The distribution represented as an addressable matrix of density values.
     * @param center_x The x-coordinate (column) of the center of the non-zero region of the distribution, in matrix
     *   coordinates.
     * @param center_y The y-coordinate (row) of the center of the non-zero region of the distribution, in matrix coordinates.
     * @param radius The radius of the non-zero region of the distribution, measured from the center, in matrix coordinates. All
     *   zero elements can be ignored when specifying this number.
     * @param moments Used to return the Zernike moments, specified in "angle-major, radius-minor" order.
     *
     * @return The number of pixels that have non-zero values and were used to compute the moments.
     */
    template <typename AddressableMatrixT, long N, typename ScalarT>
    long compute(AddressableMatrixT const & distrib, double center_x, double center_y, double radius,
                 TheaArray< VectorN< N, std::complex<ScalarT> > > & moments) const
    {
      return computeImpl<ScalarT>(distrib, center_x, center_y, radius, moments);
    }

  private:
    /** Helper function that actually computes the moments. */
    template <typename ScalarT, typename AddressableMatrixT, typename U>
    long computeImpl(AddressableMatrixT const & distrib, double center_x, double center_y, double radius,
                     TheaArray<U> & moments) const;

    /** Generate lookup table for moments. */
    void generateBasisLUT() const;

    /** Add a single-dimensional scaled increment. */
    template <typename U, typename ScalarT>
    static void accum(U const & u, std::complex<double> const & x, std::complex<ScalarT> & acc)
    {
      acc.real() += static_cast<ScalarT>(x.real() * u);
      acc.imag() -= static_cast<ScalarT>(x.imag() * u);
    }

    /** Add a multidimensional scaled increment. */
    template <typename U, long N, typename ScalarT>
    static void accum(U const & u, std::complex<double> const & x, VectorN< N, std::complex<ScalarT> > & acc)
    {
      for (long i = 0; i < N; ++i)
      {
        acc[i].real() += static_cast<ScalarT>(x.real() * u[i]);
        acc[i].imag() -= static_cast<ScalarT>(x.imag() * u[i]);
      }
    }

    typedef boost::multi_array< std::complex<double>, 4 > LUT;  ///< Lookup table class.

    Options opts;                ///< Set of options.
    mutable LUT lut;             ///< Coefficient lookup table.
    mutable bool lut_generated;  ///< Has the LUT been generated?

}; // class Zernike2

template <typename ScalarT, typename AddressableMatrixT, typename U>
long
Zernike2::computeImpl(AddressableMatrixT const & distrib, double center_x, double center_y, double radius,
                      TheaArray<U> & moments) const
{
  alwaysAssertM(radius > 0, "Zernike2: Radius must be greater than zero");

  static typename AddressableMatrixT::Value const IN_ZERO(0);
  static U const OUT_ZERO(std::complex<ScalarT>(0, 0));

  this->generateBasisLUT();

  moments.resize(numMoments());
  std::fill(moments.begin(), moments.end(), OUT_ZERO);

  int ncols = distrib.numColumns();
  int nrows = distrib.numRows();

  // Don't go outside the specified radius
  int min_x = std::max(0,         (int)std::ceil (center_x - radius));
  int max_x = std::min(ncols - 1, (int)std::floor(center_x + radius));

  int min_y = std::max(0,         (int)std::ceil (center_y - radius));
  int max_y = std::min(nrows - 1, (int)std::floor(center_y + radius));

  double r_radius = opts.lut_radius / radius;

  std::complex<double> x1, x2, x3;
  double dx, dy, tx, ty;
  int ix, iy;
  long count = 0;
  for (int y = min_y; y <= max_y; ++y)
  {
    for (int x = min_x; x <= max_x; ++x)
    {
      typename AddressableMatrixT::Value const & density = distrib.get(y, x);
      if (density != IN_ZERO)
      {
        dx = x - center_x;
        dy = y - center_y;
        tx = dx * r_radius + opts.lut_radius;
        ty = dy * r_radius + opts.lut_radius;
        ix = (int)tx;
        iy = (int)ty;
        dx = tx - ix;
        dy = ty - iy;

        // Summation of basis function
        for(int p = 0; p < opts.angular_steps; ++p)
        {
          for(int r = 0; r < opts.radial_steps; ++r)
          {
            x1 = lut[p][r][ix][iy    ] + (lut[p][r][ix + 1][iy    ] - lut[p][r][ix][iy    ]) * dx;
            x2 = lut[p][r][ix][iy + 1] + (lut[p][r][ix + 1][iy + 1] - lut[p][r][ix][iy + 1]) * dx;
            x3 = x1 + (x2 - x1) * dy;

            accum(density, x3, moments[p * opts.radial_steps + r]);
          }
        }

        count++;
      }
    }
  }

  if (count > 0)
  {
    for (array_size_t i = 0; i < moments.size(); ++i)
      moments[i] /= (ScalarT)count;
  }

  return count;
}

} // namespace Algorithms
} // namespace Thea

#endif
